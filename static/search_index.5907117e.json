[{"id":0,"title":"","content":"","routePath":"/404","lang":"","toc":[],"domain":"","frontmatter":{"pageType":404},"version":""},{"id":1,"title":"关于我","content":"#\n\n大家好，我叫 SumyGG。欢迎来到 SumyGG's Blog。\n\n> 从来没想过如何写 关于我 这个板块。所以之前的这个板块一直都是空白。 趁着博客迁移这个机会终于把这个板块填上了。\n\n「SumyGG」这个名字经历了一些演变，最初也想做一个 阳光开朗大男孩 于是叫「SUNNY」，但是这个名字实在撞衫。\n后来就把中间的「NN」合并起来，取了个「M」，形成了雏形「SUMY」。\n但是这个“单词”有点短，去注册名称经常不放行。。。于是加了个「GG」，一方面说明自己游戏很菜，另一方面你可以叫我“哥哥”。\n\n我是一个普通的程序员，目前在一家“互联网”公司做前端开发。\n\n\n我在职#\n\n起止月份                工作单位   部门    职位\n2021.05 ~ 至今        xx     xx    前端研发工程师\n2018.03 ~ 2021.03   京东     大数据   后端研发工程师\n\n\n我在玩#\n\n * Steam：sumy7\n * Switch：SW-3830-3656-4313\n * b站：贝贝二戋Sumy 偶尔会直播一下\n * EXOPHASE ↓\n * \n\n\n我在学#\n\n感谢公司提供的氛围，每天“没事”的时候会做一下力扣题。竞赛很少参加，安心做一个“刷题混子”。\n\n * LeetCode-CN\n * LeetCode-EN\n\n\n我在看#\n\n会挑一些喜欢的番来追，弃坑的也不少。\n\n> 上一版博客有个看过的番剧的模块，但是手动维护。后来觉得太麻烦了，就删掉了。\n> \n> 有个 NAS 存储了一些看过的番。后面再想办法把观看记录导到博客里（就好了）。\n\n\n我在线#\n\n右上角的社交平台链接可以找到我。欢迎一起互动。\n\nEmail：sumygg{at}codepuppies.io\n\n或者也可以在下方留言。","routePath":"/about/","lang":"","toc":[{"text":"我在职","id":"我在职","depth":2,"charIndex":287},{"text":"我在玩","id":"我在玩","depth":2,"charIndex":413},{"text":"我在学","id":"我在学","depth":2,"charIndex":505},{"text":"我在看","id":"我在看","depth":2,"charIndex":591},{"text":"我在线","id":"我在线","depth":2,"charIndex":704}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"归档","content":"","routePath":"/blog/archives","lang":"","toc":[],"domain":"","frontmatter":{"layout":"archives","title":"归档"},"version":""},{"id":3,"title":"分类","content":"","routePath":"/blog/categories","lang":"","toc":[],"domain":"","frontmatter":{"layout":"categories","title":"分类"},"version":""},{"id":4,"title":"友情链接","content":"#\n\n欢迎光顾我的小站。如果你也想和我交换友链，可以在下方留言。\n\n * 笔良文昌 - noclyt\n * 无火的余灰 - AShen One\n * 槽 - 雨rain","routePath":"/blog/flinks","lang":"","toc":[],"domain":"","frontmatter":{"pageType":"doc","title":"友情链接","sidebar":false,"outline":false},"version":""},{"id":5,"title":"标签","content":"","routePath":"/blog/tags","lang":"","toc":[],"domain":"","frontmatter":{"layout":"tags","title":"标签"},"version":""},{"id":6,"title":"引导页","content":"#\n\nTIP\n\n博客还在基于Rspress优化中，敬请期待\n\n正在完善的功能：\n\n * ✅️ 首页文章\n * ✅️ 首页分页\n * ✅️ 文章分类\n * ✅️ 文章标签\n * ✅️ 页面底部\n * ✅️ 文章搜索\n * ✅ 归档页面\n * ✅️ 评论功能\n * ✅️ 谷歌统计\n * ✅️ 左侧菜单\n * ✅️ 上一篇、下一篇\n * ✅️ 文章表情\n * ✅️ latex 公式\n * ✅️ RSS\n * ✅️ 友情链接\n * ✅️ md嵌入HTML\n * ✅️ 文章信息","routePath":"/guide/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"首页","content":"","routePath":"/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"home","title":"首页"},"version":""},{"id":8,"title":"上传splatoon3对战记录到stat.ink","content":"#\n\nstat.ink是一个splatoon系列游戏的对战记录网站，可以上传对战记录，查看自己的对战记录，以及查看其他玩家的对战记录。\n\n虽然三代的NSO相比二代好用了不少，但是对战记录依然只能保留50条，对于一些喜欢查看自己对战记录的玩家来说，总归不是很方便。\n\n本文介绍如何上传splatoon3的对战记录到stat.ink。\n\n\n注册stat.ink账号#\n\n这里不再赘述，打开网站注册一个账号。在个人中心可以找到自己的API key。记录下来，后面需要使用。\n\n\n\n\n安装s3s#\n\ns3s是一个对战记录上传器，它能够访问NSO的对战记录，然后上传到stat.ink。\n\n为了能够使用s3s，需要git和python3工具。如果你是开发人员，这些工具应该已经安装了。如果没有安装，可以自行搜索安装方法。\n\n\n\n\n配置s3s#\n\n执行s3s命令进行启动，这个命令的意思是上传打工记录，并每隔5分钟检查一次。\n\n\n\n\n\n 1. 提示输入API key，输入stat.ink的API key。我这里提前输入过了，就没有提示出来。\n 2. 给出一个链接，用浏览器打开这个链接，登录自己的NSO账号 在【选择此人】上面右键，选择【复制链接地址】，将地址粘贴到命令行中\n 3. 等待s3s校验登录信息，然后就自动上传对战记录了\n\n\n查看对战结果#\n\n上传大概10s一条记录，直接访问命令行里给出的对战记录链接就可以看到自己的对战记录了。\n\n我的打工记录：https://stat.ink/@sumy/salmon3，感兴趣的可以一起来玩。\n\n\ndocker容器部署#\n\n每次手动执行命令很麻烦，而且对战上传服务不稳定，经常上传一段时间后出现SSL认证错误的情况。\n\n所以考虑用docker容器部署s3s服务，并设置每一个小时定时启动上传一次。\n\n我自己有个群晖NAS，所以docker是部署到NAS上的。这里说明一下主要的配置属性。\n\n\n\nconfig.txt是本地s3s生成的配置文件，因为容器无法使用交互式输入登录信息，需要直接使用配置文件。\n\n群晖有计划任务功能，可以设置定时任务，这里设置每小时执行一次。执行的命令行为\n\n\n\n这样就可以实现每小时上传一次对战记录了。\n\nWARNING\n\n如果账号密码或者地区有变动，会存在登录信息失效的问题。\n\n出现这种情况，需要在本地重新走一遍登录流程，生成config.txt并更新到容器里。\n\n\n总结#\n\n通过s3s可以方便的将对战记录上传到stat.ink，而使用docker又能够实现定时上传对战记录的功能。","routePath":"/2024/03/11/upload-splatoon3-battle-records-to-stat-ink/","lang":"","toc":[{"text":"注册stat.ink账号","id":"注册statink账号","depth":2,"charIndex":167},{"text":"安装s3s","id":"安装s3s","depth":2,"charIndex":237},{"text":"配置s3s","id":"配置s3s","depth":2,"charIndex":359},{"text":"查看对战结果","id":"查看对战结果","depth":2,"charIndex":563},{"text":"docker容器部署","id":"docker容器部署","depth":2,"charIndex":669},{"text":"总结","id":"总结","depth":2,"charIndex":1019}],"domain":"","frontmatter":{"layout":"post","title":"上传splatoon3对战记录到stat.ink","date":"2024-03-11T20:00:00.000Z","categories":["游戏人生"],"tags":["splatoon","对战记录","stat-ink","s3s"]},"version":""},{"id":9,"title":"rspress博客插件折腾记录","content":"#\n\n> 首先祝各位姐们儿节日快乐🎉。\n\n之前已经将博客引擎从hexo迁移到了rspress，具体可以参考文章博客引擎迁移到 rspress。\n最近也没有闲着，首先将博客的目录结构改成了menorepo的方式，方便管理博客插件和文章内容。然后就是不断完善博客的功能模块，毕竟别家有的内容，咱也不能落下。\n\n如果你也对SumyBlog某些功能感兴趣，不妨看下这篇文章有没有实现你需要的功能。\n\n\n解析hexo文章#\n\n上一篇文章也说过解析文章的方式，这段时间将功能模块做成了一个基础的插件，提取出文章的元数据（标题、日期、分类、标签等），供其它插件使用。\n\n源码地址：plugin-post-resolver\n\n该插件只是解析了文件名为 YYYY-MM-DD-title.md 格式的文章，并向路由中添加了 /YYYY/MM/DD/title\n的路径。后续考虑将这个路径格式作为一个配置项提供。\n\n\nmarkdown增强#\n\nrspress 默认使用了基于 rust 实现的 @rspress/mdx-rs 来解析 markdown 文件，但是目前还不支持一些常用的 markdown\n扩展， 比如emoji或者mathtex公式。\n\n这里使用了 js 版本的 mdx 解析器，并补充了对 latex 和 emoji 语法解析的默认配置。\n\n源码地址：plugin-markdown-presets\n\n\n谷歌统计#\n\n这个插件是为了方便添加谷歌统计的功能，核心代码就是在 index.html 中添加了谷歌统计的脚本。\n\n源码地址：plugin-google-analytics\n\n\nrss订阅#\n\n这个参考了其它大神的 rss 插件，主要是将文章的元数据转换成 rss 的格式。具体效果可以在博客右上角的社交链接中找到。\n\n核心思路是读取文件，根据文件的元数据生成 rss 的 xml 文件，也是基于 feed\n库处理的元数据。不过文章的摘要生成的存在些问题，这部分还需要重点优化一下。\n\n源码地址：plugin-feed-rss\n\n\n布局改造#\n\n博客的主题基于 rspress 默认的主题进行了一些改造，主要是增加了一些功能模块。\n\n 1. 没有使用主题的 hero 主页模式，自己实现了一个文章列表的主页。\n 2. 增加了文章的阅读信息，比如发布日期、阅读量、文章字数等。\n 3. 增加了评论控件。\n\n\n文章阅读信息#\n\n在文章标题的下发，会展示一些文章的阅读信息，比如文章的发布日期、阅读量、文章字数等。\n\n文章信息的位置考虑了好久，由于rspress对文章内容的渲染提供的定制化能力比较少，\n一直没有找到好的方法将这些信息放在文章的头部。一段时间考虑先放到了文章目录的上方。\n\n后来发现，通过重写并导出 getCustomMDXComponent 方法，就能够自定义文章元素的渲染逻辑。于是重写了 h1\n标签的渲染逻辑后，最终将文章信息放在了文章标题的下方。 :tada:\n\n文章的阅读量使用的是 busuanzi ，不过网上的库都不是很好的兼容 esm 的模块化，所以这里自己通过 fetch-jsonp 的方式去请求页面数据。\n\n字数统计和阅读时间参考了其它大神的实现。 效果也是杠杠的。\n\n\n评论控件#\n\n评论控件基于 giscus 实现。可以借助 GitHub Discussions 的功能实现评论的存储和展示。\n\n以前也尝试过其它的评论控件，比如 valine、duoshuo 等，但是服务稳定性和数据安全性都不是很好。这次的 giscus 希望能够众望所归。\n\n\n总结#\n\n目前插件的功能已经满足了博客的基本需求，当然也还在不断地完善和改造。如果你对这些插件感兴趣，欢迎一起交流，如果能给这个仓库提交mr就更好了。\n\n后续会考虑将插件发布到npm上，方便大家使用。\n\n\n参考内容#\n\n * ChoDocs 的 VitePress 插件折腾记录\n * 记hexo-theme-even主题优化 - Eason Yang's Blog","routePath":"/2024/03/08/sumy-blog-plugin-for-rspress/","lang":"","toc":[{"text":"解析hexo文章","id":"解析hexo文章","depth":2,"charIndex":197},{"text":"markdown增强","id":"markdown增强","depth":2,"charIndex":399},{"text":"谷歌统计","id":"谷歌统计","depth":2,"charIndex":601},{"text":"rss订阅","id":"rss订阅","depth":2,"charIndex":691},{"text":"布局改造","id":"布局改造","depth":2,"charIndex":868},{"text":"文章阅读信息","id":"文章阅读信息","depth":3,"charIndex":1005},{"text":"评论控件","id":"评论控件","depth":3,"charIndex":1354},{"text":"总结","id":"总结","depth":2,"charIndex":1494},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1597}],"domain":"","frontmatter":{"layout":"post","title":"rspress博客插件折腾记录","date":"2024-03-08T00:00:00.000Z","categories":["博客"],"tags":["rspress","博客插件"]},"version":""},{"id":10,"title":"在博客中插入谷歌广告","content":"#\n\n最近看到博客每天也有点流量，就想着能不能广告薅点羊毛（事实证明并不是那么容易）。 最近博客的引擎切换到了\nrspress，本篇就基于此简单介绍一下如何在博客中插入谷歌广告。\n\n\n注册谷歌广告账号#\n\n打开 Google AdSense 的官网，选择右上角的 “登录” 按钮，选择一个 Google 账号登录。\n\n第一次登录后，会填写网站的基本信息。包括网址、电子邮箱和订阅信息等。\n\n\n\n需要注意的是地区这里选择“中国”。\n\nTIP\n\n地区这里不建议选择“香港”，虽然有港卡会比较方便点，但是后续地址验证和 手机号验证 都需要香港的才可以。\n\n如果之前因为地区选择错误继续注册了，只能通过删除账号的方式才能更换地区。\n\n这样账号注册完成，接下来按照网站的提示，还需要进行三步操作：\n\n\n\n\n提供个人信息#\n\n个人客户信息影响后续收款，所以需要根据具体情况进行填写。\n\n\n\n【姓名和地址】涉及到后续谷歌会向这个地址递送一个Pin码，一定要填写准确。\n\n这样第一步就算完成了。\n\n\n验证网站#\n\n接下来是第三步。为了能够正常展示广告，需要验证网站所有权。（让我们开始吧）\n\n\n\n谷歌这里提供了三种方式验证网站所有权：\n\n * AdSense代码段：在head里插入一段script代码\n * Ads.txt代码段：在public目录下放置一个txt文件，通过(域名)/ads.txt的路径能够访问到\n * 元标记：也是在head里插入一段meta标签代码\n\n可以选一种方式进行验证，我这里选择了Ads.txt代码段。放置好之后发布一下博客，然后点击验证。\n\n验证通过后，需要提交网站审核，谷歌会检查你的网站是否符合广告展示的要求。\n\n\n插入广告代码#\n\n在验证的过程中，别忘了可以创建广告单元，向网站中插入广告。\n\nadsense 提供了两种模式展示广告，一种是自动广告，一种是手动广告。\n\n自动广告是添加一段代码后，谷歌自己判断展示广告的位置，不过这种模式的广告展示位置不太好控制。就怕最后页面所有位置都是广告。\n\n\n\n这里不要选择这种模式，选择手动广告，即创建广告单元。\n\n\n\n选择【展示广告】，填写广告位的名称和大小等配置。\n\n\n\n创建之后，会生成一个广告代码，将这段代码插入到博客要展示广告的位置。\n\n\n\n其中的script标签，在全局引用一次即可。用rspress来说，可以在 rspress.config.ts 中配置注入。\n\n\n\n然后在需要展示的位置插入广告组件，比如在文章的中间插入一个广告。\n\n\n\n每次都写一个广告位组件还是比较麻烦的，后续可以考虑抽离成一个广告组件。目前已经简单实现了一下plugin-google-ads\n\n\n接下来#\n\n广告账号的注册和广告投放已经告一段落了，后续就是优化广告的展示效果，增加博客里广告位。不过还是想继续保持博客简约的风格，就不打算放太多广告了。\n\n接下来还有谷歌Pin码验证，这个等到收到了再说吧，任重而道远。（听说广告收入需要达到10美元的时候，目前0.1美元）\n\n\n参考内容#\n\n * VuePress网站接入Google AdSense广告位 | 千古壹号的博客","routePath":"/2024/02/17/insert-google-adsense-to-blog/","lang":"","toc":[{"text":"注册谷歌广告账号","id":"注册谷歌广告账号","depth":2,"charIndex":91},{"text":"提供个人信息","id":"提供个人信息","depth":2,"charIndex":347},{"text":"验证网站","id":"验证网站","depth":2,"charIndex":441},{"text":"插入广告代码","id":"插入广告代码","depth":2,"charIndex":718},{"text":"接下来","id":"接下来","depth":2,"charIndex":1124},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1264}],"domain":"","frontmatter":{"layout":"post","title":"在博客中插入谷歌广告","date":"2024-02-17T00:00:00.000Z","categories":["博客"],"tags":["rspress","博客插件","谷歌广告"]},"version":""},{"id":11,"title":"我的 GitHub Sponsors 已经开通了","content":"#\n\n自从听到 GitHub Sponsors 的消息之后，就一直在关注这个，就是幻想能被别人赞助“包养”的感觉。于是早早就提交了\nwaitlist，然后就一直等待着。 因为提交的是大陆地区，所以一直没有开通的消息。\n\n前两天去香港旅游（抱歉没留下任何游记，无非就是逛逛逛、买买买）， 看到了银行阴差阳错的进去申请了一下，然后就办下了港卡。\n回来之后一直思考如何将港卡利用起来，然后就想到了 GitHub Sponsors。\n\n\n修改 waitlist 信息#\n\n打开 GitHub Sponsors 的页面，选择那个正在 Pending 的账号/组织。\n\n将地址改成香港的地址，然后重新提交等待审核。\n\n\n填写港卡信息#\n\n审核通过后，需要填写 Stripe 的账号信息，这里就需要填写港卡的信息了。\n\n\n\n开通港卡的时候会给一个回执单，按照回执单上的信息填写即可。\n\n需要补充居住地址（香港的一个地址），银行账户信息，还有账单地址。填写完成这些信息后，就可以提交 Github staff 了。\n\n\n接收赞助#\n\n审核通过后，就可以接收赞助了。你需要做的是想一个好的“乞讨文案”（俺并没有想），给你的 github 项目添加一个 sponsor 按钮。\n\n在项目的添加一个 .github/FUNDING.yml 文件，里面包含的是你的 Github ID。\n\n\n\n可以在这个项目里感受一下最后效果。vite-plugin-generate-file\n\n\n总结#\n\nGitHub Sponsors 是一个很好的平台，可以让你的项目得到更多的关注和支持。如果你有一些开源项目，不妨试试。\n\n也真的希望能有人看中我写的一些“破烂”然后赞助一下。Orz\n\n\n参考内容#\n\n * 我的 GitHub Sponsors 开通啦！ | Surmon.me","routePath":"/2023/12/30/my-github-sponsors-is-active-now/","lang":"","toc":[{"text":"修改 waitlist 信息","id":"修改-waitlist-信息","depth":2,"charIndex":214},{"text":"填写港卡信息","id":"填写港卡信息","depth":2,"charIndex":303},{"text":"接收赞助","id":"接收赞助","depth":2,"charIndex":451},{"text":"总结","id":"总结","depth":2,"charIndex":629},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":727}],"domain":"","frontmatter":{"layout":"post","title":"我的 GitHub Sponsors 已经开通了","date":"2023-12-30T00:00:00.000Z","categories":["杂谈"],"tags":["GitHub Sponsors","港卡"]},"version":""},{"id":12,"title":"模块中默认导出和命名导出的区别","content":"#\n\n最近碰到一个循环依赖的问题，看了下编译后的webpack模块，发现webpack对不同默认导出方式的处理是不同的，跟之前认为的有出入，于是记录一下。\n\n之前觉得在模块中，导出的内容是不可变的，比如导出了一个变量，那么这个变量就是导出时候的内容；如果导出的是一个函数，那么这个函数也是导出函数的引用。\n\n但是实际上，这个并不是绝对的，这个内容可变性取决于导出的方式。\n\n\n导出的是引用，不是值#\n\n在一个模块中，通过命名导出了一个变量 thing。并在 500ms 后修改了这个变量的值。\n\n\n\n那么我们在引用这个变量的时候，会发现这个变量的值是会跟随变化的。\n\n\n\n导入的时候，相当于 引用 了原有模块的变量，这个特性类似于单向绑定。 但是解构赋值是不同的，因为解构的时候已经将变量的值取出来赋予了新的变量，所以不会跟随变化。\n\n\n默认导出是不同的#\n\n类似的有一个默认导出的模块，并在 500ms 后修改了默认导出的值。\n\n\n\n通过模块的 default 入口获取对应的值\n\n\n\n可以发现，不管是具名引用了default还是直接导入了default，获取到的值都是不会变的。\n\n这是因为 export default 类似于一个表达式，它在导出的时候就已经确定了值，而不是一个引用。后续不管怎么变化，都只会是执行语句时候的值。\n\n但是需要注意的是，如果是通过 export { thing as default } 这种命名导出方式导出了默认出口，那么这个值是会跟随变化的。\n\n\n\n\n\n原因嘛，可以参考上一节的说明。\n\n\n其它的说明#\n\n除了这些，还有一些其它的“微小”的特例，比如：\n\n\n默认导出的是个函数#\n\n前面说到，export default 是一个表达式，那么如果这个表达式是一个函数呢？\n\n\n\n\n\n可以发现，这个值居然会发生变化。这说明默认导出的如果是一个函数，导出的时候就变成了一个引用而不是值。这跟之前的说明又发生了些出入。\n\n这是因为，如果导出的是函数表达式的值的话，在导出的时候无法确定这个值是什么，所以只能特殊处理一下导出一个引用。\n\n\n\n不得不说，JavaScript 真是一门神奇的语言。\n\n\n模块循环依赖#\n\n最后，再说一下最开始提到的循环依赖的问题。在讲循环依赖之前，简单复习一下变量提升。\n\n通过 function 直接定义，或者 var 定义的变量，都会被提升到当前作用域的顶部。\n\n\n\nlet/const/class 定义的变量，不会被提升，所以在使用之前必须先定义。\n\n\n\n回到模块循环依赖的问题，假设有两个模块，moduleA 和 moduleB，它们互相依赖。\n\n\n\n这样是没有问题的，因为变量提升的原因，moduleA 中的 foo 函数在 moduleB 中是可以使用的。\n\n但是如果不满足变量提升的条件，模块就会报错。\n\n\n\n这样就会报错，在引用另一个文件的时候，因为不满足变量提升的条件，引用了未初始化的变量而报错。\n\n\n参考内容#\n\n * Understanding the Difference between export default and export with Named\n   Exports in JavaScript | by Hesh Ramsis ( Hesham El Masry 77 ) | Medium\n * export default thing is different to export { thing as default } -\n   JakeArchibald.com","routePath":"/2023/12/28/understanding-the-difference-between-export-default-and-export-with-named-exports-in-javascript/","lang":"","toc":[{"text":"导出的是引用，不是值","id":"导出的是引用不是值","depth":2,"charIndex":187},{"text":"默认导出是不同的","id":"默认导出是不同的","depth":2,"charIndex":368},{"text":"其它的说明","id":"其它的说明","depth":2,"charIndex":664},{"text":"默认导出的是个函数","id":"默认导出的是个函数","depth":3,"charIndex":698},{"text":"模块循环依赖","id":"模块循环依赖","depth":3,"charIndex":914},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1240}],"domain":"","frontmatter":{"layout":"post","title":"模块中默认导出和命名导出的区别","date":"2023-12-28T12:00:00.000Z","categories":["果然还是前端"],"tags":["javascript","es6","module","export","default"]},"version":""},{"id":13,"title":"在Node中使用dotenv加载环境变量","content":"#\n\n一份代码往往需要部署到不同环境中（开发环境、预览环境、正式环境），它们的一些地方有细微差别。通过环境变量可以定义不同环境使用的值， 比如开发环境的接口地址是\nhttp://localhost:8080，而正式环境的接口地址是 https://api.example.com。\n\n在 bundle 构建的时候，可以通过 webpack 的 DefinePlugin 来定义环境变量，这样在代码中就可以通过 process.env\n来访问这些环境变量了。 将不同的 webpack 配置使用 webpack-merge 进行合并，由此达到多环境配置的目的。\n\n但是最好的方法还是建议使用dotenv加载，这里参考 vite 的方式， 根据环境变量加载不同的 dotenv 。 以下对该段代码进行了简化：\n\nhttps://gist.github.com/sumy7/2a1175947d831a4eee9e8cfb2df51686\n\n将方法返回的值传给 webpack 的 DefinePlugin 即可。注意不能直接导出 process.env 到客户端，其中可能包含敏感信息。","routePath":"/2023/12/01/ci-in-node-to-load-dotenv/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"在Node中使用dotenv加载环境变量","date":"2023-12-01T22:00:00.000Z","categories":["果然还是前端"],"tags":["node","dotenv","webpack","rspack"]},"version":""},{"id":14,"title":"鸿蒙应用前端开发导读","content":"#\n\n> 鸿蒙作为一个新兴的操作系统，也在发展其独特的生态。本文将从前端开发的角度，介绍鸿蒙应用的开发流程。\n\n\n鸿蒙与 OpenHarmony#\n\n 1. 鸿蒙操作系统 是华为研发的智能终端操作系统。\n 2. 华为已把该智能终端操作系统的基础能力全部捐献给开放原子开源基金会，由开放原子开源基金会整合其他参与者的贡献， 形成 OpenHarmony\n    开源项目，最新的版本为 OpenHarmony 3.0。\n 3. HarmonyOS 是华为基于开源项目 OpenHarmony 开发的商用版本。\n\n\n鸿蒙应用开发导读#\n\n随着系统的演进发展，HarmonyOS先后提供了两种应用模型：\n\n * FA（Feature Ability）模型：HarmonyOS早期版本开始支持的模型，已经不再主推。\n * Stage模型：HarmonyOS 3.1 Developer Preview版本开始新增的模型，是目前主推且会长期演进的模型。\n   在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/application-\nmodel-description-0000001493584092-V3\n\n\nUI开发#\n\n方舟开发框架（简称ArkUI）为HarmonyOS应用的UI开发提供了完整的基础设施，包括简洁的UI语法、\n丰富的UI功能（组件、布局、动画以及交互事件），以及实时界面预览工具等，可以支持开发者进行可视化界面开发。\n\n针对不同的应用场景及技术背景，方舟开发框架提供了两种开发范式，分别是基于ArkTS的声明式开发范式（简称“声明式开发范式”）\n和兼容JS的类Web开发范式（简称“类Web开发范式”）。\n\n * 声明式开发范式：采用基于TypeScript声明式UI语法扩展而来的ArkTS语言，从组件、动画和状态管理三个维度提供UI绘制能力。\n * 类Web开发范式：采用经典的HTML、CSS、JavaScript三段式开发方式，即使用HML标签文件搭建布局、使用CSS文件描述样式、使用JavaScr\n   ipt文件处理逻辑。该范式更符合于Web前端开发者的使用习惯，便于快速将已有的Web应用改造成方舟开发框架应用。\n\n\n\n应用模型          页面形态       支持的UI开发范式\nStage模型（推荐）   应用或服务的页面   声明式开发范式（推荐）\n              卡片         声明式开发范式（推荐类Web开发范式\nFA模型          应用或服务的页面   声明式开发范式类Web开发范式\n              卡片         类Web开发范式\n\n基于ArkTs声明式开发范式#\n\n基于ArkTS的声明式开发范式的方舟开发框架是一套开发极简、高性能、支持跨设备的UI开发框架，提供了构建HarmonyOS应用UI所必需的能力，主要包括：Ark\nTS、布局、组件、页面路由和组件导航、图形、动画、交互事件。\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-ui-dev\nelopment-overview-0000001438467628-V3\n\n\n\n直接上例子\n\n\n\n基于JS的类Web开发范式#\n\n兼容JS的类Web开发范式的方舟开发框架，采用经典的HML、CSS、JavaScript三段式开发方式。使用HML标签文件进行布局搭建，使用CSS文件进行样式描\n述， 使用JavaScript文件进行逻辑处理。UI组件与数据之间通过单向数据绑定的方式建立关联，当数据发生变化时，UI界面自动触发更新。此种开发方式，\n更接近Web前端开发者的使用习惯，快速将已有的Web应用改造成方舟开发框架应用。主要适用于界面较为简单的中小型应用开发。\n\nhttps://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/ui-js-overvi\new-0000001428061548-V3\n\n\n\n\n\n\n\n\n\n\n与服务能力交互#\n\n组件与自定义组件#\n\n在ArkUI中，UI显示的内容均为组件，由框架直接提供的称为系统组件，由开发者定义的称为自定义组件。可以通过将UI和部分业务逻辑封装成自定义组件。\n\n * 自定义组件通过 @Component 进行装饰，是基本的UI单元。\n * 由一个或多个自定义组件可以组成页面，通过 @Entry 装饰，可以调用页面的声明周期。\n\n\n\n调用基础服务#\n\n操作系统提供了许多基础服务，如通知、媒体、电话、网络等。导入模块后，就可以调用模块提供的能力。\n\n\n\n\n鸿蒙开发：前端开发者的机遇与挑战#\n\n\n基于JS的类Web开发范式更适合前端工作者#\n\n从开发体验和语法来看，基于JS的类Web开发范式类似于Vue的写法。通用的MVVM框架思想，类小程序的架构，都大大降低了上手成本。\n\n基于JS的类Web开发范式，也为前端页面的多端适配提供了一个很好的切入点。小程序多端适配框架 Taro 从 v3.5 版本开始已经可以转换成鸿蒙 APP。\n\nhttps://docs.taro.zone/docs/harmony\n\n\nArkTS鸿蒙开发的大趋势#\n\n从最新的鸿蒙系统开始，官方在大力推荐Stage应用模型和ArkTs语言开发。\n\nArkTS是在TypeScript基础上，扩展了声明式UI、状态管理和并发任务的能力。\n\n前端开发者在迁移到ArkTS上存在先天的优势：\n\n 1. TypeScript基础：ArkTS基于TypeScript，如果前端工作者已经熟悉TypeScript，那么他们将会更容易理解和使用ArkTS。\n 2. 状态管理：ArkTS内置了状态管理的功能，与Vue的属性管理非常相似，类比其思想会更容易上手ArkTS的状态管理。\n 3. 声明式UI：ArkTS使用声明式UI，最接近的莫过于Jetpack Compose。官方提供了很好的文档和示例，帮助前端开发者快速上手。\n 4. 并发任务：ArkTS支持并发任务，这对于处理异步操作和并发问题非常有帮助。ArkTS已经支持前端工作者非常熟悉的Promise或async/await。\n    但是它也提供了高级的线程模型，这部分需要进一步熟悉。","routePath":"/2023/11/22/guide-to-harmony-apps-for-feer/","lang":"","toc":[{"text":"鸿蒙与 OpenHarmony","id":"鸿蒙与-openharmony","depth":2,"charIndex":56},{"text":"鸿蒙应用开发导读","id":"鸿蒙应用开发导读","depth":2,"charIndex":255},{"text":"UI开发","id":"ui开发","depth":3,"charIndex":623},{"text":"基于ArkTs声明式开发范式","id":"基于arkts声明式开发范式","depth":4,"charIndex":1239},{"text":"基于JS的类Web开发范式","id":"基于js的类web开发范式","depth":4,"charIndex":1500},{"text":"与服务能力交互","id":"与服务能力交互","depth":3,"charIndex":1850},{"text":"组件与自定义组件","id":"组件与自定义组件","depth":4,"charIndex":1860},{"text":"调用基础服务","id":"调用基础服务","depth":4,"charIndex":2033},{"text":"鸿蒙开发：前端开发者的机遇与挑战","id":"鸿蒙开发前端开发者的机遇与挑战","depth":2,"charIndex":2094},{"text":"基于JS的类Web开发范式更适合前端工作者","id":"基于js的类web开发范式更适合前端工作者","depth":3,"charIndex":2114},{"text":"ArkTS鸿蒙开发的大趋势","id":"arkts鸿蒙开发的大趋势","depth":3,"charIndex":2322}],"domain":"","frontmatter":{"layout":"post","title":"鸿蒙应用前端开发导读","date":"2023-11-22T17:50:00.000Z","categories":["前端"],"tags":["鸿蒙","harmonyos","artts"]},"version":""},{"id":15,"title":"博客引擎迁移到 rspress","content":"#\n\n博客引擎经历了多次变迁，从最初的jekyll到hexo。本来这次想折腾一下hugo的，但是中间出来个rspress，\n考虑到目前前端技术比较火热的rust语言，因此决定迁移到rspress。\n\n\n使用rspress搭建博客工程#\n\n由于之前的博客引擎基于hexo，因此需要创建一个新的rspress工程，然后将之前的博客文章迁移到新的工程里。\n\n\n\n初始化完成后可以在 package.json 看到三个命令。\n\n\n\n\n迁移博客文章#\n\nrspress基于约定式路由，自动扫描 docs 目录下的md/mdx文件。\n\n这样不满足我的要求：\n\n 1. 文章路径都是固定的格式 /YYYY/MM/DD/title，因为不确定外网是否有收录我文章的地方（应该很少），我就不想改变这个路径结构\n 2. 之前的博客有一百多篇文章，按照上面格式修改创建目录修改比较繁琐。\n\n于是一直在思考如何解决这个问题，最后发现rspress可以编写插件，于是就写了一个插件来解决这个问题。\n\n插件代码就在这个博客仓库里，可以看一下源码。\n\n大概流程是：\n\n 1. 遍历 source/_posts 目录下的md文件，解析出文章的元数据\n 2. 省事的调用 hexo 的工具库，解析文章名称中的日期和标题信息\n 3. 通过插件的 addPages 周期方法，将文章路由按照格式添加到路由表中\n\n由此就解决了文章路径的问题。\n\n\n改造博客主题#\n\nrepress 有个默认主题 theme-default，感觉还是挺符合我的胃口的。我也没过多的修改里面的内容和样式。\n\n但是相对于hexo的主题，这个默认主题的功能模块还是比较少的。比如hexo的主题有评论模块，这个默认主题就没有。\n\n后面会单独写一篇文章，记录下如何给rspress添加一些博客模块。\n\n\n使用 Github Actions 自动部署#\n\n之前在hexo是在本地调用 deploy 命令，进行部署。这次顺便将部署操作迁移到了 github actions上面。\n\n这是我写的一个部署脚本，可以参考一下。\n\n\n\n\n总结#\n\nrspress是一个很不错的博客引擎，基于rust语言，性能和安全性都很好。而且还支持插件，可以自定义一些功能。\n\n由于rspress刚起步，可以折腾的内容还是蛮多的，目前对该引擎比较满意。\n\n\n参考内容#\n\n * rspress官网","routePath":"/2023/11/19/new-blog-with-rspress/","lang":"","toc":[{"text":"使用rspress搭建博客工程","id":"使用rspress搭建博客工程","depth":2,"charIndex":100},{"text":"迁移博客文章","id":"迁移博客文章","depth":2,"charIndex":212},{"text":"改造博客主题","id":"改造博客主题","depth":2,"charIndex":603},{"text":"使用 Github Actions 自动部署","id":"使用-github-actions-自动部署","depth":2,"charIndex":767},{"text":"总结","id":"总结","depth":2,"charIndex":878},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":981}],"domain":"","frontmatter":{"layout":"post","title":"博客引擎迁移到 rspress","date":"2023-11-19T17:55:00.000Z","tags":["rspress","blog"],"categories":["网站"]},"version":""},{"id":16,"title":"使用 Cloudflare 加速 Github Pages","content":"#\n\n之前很早注册过一个域名，一直闲置。后来看到 cloudflare 的免费域名托管服务，就用来做了邮箱。\n\n尝到甜头后，就把博客的域名也迁移到 cloudflare 上面去。\n\n\n将域名解析到 Cloudflare#\n\n首先在 cloudflare 上添加站点。这里使用的博客的域名 sumygg.com。\n\n\n\n选择一个免费套餐，由于已经设定好了域名，这里没有截图。\n\n选择好套餐后，cloudflare 会给出 nameserver 的地址，需要在域名注册商那里修改 nameserver。\n\n我的域名在 namesilo 上注册的，在 namesilo 的控制台里修改 nameserver。\n\n\n\n修改好 nameserver 后，cloudflare 会自动检测域名是否已经解析到 cloudflare，这个过程可能需要十几分钟。\n\n\n配置 DNS#\n\n在 cloudflare 的 DNS 配置页面，添加 A 记录 和 AAAA 记录，将域名解析到 Github Pages 的 IP 地址。\n\n这里直接查看我填写好的配置。或者参考 Github Pages 的官方文档。\n\n\n\n别忘了还需要在仓库中添加 CNAME 文件，内容为域名。由于是迁移到 cloudflare，之前都已经做过了。\n\n\n配置 HTTPS#\n\ncloudflare 提供了免费的 HTTPS 证书，可以直接开启。\n\n\n\n这里选择灵活、完全、完全（严格）都是可以的。\n\nWARNING\n\n需要注意的是，如果选择灵活，那么 cloudflare 和 Github Pages 之间的通信是 HTTP，而 cloudflare 和用户之间的通信是\nHTTPS。\n\n如果你在 Github Pages 中开启了强制 HTTPS，就会出现无限重定向的问题。\n\n\n配置 Configuration Rules#\n\n因为使用了 灵活 的 HTTPS 方式，通过 规则 来强制使用 HTTPS。\n\n\n\n其实与以上选择 完全 的效果是一样的。这样的目的，以后也在该域名代理其它网站，则以 HTTPS 方式回源只针对当前域名有效。\n\n\n效果#\n\n到此配置完成了，在 cloudflare 的 概述 面板上，可以查看域名的访问情况，感觉还是挺不错的。\n\n","routePath":"/2023/11/13/use-cloudflare-speed-up-github-pages/","lang":"","toc":[{"text":"将域名解析到 Cloudflare","id":"将域名解析到-cloudflare","depth":2,"charIndex":91},{"text":"配置 DNS","id":"配置-dns","depth":2,"charIndex":374},{"text":"配置 HTTPS","id":"配置-https","depth":2,"charIndex":555},{"text":"配置 Configuration Rules","id":"配置-configuration-rules","depth":2,"charIndex":770},{"text":"效果","id":"效果","depth":2,"charIndex":902}],"domain":"","frontmatter":{"layout":"post","title":"使用 Cloudflare 加速 Github Pages","date":"2023-11-13T17:43:44.000Z","categories":["Github Pages"],"tags":["Github Pages","Cloudflare"]},"version":""},{"id":17,"title":"小米2023年度编程挑战赛分享","content":"#\n\n> 小米编程大赛是每年1024的固定活动，依托于力扣的周赛和双周赛，进行内部排名。\n> \n> 今年跟去年相比，因档期限制只有一场周赛可以参加。第二是存在些许冷门，这也是编程比赛的一个看点。 本次将题目、解题思路和一些感悟分享给大家。\n\n\n题目#\n\n\n2908. 元素和最小的山形三元组 I#\n\n给你一个下标从 0 开始的整数数组 nums 。\n\n如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：\n\n * i < j < k\n * nums[i] < nums[j] 且 nums[k] < nums[j]\n\n请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。\n\n示例 1：\n\n> 输入： nums = [8,6,1,5,3]\n> \n> 输出： 9\n> \n> 解释： 三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为：\n> \n>  * 2 < 3 < 4\n>  * nums[2] < nums[3] 且 nums[4] < nums[3]\n> \n> 这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。\n\n示例 2：\n\n> 输入： nums = [5,4,8,7,10,2]\n> \n> 输出： 13\n> \n> 解释： 三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为：\n> \n>  * 1 < 3 < 5\n>  * nums[1] < nums[3] 且 nums[5] < nums[3]\n> \n> 这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。\n\n示例 3：\n\n> 输入： nums = [6,5,4,3,4,5]\n> \n> 输出： -1\n> \n> 解释： 可以证明 nums 中不存在山形三元组。\n\n提示：\n\n * 3 <= nums.length <= 50\n * 1 <= nums[i] <= 50\n\n思考#\n\n签到题\n\n数据范围不大三重循环才 50^3 ，直接开搞判断满足条件的更新 ans\n\n比赛代码#\n\n\n\n\n2909. 元素和最小的山形三元组 II#\n\n给你一个下标从 0 开始的整数数组 nums 。\n\n如果下标三元组 (i, j, k) 满足下述全部条件，则认为它是一个 山形三元组 ：\n\n * i < j < k\n * nums[i] < nums[j] 且 nums[k] < nums[j]\n\n请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。如果不存在满足条件的三元组，返回 -1 。\n\n示例 1：\n\n> 输入： nums = [8,6,1,5,3]\n> \n> 输出： 9\n> \n> 解释： 三元组 (2, 3, 4) 是一个元素和等于 9 的山形三元组，因为：\n> \n>  * 2 < 3 < 4\n>  * nums[2] < nums[3] 且 nums[4] < nums[3]\n> \n> 这个三元组的元素和等于 nums[2] + nums[3] + nums[4] = 9 。可以证明不存在元素和小于 9 的山形三元组。\n\n示例 2：\n\n> 输入： nums = [5,4,8,7,10,2]\n> \n> 输出： 13\n> \n> 解释： 三元组 (1, 3, 5) 是一个元素和等于 13 的山形三元组，因为：\n> \n>  * 1 < 3 < 5\n>  * nums[1] < nums[3] 且 nums[5] < nums[3]\n> \n> 这个三元组的元素和等于 nums[1] + nums[3] + nums[5] = 13 。可以证明不存在元素和小于 13 的山形三元组。\n\n示例 3：\n\n> 输入： nums = [6,5,4,3,4,5]\n> \n> 输出： -1\n> \n> 解释： 可以证明 nums 中不存在山形三元组。\n\n提示：\n\n * 3 <= nums.length <= 10^5\n * 1 <= nums[i] <= 10^8\n\n思考#\n\n上一题的数据量加强版，三重循环 (10^5)^3 > 10^7，考虑用其他方法\n\n题目要求找最小的，那么可以贪心找满足条件三个数最小的（同时找三个数不太好找）\n\n再退一步。对于某个数 nums[i]，先预处理找左边最小的数与当前的和 leftToRightSum[i]，再找右边最小的数与当前数的和\nrightToLeftSum[i]， 最后遍历一遍计算 leftToRightSum[i] + rightToLeftSum[i] - nums[i]\n更新ans\n\n（写的不是很优雅，相同代码直接拷贝了两遍，这样容易出错。而且其实预处理里也不用计算当前数字的）\n\n写完之后把代码提交回第一题验证了一下\n\n比赛代码#\n\n\n\n\n2910. 合法分组的最少组数#\n\n给你一个长度为 n 下标从 0 开始的整数数组 nums 。\n\n我们想将下标进行分组，使得 [0, n - 1] 内所有下标 i 都 恰好 被分到其中一组。\n\n如果以下条件成立，我们说这个分组方案是合法的：\n\n * 对于每个组 g ，同一组内所有下标在 nums 中对应的数值都相等。\n * 对于任意两个组 g(1) 和 g(2) ，两个组中 下标数量 的 差值不超过 1 。\n\n请你返回一个整数，表示得到一个合法分组方案的 最少 组数。\n\n示例 1：\n\n> 输入： nums = [3,2,3,2,3]\n> \n> 输出： 2\n> \n> 解释： 一个得到 2 个分组的方案如下，中括号内的数字都是下标：\n> \n> 组 1 -> [0,2,4]\n> \n> 组 2 -> [1,3]\n> \n> 所有下标都只属于一个组。\n> \n> 组 1 中，nums[0] == nums[2] == nums[4] ，所有下标对应的数值都相等。\n> \n> 组 2 中，nums[1] == nums[3] ，所有下标对应的数值都相等。\n> \n> 组 1 中下标数目为 3 ，组 2 中下标数目为 2 。\n> \n> 两者之差不超过 1 。\n> \n> 无法得到一个小于 2 组的答案，因为如果只有 1 组，组内所有下标对应的数值都要相等。\n> \n> 所以答案为 2 。\n\n示例 2：\n\n> 输入： nums = [10,10,10,3,1,1]\n> \n> 输出： 4\n> \n> 解释： 一个得到 2 个分组的方案如下，中括号内的数字都是下标：\n> \n> 组 1 -> [0]\n> \n> 组 2 -> [1,2]\n> \n> 组 3 -> [3]\n> \n> 组 4 -> [4,5]\n> \n> 分组方案满足题目要求的两个条件。\n> \n> 无法得到一个小于 4 组的答案。\n> \n> 所以答案为 4 。\n\n提示：\n\n * 1 <= nums.length <= 10^5\n * 1 <= nums[i] <= 10^9\n\n思考#\n\n先统计每个数字出现次数，然后数字就可以扔掉了，后面只跟次数有关系。\n\n（看数据量，又是最值问题，计划写成二分，二分枚举每组的数量）\n\n先写 check 函数。数量差1，(s-1, s) 还有 (s, s+1) 都满足条件，但是如何混合判断，会出现 (s-1, s+1) 这种不满足条件的情况。\n所以，为了方便进行处理，这里限制每组数量为 s 或 s+1 ，在这种情况下能分成多少组。如果不能分出来，就返回 -1。\n\n分法：先将每组数量定为 s+1，分完之后最后一组会出现一个余数（不为0的时候），然后从每组拿一个出来分给最后一组，看能否将最后一组补齐到 s。\n\n\n\n（写完check发现，貌似无法二分，因为结果不一定连续）\n\n本着不浪费代码的原则，改为了暴力枚举，将分组从次数最多倒序枚举到1个，然后就AC了。。。\n\n（这个题目在处理分组上浪费了好多时间，过了之后没再思考赶紧继续看第四题。。。）\n\n（后来稍微思考了一下数据量，枚举量与两个因素有关，数字出现最多的次数 numMaxCnt 和 去重后数字的个数 distinctCnt。distinctCnt\n越多， 那么 numMaxCnt 就越少，这两个基本上是互斥的关系）\n\n比赛代码#\n\n\n\n\n2911. 得到 K 个半回文串的最少修改次数#\n\n给你一个字符串 s 和一个整数 k ，请你将 s 分成 k 个 子字符串 ，使得每个 子字符串 变成 半回文串 需要修改的字符数目最少。\n\n请你返回一个整数，表示需要修改的 最少 字符数目。\n\n注意：\n\n * 如果一个字符串从左往右和从右往左读是一样的，那么它是一个 回文串 。\n * 如果长度为 len 的字符串存在一个满足 1 <= d < len 的正整数 d ，len % d == 0 成立且所有对 d\n   做除法余数相同的下标对应的字符连起来得到的字符串都是 回文串 ，那么我们说这个字符串是 半回文串 。比方说 \"aa\" ，\"aba\" ，\"adbgad\" 和\n   \"abab\" 都是 半回文串 ，而 \"a\" ，\"ab\" 和 \"abca\" 不是。\n * 子字符串 指的是一个字符串中一段连续的字符序列。\n\n示例 1：\n\n> 输入： s = \"abcac\", k = 2\n> \n> 输出： 1\n> \n> 解释： 我们可以将 s 分成子字符串 \"ab\" 和 \"cac\" 。子字符串 \"cac\" 已经是半回文串。如果我们将 \"ab\" 变成 \"aa\"\n> ，它也会变成一个 d = 1 的半回文串。\n> \n> 该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 1 。\n\n示例 2:\n\n> 输入： s = \"abcdef\", k = 2\n> \n> 输出： 2\n> \n> 解释： 我们可以将 s 分成子字符串 \"abc\" 和 \"def\" 。子字符串 \"abc\" 和 \"def\" 都需要修改一个字符得到半回文串，所以我们总共需要\n> 2 次字符修改使所有子字符串变成半回文串。\n> \n> 该方案是将 s 分成 2 个子字符串的前提下，得到 2 个半回文子字符串需要的最少修改次数。所以答案为 2 。\n\n示例 3：\n\n> 输入： s = \"aabbaa\", k = 3\n> \n> 输出： 0\n> \n> 解释： 我们可以将 s 分成子字符串 \"aa\" ，\"bb\" 和 \"aa\" 。\n> \n> 字符串 \"aa\" 和 \"bb\" 都已经是半回文串了。所以答案为 0 。\n\n提示：\n\n * 2 <= s.length <= 200\n * 1 <= k <= s.length / 2\n * s 只包含小写英文字母。\n\n思考#\n\n之前碰到过一个类似的题目《得到K个回文串的最小修改次数》，先套用那题的转移方程\n\ndp[i][j]表示前i个字符，分隔成j个字符串，得到(半)回文的最小修改次数\n\n转移方程 dp[i][j] = Math.min(dp[k][j-1] + getCost(k, i - 1))\n\ngetCost(l, r)是把字符串 [l, r] 变成(半)回文串的修改次数\n\n然后就是处理这个看着很啰嗦，其实也要读好久的半回文串的定义\n\n以 adbgad 为例，len=6，因子d有 1,2,3,6 四个，首先排除自身 6，只剩下 1,2,3\n\nd=1 分成 adbgad\n\nd=2 分成 adbgad -> aba dgd\n\nd=3 分成 adbgad -> ag da bd\n\n可以发现在 d=2 时，分隔出来的 d 个字符串都是回文字符串，所以 adbgad 是一个半回文字符串\n\n搞懂了半回文字符串的定义，按照题目描述计算最小花费\n\ngetCostPart 用于计算在 d=step 的情况下形成半回文字符串的花费。外层循环表示第 j 个字符串组，\n内部双指针计算将该组变成回文字符串所需要的花费。d 的花费就是所有字符串组的花费之和\n\ngetCost 枚举 len 的因子，交给 getCostPart 计算花费，最后统计一个最小的花费\n\n（全部搞完就剩最后 6 分钟了，赶紧提交了一下，发现 WA 了）\n\n（很紧张的检查代码，发现 getCostPart 的 right 初始值设置的不对，修改后赶在最后一分钟提交成功😭）\n\n（下次可以让 力扣 官方出个实时大屏，让场外同学感受一下这种紧张的气氛）\n\n\n\n比赛代码#\n\n\n\n\n刷题经验#\n\n接下来我就简单说一下个人在 LeetCode 上的一些感想。\n\n\nWhy Kotlin#\n\n大家可能看到我的语言常年使用的是 Kotlin。最初接触到这门语言还是在 Jetbrains 北京站大会上，之前也是被 Java 模板代码苦恼的一员。\n\n当时布道师的一句话：我们提供了 Convert Java to Kotlin 的功能，为什么没有提供 Kotlin to Java 呢？因为你只要用过\nKotlin 就不想换回去了。\n\n\n\n在我使用下来，Kotlin 相比 Java 在刷题上的优势：\n\n 1. 函数可以定义在方法内部，这样一个函数就能把题目需要的所有逻辑包含进来。\n\n\n\n 2. 提供了不少的工具方法，简化代码。举几个🌰\n\n\n\n每门语言都有自己独特的魅力，不管你刷题的目的是什么，首先要做的是找到一门适合自己的语言。\n\n\n找到适合的刷题节奏#\n\n想要提升，疯狂嗑 hard，结果物极必反。\n\n想要成就感，刷 easy 固然很爽（我有的时候一天能刷10道easy），但是对提升不大。\n\n如何在这两者之间找到平衡，我给自己的定位是“刷题混子”。。。\n\n每天上午开工前拿出 30 分钟，完成日常的每日两题（美服一题，国服一题）。碰到搞不定的就留到晚上来解决。有时候晚上比较忙，就加 TODO && CV大法。\n\n竞赛有奖品就参加（所以才是混子），没有奖品就无视了。。。这里不得不提两位常年打星的大佬，真的每场周赛都参加。\n\n所以找到自己的刷题节奏，保持成就感，不要有太大压力。这是一个长期提升的过程，不要一开始就把精力全用光。\n\n\n数据范围也会提供重要信息#\n\n读完题目之后，一定记得看一眼数据范围。一些题目算法上比较麻烦，但是因为数据范围较小，可以用暴力搜索低分飘过。\n\n不同的数据范围处理起来也不一样，而且数据范围会提示一些算法方向。\n\n * 基本时限内的复杂度在 10^6 ~ 10^7\n * 10^5 需要考虑 O(nlogn) 以内的算法，比如 二分、各种优先队列、剪枝 等\n * 10^3 以内O(n^2) 就可以随便做了（大概）\n * 10^2 以内深搜暴力\n\n因此读完题目之后，一定记得看一眼数据范围。\n\n\n夯实基础，才能不惧怕 hard#\n\n可以打开题目列表看一下前三行的tag，是否都有了解。这个可以说是力扣的重点考试范围了。\n\n\n\n有的人一看到 hard 下意识就想 CV 了。但是 hard 其实也有可以攻破的点。\n\n\n\nhard 使用的知识点都有对应的 medium 题目，在碰到 hard 的时候不妨尝试一下，了解自己欠缺的知识点。对症学习。缺啥补啥。\n\n\n刷题价值#\n\n要说刷 LeetCode 是否有价值，答案是肯定的。我认为有以下几点：\n\n\n提升编码熟练度#\n\n通过不断的刷题，可以让你更熟练地使用编程语言，提高编码效率。你会更熟悉语法，更了解如何有效地使用数据结构和算法， 以及如何编写出更优雅、更高效的代码。\n\n\n了解语言特性#\n\n算法是所有语言共通的，但是每种编程语言都有其独特的特性和优势。说到 Python 就很容易想起它的大数处理、内置缓存， 说到 Java\n就有很多数据结构可供选择，说到 JavaScript 好像没啥可以说的。。。\n\n通过刷题， 你就能更好的更深入的了解这些语言特性。当你熟练掌握这些特性之后，不仅可以使你更好的了解这门语言，\n也能简化代码提高刷题效率。这是一个相互的，不断改进的过程。\n\n\n强化算法思维#\n\n碰到一个问题如何进行拆解，如何对代码结构进行规划使其能够满足易扩展的要求。通过刷题可以不断强化这部分能力，例如如何解决深搜广搜的问题等。\n\n将你学到的各种算法和数据结构，应用到实际问题中，这不仅可以提高解决问题的能力，更能助力你理解和设计复杂的系统。\n\n\n增强抗压能力#\n\n不知道大家都有没有碰到过，线上出了一个问题，然后一群人在盯着你解决。\n\n\n\n这种情况下，如何顶住鸭梨完成代码修复、发版、上线的任务。\n\n力扣的竞赛都有时间限制，就需要在有限的时间内完成问题理解、算法设计、代码编写。然后提交！！！如果WA了，还需要在时限内调试代码，找到问题所在。\n\n多参加竞赛，在编码时保持冷静和坚持，对于个人成长和职业发展都会有帮助。\n\n\n总结#\n\n 1. 感谢【xxxxxxxxxxxx】和各位大佬给予的这次机会\n 2. 这次比赛成绩有一定的运气成分\n 3. 刷题是个持之以恒的过程，只要坚持下去就一定能有收获","routePath":"/2023/10/31/solutions-to-xiaomi-programming-competition-2023/","lang":"","toc":[{"text":"题目","id":"题目","depth":2,"charIndex":121},{"text":"2908. 元素和最小的山形三元组 I","id":"2908-元素和最小的山形三元组-i","depth":3,"charIndex":127},{"text":"思考","id":"思考","depth":4,"charIndex":916},{"text":"比赛代码","id":"比赛代码","depth":4,"charIndex":963},{"text":"2909. 元素和最小的山形三元组 II","id":"2909-元素和最小的山形三元组-ii","depth":3,"charIndex":973},{"text":"思考","id":"思考-1","depth":4,"charIndex":1767},{"text":"比赛代码","id":"比赛代码-1","depth":4,"charIndex":2074},{"text":"2910. 合法分组的最少组数","id":"2910-合法分组的最少组数","depth":3,"charIndex":2084},{"text":"思考","id":"思考-2","depth":4,"charIndex":2949},{"text":"比赛代码","id":"比赛代码-2","depth":4,"charIndex":3470},{"text":"2911. 得到 K 个半回文串的最少修改次数","id":"2911-得到-k-个半回文串的最少修改次数","depth":3,"charIndex":3480},{"text":"思考","id":"思考-3","depth":4,"charIndex":4487},{"text":"比赛代码","id":"比赛代码-3","depth":4,"charIndex":5195},{"text":"刷题经验","id":"刷题经验","depth":2,"charIndex":5205},{"text":"Why Kotlin","id":"why-kotlin","depth":3,"charIndex":5245},{"text":"找到适合的刷题节奏","id":"找到适合的刷题节奏","depth":3,"charIndex":5581},{"text":"数据范围也会提供重要信息","id":"数据范围也会提供重要信息","depth":3,"charIndex":5883},{"text":"夯实基础，才能不惧怕 hard","id":"夯实基础才能不惧怕-hard","depth":3,"charIndex":6129},{"text":"刷题价值","id":"刷题价值","depth":2,"charIndex":6310},{"text":"提升编码熟练度","id":"提升编码熟练度","depth":3,"charIndex":6355},{"text":"了解语言特性","id":"了解语言特性","depth":3,"charIndex":6443},{"text":"强化算法思维","id":"强化算法思维","depth":3,"charIndex":6647},{"text":"增强抗压能力","id":"增强抗压能力","depth":3,"charIndex":6784},{"text":"总结","id":"总结","depth":2,"charIndex":6972}],"domain":"","frontmatter":{"layout":"post","title":"小米2023年度编程挑战赛分享","date":"2023-10-31T10:13:00.000Z","categories":["读书笔记"],"tags":["LeetCode","Kotlin","Xiaomi","event"]},"version":""},{"id":18,"title":"鲁班平台Monorepo+rspack构建优化实践","content":"#\n\n鲁班平台是我们内部的一个低代码搭建平台，承载着移动端、大屏端和RN的活动搭建。\n\n鲁班平台采用了一个仓库管理代码，整个代码仓库结构如下：\n\n\n\n随着业务发展，一些问题也随之显现出来：\n\n 1. 目录结构混乱，模块之间相互引用\n 2. 整个client由同一个 package.json 管理，依赖冗余\n 3. 构建时间长，在流水线上平均一次需要 8 min\n\n项目基于 webpack4 进行构建，之前我们一直在寻找好的解决方案。首先 Monorepo 已经是一个成熟的理念， 也曾尝试迁移到\nMonorepo。但是从最终收益来看只是改变了项目结构，构建成本未发生实质的变化。 而 Rspack 的出现，才使得这个方案变得更有价值。\n\n\n什么是Monorepo？#\n\n一个产品会有多个项目，每个项目之间会存在版本同步的问题，如何在其中一个项目发布上线后，保证每个项目版本升级后的版本同步问题， 提出的解决方案就是\nmonorepo 策略。\n\nmonorepo 是一种将多个项目代码存储在一个仓库里的软件开发策略（mono 意为单一，repo 意为 仓库）。 与之相对的是另一种流行的代码管理方式\nMultiRepo，即每个项目对应一个单独的仓库来分散管理。\n\n\n\n\nRspack#\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性， 可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。 经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\n\n\n\n项目结构优化#\n\n之前的代码采用目录的方式进行隔离存放——client 和 server，而 client 的 src 又存放了三个关键模块——cms、activity 和\ntvActivity。 于是整个项目结构拆分的方向就确定了。\n\n\n\n整体看来整理前后的目录结构是一一对应的，apps 作为入口，packages 作为项目内部依赖。\n\n当然这个目录也不是一开始就是确定这样拆分的，apps 的入口确定好了之后，packages 根据后面 rspack 的迁移不断的补充和完成形成的。\n\n\n创建 Monorepo 工程#\n\nmonorepo 有多种驱动方式，一般需要包管理工具的 workspace 功能的支持。这里采用 turborepo + yarn workspace 的模式。\n\n自己写配置还是比较麻烦的，参考一个现有的使用\nhttps://turbo.build/repo/docs/getting-started/from-example 创建一个示例的 Monorepo 工程\n\n\n\n根据之前拆分的目录结构，创建对应的目录，并删除实例代码。\n\n\n项目内的模块依赖#\n\n要在一个模块引入其它模块，不需要将包 push 到 artifactory 上，而是在对应模块的 package.json 引入。\n\n\n\n后续在代码中，使用 luban-components/xxx/xxx 就能引用模块下的文件了。\n\n\npostcss.config.js#\n\npostcss 的配置无它，这里简单提一下。需要在所有需要处理的 css 文件的模块的根目录放置一个 postcss.config.js 文件， 否则\npostcss 不会处理这个目录下的文件。\n\n除了配置文件放置的位置之外，还需要注意版本升级后的新语法，除法需要加括号才会在预处理阶段进行计算。\n\n\n构建 docker 镜像#\n\n之前 docker 镜像里会同时存在 nginx 服务和 node 服务。本次迁移也是采用这种模式。\n\n前端页面只需要将 dist 目录下的成品转移到 nginx 服务目录下。而 node 服务就需要在容器里安装依赖并进行构建。 因此 dockerfile\n编写也需要分成两部分进行。\n\n构建前端页面#\n\n在 package.json 中添加一条命令，--filter 表示只处理对应模块。\n\n\n\n构建的时候执行该命令，通过 COPY 执行将 dist 目录下的成品复制到对应目录下\n\n\n\n构建 node 服务#\n\n在 monorepo 模式下，所有依赖都会被提取到根目录的 node_modules。而 node 执行需要依赖其中的某些包。直接拷贝 node\n服务会缺少依赖， 而全部拷贝（包含外部的 node_modules）又会引入前端的一些依赖。\n\n这个时候就需要使用 turbo 提供的一条指令了\nhttps://turbo.build/repo/docs/reference/command-line-reference/prune\n\n\n\n这条指令会将 luban-server 模块下依赖的全部文件生成到 out 目录下，我们将 out 目录拷贝到 docker 中，然后执行安装命令。\n\n\n\n\n迁移rspack#\n\n将项目目录进行分模块拆分之后，接下来将 webpack4 的配置迁移到 rspack。这里采用的是先创建一个vue2 的 rspack 空白项目，\n然后将模块代码拷入，补充缺少的依赖和配置的方式进行。下面记录一下关键步骤、遇到的问题和解决方案。\n\n\n迁移配置文件#\n\n根据报错信息，需要补充的配置内容有：\n\n 1. devServer.proxy 的本地预览服务器转发配置\n 2. builtins.define 中的变量替换\n 3. resolve.alias 的路径别名替换\n\n这里直接展示完成后的 rspack.config.js\n\n\n\n\n多环境配置文件#\n\n目前很流行一套代码多环境部署，但是 webpack 和 rspack 都没有支持。\n\n> 不过 webpack 已经计划支持了 https://github.com/webpack/webpack-cli/pull/3759 ，相信不久的将来\n> rspack 也会跟上。\n\n老项目之前的方案是根据环境变量，将不同的 webpack 配置使用 webpack-merge 进行合并，由此达到多环境配置的目的。 这里参考 vite 的模式\nhttps://cn.vitejs.dev/guide/env-and-mode.html ，根据环境变量加载不同的 dotenv 。\n\n\n\n\nwebpack 插件无法兼容 rspack#\n\n项目中的 luban-cms 模块使用了 svg-sprite-loader 来处理 svg 图标。 这个插件使用的 API 在 rspack\n中报错。由于没有找到其它代替的插件来解决 svg 图标构建的问题，这里继续使用 webpack 构建 svg 图标库， 将构建成品引入项目。\n\n这里贴一个 webpack 的配置，其它项目通过 luban-icons/dist/icons.js 的方式引用生成的 svg 图标库。\n\n\n\n\n\n\n成果#\n\n\n单模块构建#\n\n这里选择文件依赖数量最多的 luban-cms 模块，本地执行 yarn run build 执行进行构建。yarn 命令统计的耗时从 21s 提升到 5s。\n基于 Rspack 构建成品的速度提升了大概 4 倍。\n\n\n\n为此我还专门去推上吹了一波~\n\nhttps://twitter.com/sumygg/status/1719993104592425311\n\n\n\n\n流水线集成构建#\n\n将整个项目构建流迁移到新版流水线上，排除首次构建缓存的影响，已第二次构建的时间作为总体的构建时间。 计算从代码拉取到推送完 docker\n的总时间。由于阶段之间的环节是并行执行的，总时间计算的是各阶段的耗时总和， 而每个阶段取其中最长时间的环节作为该阶段的耗时。\n\n迁移前\n\n19+20+133+134+175=481s\n\n\n\n迁移后\n\n8+20+58+117=203s\n\n\n\n可以看到除了简化了 流水线 上配置的构建步骤外（6步 缩减为 3步），构建时长也从 481s 缩减到了 203s 。构建速度大概提升了 2 倍。\n\n不过构建 docker 镜像的耗时也是一个大头，还有 miflow 平台的资源调度也存在一定的耗时，后续考虑如何优化这一部分构建。\n\n\n其它 Monorepo 场景#\n\n除了鲁班项目迁移遇到的一些场景，下面再介绍几个常见的 Monorepo 的使用场景。\n\n\n前端+组件库#\n\n这可能是最初的使用方式了吧，包括一些开源的项目都是使用的这种方式。通过命令执行将构建的成品推送到 artifactory 上。\n\n当然也需要一些工具链的配置，比如自动修改版本号、自动构建、自动publish等。\n\n在我编写的midway-mi组件库中，就尝试了turbo+changeset的模式，感兴趣的可以尝试一下。\n\nhttps://turbo.build/repo/docs/handbook/publishing-packages/versioning-and-publis\nhing\n\n\n\n\n前端+node后端共享类型#\n\nNode 服务提供接口，返回给前端页面展示使用。由于都是使用的 js 语言的关系，可以共享前后端的类型。\n\n假设这个共享类型的模块叫 shared-types。\n\n前端可以在 package.json 文件里添加该依赖，然后在代码中引入对应的类型即可。打包工具会处理公共模块内的代码并引入。\n\n后端服务没有打包工具，只是根据依赖文件的路径解析文件，并加载执行。所以一个模块要给后端使用，需要实时进行构建。\n\n\n\n与以往不同的是 dev 命令添加了 --watch 参数，用于监听文件变化，并在文件修改后实时将文件构建成 cjs 格式的成品文件。\n\n\n总结#\n\n使用 Monorepo 后一方面能够很好的组织隔离各模块的依赖，另一方面也使得代码结构变得清晰。\n\n而 Rspack 对编译速度的提升非常明显。由于 Rspack 对 webpack API 兼容支持比较高，迁移 Rspack 没有遇到大的兼容性问题。\n当然一些与 Rspack 不兼容的 webpack 插件，在迁移的过程中没有将中心放在改造插件上，采用了继续使用 webpack 构建成 js\n成品再引入项目的方式来解决。 另外一些特性比如加载 dotenv 后续也期望 Rspack 能够尽快支持。\n\n再后续也会考虑将 Rspack 应用到其它业务中，例如作为 taro 或 umijs 的底层。不过 Rspack 不支持 Module Federation\n的特性的问题还是需要权衡一下的。\n\n以上只是对项目迁移的一个粗略的介绍，很多细节没有详细进行说明。如果你有好的想法或其它想详细了解的内容，欢迎与我探讨。\n\n\n参考内容#\n\n * monorepo介绍与实践🥂 - 掘金\n * rspack","routePath":"/2023/09/07/luban-platform-in-actions-monorepo-and-rspack/","lang":"","toc":[{"text":"什么是Monorepo？","id":"什么是monorepo","depth":2,"charIndex":321},{"text":"Rspack","id":"rspack","depth":2,"charIndex":535},{"text":"项目结构优化","id":"项目结构优化","depth":2,"charIndex":748},{"text":"创建 Monorepo 工程","id":"创建-monorepo-工程","depth":3,"charIndex":995},{"text":"项目内的模块依赖","id":"项目内的模块依赖","depth":3,"charIndex":1230},{"text":"postcss.config.js","id":"postcssconfigjs","depth":3,"charIndex":1360},{"text":"构建 docker 镜像","id":"构建-docker-镜像","depth":3,"charIndex":1531},{"text":"构建前端页面","id":"构建前端页面","depth":4,"charIndex":1690},{"text":"构建 node 服务","id":"构建-node-服务","depth":4,"charIndex":1791},{"text":"迁移rspack","id":"迁移rspack","depth":2,"charIndex":2101},{"text":"迁移配置文件","id":"迁移配置文件","depth":3,"charIndex":2237},{"text":"多环境配置文件","id":"多环境配置文件","depth":3,"charIndex":2385},{"text":"webpack 插件无法兼容 rspack","id":"webpack-插件无法兼容-rspack","depth":3,"charIndex":2686},{"text":"成果","id":"成果","depth":2,"charIndex":2929},{"text":"单模块构建","id":"单模块构建","depth":3,"charIndex":2935},{"text":"流水线集成构建","id":"流水线集成构建","depth":3,"charIndex":3128},{"text":"其它 Monorepo 场景","id":"其它-monorepo-场景","depth":2,"charIndex":3469},{"text":"前端+组件库","id":"前端组件库","depth":3,"charIndex":3531},{"text":"前端+node后端共享类型","id":"前端node后端共享类型","depth":3,"charIndex":3792},{"text":"总结","id":"总结","depth":2,"charIndex":4083},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":4500}],"domain":"","frontmatter":{"layout":"post","title":"鲁班平台Monorepo+rspack构建优化实践","date":"2023-09-07T11:20:00.000Z","categories":["果然还是前端"],"tags":["前端","构建","Monorepo","rspack"]},"version":""},{"id":19,"title":"CTF Mobile 基础入门","content":"#\n\n> 最近参加了公司组织的 CTF 比赛，混了一个还算不错的成绩，将当时分享的 Mobile 部分的提纲拿出来记录一下。\n\nmobile指移动端APP的相关题目。\n\n\nAndroid#\n\n\n准备的工具#\n\n * 电脑，推荐程度windows>linux>mac>mac M1\n * apk解包反编译工具\n   * bytecode-viewer https://github.com/Konloch/bytecode-viewer\n   * jd-gui https://github.com/java-decompiler/jd-gui\n * so 文件逆向\n   * IDA Pro\n   * Binary Ninja\n   * Ghidra\n   * 52pojie的网盘 https://down.52pojie.cn/Tools/Disassemblers/\n\n\n基础知识#\n\n先正向了解APK，为逆向打好基础。建议自己写一个APK，了解APK的生产过程和基本结构。\n\n * APK实际上是一个zip压缩包\n * 资源文件xml会进行编译压缩，转成二进制格式。注意关注AndroidManifest.xml文件\n * java/kt文件编译生成class，压缩生成dex格式文件\n * jni技术加载so文件，so文件是NDK编译生成的，一般用C++语言编写\n\n\n解题思路#\n\n 1. 阅读题目要求，安装APK到手机，查看APK的主要功能\n 2. 反编译APK文件，查看反编译结果。了解APK内部的调用关系。\n 3. 确定核心逻辑/核心漏洞，查找资料，构造破解方法\n 4. 破解APK，获取flag\n\n核心逻辑\n\n * dex -> java语言\n * so -> 汇编语言\n * Android漏洞\n\n\n题目讲解#\n\n根据核心逻辑选取了三个题目重点说明一下。\n\n数学家#\n\n反编译APK，确定核心逻辑在Java代码中。\n\n阅读反编译后的代码，关键在随机种子爆破\n\n查询相关资料，编写随机种子爆破的程序\n\n找到了随机种子和随机数，代入解密代码获取flag\n\n多少个MD5#\n\n反编译APK，确定核心逻辑在so文件中。\n\nIDA pro打开so文件，找到so文件对应的方法位置。\n\n按下神奇的F5进行反编译。\n\n阅读代码（合理）猜测逻辑。\n\n在线解谜md5，获取前4段，破解最后一段 拼接组成flag\n\n重定向进阶#\n\n反编译APK，确定核心逻辑需要利用Intent重定向获取apk的私有文件。 查找Intent重定向相关资料，（2021ByteCTF）\n根据资料，获取漏洞的相关知识，编写漏洞利用poc 执行poc，获取flag\n\n\nIOS#\n\n我也不会🤦🏻‍♀️（下次一定\n\n\n总结#\n\n * 工具的运用\n * 搜索引擎的大力帮助\n * 合理的猜测+运气\n\n\n未来展望（押题）#\n\n * docker android模拟器，自己写apk进行攻击\n * smali插桩\n * wasm","routePath":"/2023/06/02/ctf-mobile-startup/","lang":"","toc":[{"text":"Android","id":"android","depth":2,"charIndex":85},{"text":"准备的工具","id":"准备的工具","depth":3,"charIndex":96},{"text":"基础知识","id":"基础知识","depth":3,"charIndex":388},{"text":"解题思路","id":"解题思路","depth":3,"charIndex":588},{"text":"题目讲解","id":"题目讲解","depth":3,"charIndex":759},{"text":"数学家","id":"数学家","depth":4,"charIndex":788},{"text":"多少个MD5","id":"多少个md5","depth":4,"charIndex":885},{"text":"重定向进阶","id":"重定向进阶","depth":4,"charIndex":1007},{"text":"IOS","id":"ios","depth":2,"charIndex":1123},{"text":"总结","id":"总结","depth":2,"charIndex":1148},{"text":"未来展望（押题）","id":"未来展望押题","depth":2,"charIndex":1189}],"domain":"","frontmatter":{"layout":"post","title":"CTF Mobile 基础入门","date":"2023-06-02T12:30:00.000Z","categories":["技术"],"tags":["ctf","mobile","android","ios"]},"version":""},{"id":20,"title":"小米2023CTF安全赛道writeup","content":"#\n\n> 又是一年小米CTF，这次稍微卷了卷，拿到了第三名。奖品是一个小米手表（感觉没有去年好，23333）。但是有超多的证书和奖杯（有三个！！！）\n\n\nIoT#\n\n\nIoT-1 Cyber Pulse#\n\n> 想不到居然是个原题。。。https://ctftime.org/writeup/34125\n\n先用Logic2打开文件，然后导出为csv格式\n\n\n\n写个程序分析一下分布\n\n\n\n最后输出flag\n\n\n\n\n\n\nIoT-2 Debug#\n\nhint给了提示，解压sal文件，从json里搜索，找到了saleae公司下的Logic2软件可以打开该文件。\n\n用该软件分析数据，拼接字符串得到flag。\n\n\n\n\nIoT-3 PCB#\n\n找软件找了好久。。。群里大佬提示了一个【嘉立创CAM】（吐槽一下居然还要手机验证码登录），找了个Windows电脑安装了一下，载入zip压缩包。在三个图层里有f\nlag信息。（从0开始的PCB入门）\n\n\n\n\nIoT-4 BLE1#\n\n找到低功耗蓝牙的LTK。使用工具破解即可。https://github.com/mikeryan/crackle\n\n\n\n\nIoT-5 BLE3#\n\n这个题确实不难，就是工具没找到，卡了好久。\n\n用wireshark打开数据包文件，过滤条件输入btatt，首先看发送的基本信息。枚举BLE的handler，不停读取其中的信息，看到了一个里面有假的flag，\n提交上去肯定不是。\n\n\n\nbtatt里没有有用的信息，看了下外面其余信息，发现文件最后有一段配对交换和加密传输的过程。开始考虑怎么解密这个数据包。\n\n============================卡了好久分割线====================\n\n继续使用crackle解密，发现不支持。\n\n\n\n继续找，有人提到了怎么解密BLUETOOTH_LE_LL。https://github.com/arunima06/crackle\n但是代码没有合入master。用它提供的工具进行解密。成功获取了解密数据包文件。\n\n\n\nwireshark打开，翻找最后的请求，发现两段flag。flag{3dbd26cb04d9ae7b8c89628c032ee7d2}\n\n\n\n\nIoT-8 BLE2#\n\n这个题的步骤有点多。\n\n用wireshark打开数据包文件。过滤条件输入btatt，这里只关注数据传输的相关Frame。\n\n\n\n\n\n在中间部分发现了一个公钥的开头，后面的两个数据包都是在传输公钥。将两个数据包的公钥提取出来备用。\n\n合理猜测一下，接下来肯定要传输公钥加密后的密文了。把所有的Send Write Request的数据内容提取出来。\n\n\n\n这里存成hex字符串备用\n\n\n\n下一步需要解密这个字符串数据。这里涉及到公钥解密的算法，需要找到几个参数：\n\n 1. 获取公钥的基本信息\n 2. 将n转成10进制，在网站上 http://factordb.com/index.php?id=1100000001582802043 分解得到p和q。\n 3. 将获得的所有参数代入公式中，c是需要解密的密文。最终得到flag。（其实不想用python的，但是抵不住python处理大数真的很方便）\n\n\n\n\n\n\nIoT-9 你的Wi-Fi流量被监听了么？#\n\n给了一个pcap文件，第一次玩流量分析，一步一坑的解决了。\n\n用Wireshark打开文件，以为直接找HTTP协议，发现不行。都是802.11协议。查找发现是与wifi设备通信的协议，被加密了，需要获取解密密钥。\n\n这里用Aircrack-ng进行爆破\n\n\n\n爆破找到密码\n\n\n\n找到密码了之后可以用wireshark->Frame上右键->...->输入解密密钥。\n\n\n\n\n\n接下来wireshark会自动解密请求。然后开始找可疑请求，先从HTTP协议开始找，因为最容易辨认。\n\n\n\n可以看到有一个发送的POST请求，里面有可疑的flag，但是直接提交上去没有通过。\n\n猜测可能被加密了，因为Encrypted=1。用Base64解密，获取到了还算“正常”的flag，提交通过。\n\n\nIoT-10 7 segment#\n\n这是一个综合的题目，结合了前面的信号分析和PCB查看。\n\n> 开始还不知道7 segment是什么意思，后来又查了一下叫七段数码管，就是计算器那种展示方式。\n\n给了一个sal文件和PCB图纸。先看PCB图纸。\n\n\n\n是一个“荷魯斯之眼”的标识，里面有线路，线路连接着几个输入点。对照网上的引脚图，可以把输入点和对应显示的线段标识出来。\n\n\n\n\n\n然后看信号文件。\n\n\n\n对照信号文件把高低电平找出来，然后根据接口和线段的对应关系，就能把展示的数字还原出来。\n\n这里手动还原也可以。当然你也可以写个程序搜一下，就是把数字字母编码和对应的信息的排列组合试一下。把都满足的结果输出出来。\n\n\n\n最后一个是干扰项，搜索的时候暂时去掉了。\n\n最终还原出来的的信息是 8663161677b676f6f645f376f627d_ 。这个明显是加密的。。。但是不知道怎么解密。。。\n\n======================卡了很久的分割线=================\n\n期间试过很多种解密，都没啥效果。于是又把那个网站找出来 https://www.dcode.fr/cipher-identifier 判断一下加密方式。\n\n\n\n这四种概率挺高的，继续实验。在试到环式移位（Circular Bit Shift）发现结果很像一个flag。\n\n\n\n调整移位的数量，最终发现flag。\n\n\n\n\nMisc#\n\n\nmisc-1 红线！红线！红线！#\n\n根据提示 tomorrow is another day 去github上搜索（你说为什么不在gitlab里搜索？公司的gitlab有搜索吗。。。），\n找到一个仓库，翻看提交记录，找到flag\n\n\n\n\n\n\nmisc-2 有趣的前端#\n\n页面写了一些字符，不知道做什么的，直接看源码\n\n源码的\n\n蚁剑连接获取flag。\n\n\n\n\nweb-4 不安全的Redis服务#\n\n未认证的redis，找了几个利用方式，利用数据备份功能，条件都比较苛刻：\n\n * cron 反弹shell —— cron目录被删除\n * 写入ssh key —— ssh 拒绝连接\n * 写入php木马 —— 未提供php服务\n\n后来找到一个利用主从加载so文件的利用方式，成功获取交互式shell\n\nhttps://www.cnblogs.com/paperpen/p/11178751.html\n\n在根目录下获取到flag\n\n\nweb-5 真假难辨#\n\n访问indes.php会自动跳转到index.php，从而出现404\n\n用postman访问，禁用自动跳转，在header里找到了flag\n\n\n\n\nweb-6 低版本的Flask#\n\n在url里填写name参数后，访问的页面会打印填入的内容，猜测是个模板引擎的执行漏洞。\n\n找到了低版本Flask\nSSTI漏洞，flask使用jinjia2渲染引擎进行网页渲染，当处理不得当，未进行语句过滤，用户输入{{控制语句}}，会导致渲染出恶意代码，形成注入。\n\n构造注入语句，可以执行任意的shell语句，找到flag文件cat获取\n\n\n\n这里比较麻烦的一个是如何获取os._wrap_close类来执行shell命令，通过查找发现在所有子类的118位。这个是慢慢试出来的。\n\n\nweb-7 粗心上线#\n\n这个题目前期给的信息很少，这里猜测了一下，是不是把目录直接拷贝上线了，没有注意.git目录的存在。访问 http://10.167.93.41/.git/\n出现了禁止访问的字样，说明这个目录是存在的。http://10.167.93.41/.git/HEAD/ 也成功获取到了最新分支。\n\n剩下的就好办了，找到一个利用工具 https://github.com/lijiejie/GitHack ，执行命令\n\n\n\n会将远程的.git下载下来然后还原出flag文件。\n\n\nweb-8 ElasticSearch#\n\nes的远程执行，构造一个POST请求，获取到flag\n\n\n\n\nweb-9 才开始学nginx#\n\nhtml源码提示了flag的位置\n\n\n\n猜测是个路径遍历问题，试了一下/files/果然列出了路径，构造一个指向/tmp目录的路径，下载flag文件拿到flag。\n\n\n\n\nweb-10 标准模板：欢迎光临#\n\n放出hint提示模板引擎使用了thymeleaf，看路径包含的页面是通过url参数传入的，构造POC执行反弹shell\n\n\n\n\n\n\nweb-11 unserialize#\n\n题目提示给了两个参数file和data，file是一个文件包含命令，data的作用还不知道。\n\n首先通过file将index.php的源码获取过来\n\n\n\nbase64解码后就变成了一个实际的代码审计题目\n\n\n\n关键是对data处理，首先将data反序列化，然后Example在销毁的时候会自动打印 $file 的内容。\n于是就想到序列化构造一个数据，然后通过data反序列化来赋值 $file 参数，最终获取flag内容。\n\n构造Example序列化数据\n\n\n\n构造url执行\n\n\n\n\nweb-12 不安全的代理服务#\n\n这个题没太懂，就是一个页面放了一会儿，刷刷的在跑流量。\n\n\n\n发现有的public接口里附带了基本的认证参数，flag接口提示未认证。就想到重放flag接口，并添加认证参数。\n\n\n\n成功获取了flag。\n\n\nweb-13 php-audit#\n\nphp源码审计题目，发现禁止请求localhost，但是又告诉你flag在哪里\n\n\n\n利用curl的file协议，访问本地文件，构造url，获取flag\n\nhttp://10.167.34.65/index.php?url=file:///var/www/html/flag.php\n\n\n\n\nweb-14 jenkins#\n\n给了一个jenkins系统，未登录。试了一下弱口令admin/admin，居然登录进去了。开始找能列目录的地方。找了几圈在节点管理里发现一个执行命令的输入框。\n\n\n\n查找flag的位置，最后输出flag。\n\n\nweb-15 一个blog#\n\n文件包含，html里提供了包含的源码\n\n\n\n可以发现，只要page参数不等于flag，就直接与.php拼接然后include进来。\n\n所以，可以使用相对路径绕过对黑名单的判断page=./flag\n\n\nweb-16 认证绕过#\n\n这个题刚开始无从下手，就在乱试。页面就提供了一个/doLogin接口和登录失败提示可以通过/flag/get获取flag。\n\n开始想到sql注入，但是这个题目标题不像是通过sql进行操作的样子。于是就找响应的可以点。\n\n有个可以点是/doLogin接口会将RememberMe的cookie删掉。通过这个关键词入手，发现shiro存在认证绕过漏洞。\n\n有两类，一类是通过爆破Remember的加密方式，获取加密密钥修改权限。这个题目没有RememberMe的相关功能。\n\n第二类是构造特殊路径，绕过shiro的权限对路径的判断。尝试了几个，发现CVE-2020-13933可以使用。成功获取flag。\n\n\n\n\nweb-17 文件解析器#\n\nhint说可以解析xml。。。谷了一下有个Blind\nXXE实体引入的可以利用。而且也能正常回显。剩下的问题是flag的路径在哪里？随便猜了几个，运气好猜到了。。。\n\n\n\n\nweb-18 SELF GPT - 1#\n\n是个比较有名的开源项目 https://github.com/binary-husky/gpt_academic ，先下载代码看了一下。\n\nissue里有人提到了项目存在漏洞，但是没有后文了。\n\n然后就放在那里没有理它。。。\n\n==================One Year Later================\n\n想起来又拿出来看看。开始找python相关的漏洞。\n\n * 首先想到的是有没有调用系统shell执行命令的地方。发现了一个调用系统命令wget下载文献的地方，但是被注释了。\n * 项目使用了上传和解压压缩文件的功能。搜了一下，相关利用方式是上传一个带软链的目录，访问任意目录。\n * 上传的文件怎么下载下来。发现有个下载文件的接口，开放了/tmp/gradio/[随机串]的临时目录，和private_upload/[日期时间]/[上传文\n   件名]的目录。只能访问到具体文件，没有列目录的能力。\n * 然后开始构造软链，测试文件。\n   * /etc/hosts 可以访问\n   * /etc/passwd 可以访问\n   * /home/work 没有内容\n   * ../../.././xxxxxxxx/flag等可能的flag文件，没有找到\n   * /root/.bash_history 没有权限\n   * 又试了几个目录，../的软链会递归，然后用根目录的软链的话，程序会卡死。。。\n * 尝试了好多种方法没有突破。问题就卡在如何通过列目录找到flag文件（有点想放弃）\n * 猛然间想到要不从项目本身的文件找找突破口？\n * 构造了一个返回上几级的软链，看了一下这几个文件的内容，最后终于在config.py发现了硬编码的flag。flag{9fdeb6b22d04f449360\n   f99414397055e}\n\n\nweb-19 粗心的程序员！#\n\n这个题的点比较多，需要各个击破。\n\n第一个点是vim，很容易想到了vim的交换文件，访问 .index.php.swp 获取到交换文件。\n\n执行 vim -r .index.php.swp 还原出原文件。\n\n\n\n第二个是sprintf+addslashes的SQL注入，只要构造 %1$' or 1#\n在addslashes的作用下在单引号前面会插入一个\\，当传入sprintf时%就会‘吞掉’后面的\\，从而‘’’逃逸出来，完成注入。\n\n第三个需要跳过第18行的三个判断条件：\n\n 1. 年龄等于999，这怎么可能。可以在sql后面通过union all的方式补充一条假的数据 %1$' union all select 1, 999 #\n 2. password和password1的值不相等，但是md5运算却相等。刚开始想到了md5碰撞，但是后来想了想不应该这么复杂，就发现了PHP有个隐式转换的\n    缺陷，PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以\n    后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 构造例子 QNKCDZO 240610708\n    当然，安全的比较方法是三个=，也就是“===”。\n\n完成以上所有的点之后，最终构造出来的url就有了。请求获取flag\n\n\n\n\nweb-21 一个网络测试工具#\n\n这个题目传递一个ip参数，会对这个参数执行ping命令。想到了后端是不是使用了命令拼接直接交个shell执行。尝试分隔命令，引入自己的命令。\n\n试了几个分隔符都不行，而且使用了黑名单的分隔符会出现禁止访问的页面。（试分隔符卡了好久。。。）\n\n忽然想到ip的内容会回显到页面，可不可以通过二次运算的方式让执行命令的结果通过ping命令的报错回显出来。按照这个思路配合base64编码绕过字符检测，成功获取\n到了文件内容。\n\n\n\n可以看一下被困扰了好久的庐山真面目：\n\n\n\n\nweb-22 文件预览服务器#\n\n访问地址，提示提供filepath，随便试了几个，只是返回“文件不存在”。\n\n试了下index.php，发现返回了源码。\n\n\n\n源码告诉了flag的位置和基本的代码逻辑。\n\n看注释，说是不能包含两个连续的上一级，那就用当前目录隔开就行了。构造filepath获取flag。\n\n\n\n\nweb-23 PHP IS BEST#\n\nphp源码审计题\n\n\n\n从get参数的two传递一个路径，获取这个路径的值，并且与one中的值比较，如果相等则输出flag。\n\n这个题目的关键是如何将two的值变为我们可控的一个值，正好file_get_contents支持获取base64编码的data值，由此构造一个请求。\n\n\n\n\nweb-24 简约但不简单#\n\nping命令绕过，找到了一个原题。\n\n首先获取index.php代码，绕过空格。 ?ip=1;cat$IFS$1index.php\n\n\n\n看到代码确定是原题了。用拼接的方法，绕过对flag顺序的检测\n?ip=1%3ba%3dag.php%3bb%3dfl%3bcat%24IFS%241%24b%24a\n\n\nweb-25 神奇的计算器#\n\n随便输入一个表达式，会自动包裹#{}然后返回表达式结果，猜测是spEL的表达式引擎。spEL表达式可以通过T()获取类，然后利用内部的类执行一些命令。\n\n思路是这样，实际操作过程中，发现过滤了很多关键词\n\n\n\n这就导致getClass()然后forName()获取对应类的方法无法使用了。\n\n试了好几个方法，终于发现一个读文件的方式没有被过滤，根据前几个Java题猜测（可能是一个人出的题目）flag的文件名是flag.txt。写入脚本成功获取flag\n。\n\n\n\n\nweb-26 天女散花#\n\n上来给了一个页面，试了一下，发现跳转到error.html，开始猜测页面地址。最后猜到了success.html有内容。\n\n\n\n提供了四个页面，前三个每个页面的源码都能看到一段flag。\n\n\n\n\n\n\n\n最后一个页面通过链接跳转不过去，看页面分布情况，猜测最后一个页面地址是04.html\n\n\n\n拼凑出来提交flag。\n\n\nweb-27 想获取flag吗#\n\n提示给出来说要先获取源码，查看提示可以尝试包含ma.php。在index.php试了几个参数，发现file=可以包含。获取index.php和ma.php的源码\n。\n\n\n\n这里重点看一下ma.php的源码，是一个绕过\n\n\n\n看样子禁用了空格，一些基本的查看命令，尝试了几种方法，最后用base64编码+空格绕过的方式获取到的flag。\n\n\n\n空格使用 $IFS$9 绕过，命令编码base64，内容是 cat /flag.txt。\n\n\nweb-28 神奇的魔方#\n\n开始给了个页面，是个魔方游戏。开始找页面源码的内容。\n\n\n\n这段奇怪的混淆最终证明确实是控制台输出的那些文本。。。\n\n然后看到了请求头里返回的服务器名称openresty/1.21.4.1有什么漏洞可以用，找了一下也没有。。。\n\n注意到网站会把不存在的资源返回index.gk的内容，试了一个static和uploads里常用的路径（例如/static/index.css），发现不太行。（\n事后发现，直接访问/uploads路径就出来了）。。。考虑到一个一个猜比较麻烦，就上路径扫描了。\n\n\n\n发现有个下载路径/download指定file可以下载文件。尝试下载/download?file=/flag/flag.txt，感觉没那么容易。会删除ag/和.\n./这两个字符串。\n\n这好说，构造一下就行了：\n\n * ..././ 代替 ../\n * agag// 代替 ag/\n\n最终获取flag。\n\n\n\n\nweb-29 拿到管理员权限就能得到flag啦！#\n\n上来就能看到源码，是一个代码审计题目。直接拿代码的关键词谷歌，发现是CBC翻转字节攻击的方法。找到一篇博客里面有POC。https://chybeta.gith\nub.io/2017/11/18/LCTF-2017-Simple-blog-writeup/\n\n参考里面的代码，实现了一版Java版本的，开始爆破，几分钟救出来了。。。（调代码调了几个小时。。。\n\n\n\n\n\n\nweb-30 魔法再现#\n\n去年有两个这样的题目，今年又来了一个。猜测是ImageMagick相关的漏洞。\n\n先看现象，上传一个图片文件（限定了几种格式），会转成png文件，然后图片宽高被调整到50x50。页面中也出现了flag{******}字样，目标明确了，就是想办\n法读取index.php文件里的flag。\n\n然后开始找imagemagick的相关漏洞\n\n================找了好几天的分割线=================\n\n偶然间发现了2022年新的漏洞CVE-2022-44268远程文件泄露漏洞。具体漏洞内容就不详述了。下面说利用过程。\n\n 1. 首先准备一个空白的png用于上传。\n\n\n\n 2. 给png的exif写入profile和文件路径，用于触发文件读取。\n\n\n\nprofile是exif的属性名，index.php是读取的文件名。 3. 将文件上传到网站，把处理后的文件下载下来。 4. 解析处理后文件的数据\n\n\n\n5. 把这段代码用hex解码，获取文件内容，从中可以找到flag。（注意开头的862是无用的，不要跟后面的在一起解码。）\n\n\nweb-31 密钥，密钥，不能默认#\n\n观察端口9080和返回的header-server数据，判断是 Apache APISIX，通过搜索发现有个默认密钥漏洞\nCVE-2020-13945。构造请求，添加任意命令执行的路由。\n\n\n\n然后访问执行命令，获取目录内容，进而得到flag\n\n\n\n\nweb-32 Actuator 404#\n\n这个题知道是找actuator的端点，直接访问是返回404。猜测缺少一个路径前缀。扫了所有3位字符的组合路径/aaa/actuator/env没发现有内容。。。\n\n==================卡了很久的分割线=================\n\n放出了hint：/xiaomi/management/\n\n拼接路径/xiaomi/management/actuator/env找到了端点。然后就是各种翻找，在/xiaomi/management/actuator/h\nttptrace发现了一个奇怪的地址。/xiaomi/ctf/api/v1/userInfo?id=1\n\n遍历id，在第999个ID发现了flag。\n\n\n\n","routePath":"/2023/05/06/mi-ctf-2023-writeup/","lang":"","toc":[{"text":"IoT","id":"iot","depth":2,"charIndex":76},{"text":"IoT-1 Cyber Pulse","id":"iot-1-cyber-pulse","depth":3,"charIndex":83},{"text":"IoT-2 Debug","id":"iot-2-debug","depth":3,"charIndex":208},{"text":"IoT-3 PCB","id":"iot-3-pcb","depth":3,"charIndex":305},{"text":"IoT-4 BLE1","id":"iot-4-ble1","depth":3,"charIndex":421},{"text":"IoT-5 BLE3","id":"iot-5-ble3","depth":3,"charIndex":495},{"text":"IoT-8 BLE2","id":"iot-8-ble2","depth":3,"charIndex":950},{"text":"IoT-9 你的Wi-Fi流量被监听了么？","id":"iot-9-你的wi-fi流量被监听了么","depth":3,"charIndex":1368},{"text":"IoT-10 7 segment","id":"iot-10-7-segment","depth":3,"charIndex":1735},{"text":"Misc","id":"misc","depth":2,"charIndex":2348},{"text":"misc-1 红线！红线！红线！","id":"misc-1-红线红线红线","depth":3,"charIndex":2356},{"text":"misc-2 有趣的前端","id":"misc-2-有趣的前端","depth":3,"charIndex":2478},{"text":"misc-3 敏感数据","id":"misc-3-敏感数据","depth":3,"charIndex":-1},{"text":"misc-4 ez forensics","id":"misc-4-ez-forensics","depth":3,"charIndex":-1},{"text":"misc-5 ChatGPT","id":"misc-5-chatgpt","depth":3,"charIndex":-1},{"text":"misc-6 弦外之音","id":"misc-6-弦外之音","depth":3,"charIndex":-1},{"text":"Mobile","id":"mobile","depth":2,"charIndex":-1},{"text":"mobile-1 ba5e64","id":"mobile-1-ba5e64","depth":3,"charIndex":-1},{"text":"mobile-2 xor","id":"mobile-2-xor","depth":3,"charIndex":-1},{"text":"mobile-3 MAZE","id":"mobile-3-maze","depth":3,"charIndex":-1},{"text":"mobile-4 重定向初探","id":"mobile-4-重定向初探","depth":3,"charIndex":-1},{"text":"mobile-5 数学家","id":"mobile-5-数学家","depth":3,"charIndex":-1},{"text":"mobile-6 多少个MD5","id":"mobile-6-多少个md5","depth":3,"charIndex":-1},{"text":"mobile-7 pdd","id":"mobile-7-pdd","depth":3,"charIndex":-1},{"text":"mobile-9 bqq","id":"mobile-9-bqq","depth":3,"charIndex":-1},{"text":"mobile-10 VM","id":"mobile-10-vm","depth":3,"charIndex":-1},{"text":"mobile-11 重定向进阶","id":"mobile-11-重定向进阶","depth":3,"charIndex":-1},{"text":"Web","id":"web","depth":2,"charIndex":-1},{"text":"web-1 聊天室","id":"web-1-聊天室","depth":3,"charIndex":-1},{"text":"web-2 风险组件","id":"web-2-风险组件","depth":3,"charIndex":-1},{"text":"web-3 简单文件包含","id":"web-3-简单文件包含","depth":3,"charIndex":-1},{"text":"web-4 不安全的Redis服务","id":"web-4-不安全的redis服务","depth":3,"charIndex":2538},{"text":"web-5 真假难辨","id":"web-5-真假难辨","depth":3,"charIndex":2775},{"text":"web-6 低版本的Flask","id":"web-6-低版本的flask","depth":3,"charIndex":2862},{"text":"web-7 粗心上线","id":"web-7-粗心上线","depth":3,"charIndex":3124},{"text":"web-8 ElasticSearch","id":"web-8-elasticsearch","depth":3,"charIndex":3372},{"text":"web-9 才开始学nginx","id":"web-9-才开始学nginx","depth":3,"charIndex":3425},{"text":"web-10 标准模板：欢迎光临","id":"web-10-标准模板欢迎光临","depth":3,"charIndex":3529},{"text":"web-11 unserialize","id":"web-11-unserialize","depth":3,"charIndex":3614},{"text":"web-12 不安全的代理服务","id":"web-12-不安全的代理服务","depth":3,"charIndex":3878},{"text":"web-13 php-audit","id":"web-13-php-audit","depth":3,"charIndex":4000},{"text":"web-14 jenkins","id":"web-14-jenkins","depth":3,"charIndex":4165},{"text":"web-15 一个blog","id":"web-15-一个blog","depth":3,"charIndex":4287},{"text":"web-16 认证绕过","id":"web-16-认证绕过","depth":3,"charIndex":4404},{"text":"web-17 文件解析器","id":"web-17-文件解析器","depth":3,"charIndex":4723},{"text":"web-18 SELF GPT - 1","id":"web-18-self-gpt---1","depth":3,"charIndex":-1},{"text":"web-19 粗心的程序员！","id":"web-19-粗心的程序员","depth":3,"charIndex":5632},{"text":"web-21 一个网络测试工具","id":"web-21-一个网络测试工具","depth":3,"charIndex":6262},{"text":"web-22 文件预览服务器","id":"web-22-文件预览服务器","depth":3,"charIndex":6516},{"text":"web-23 PHP IS BEST","id":"web-23-php-is-best","depth":3,"charIndex":6674},{"text":"web-24 简约但不简单","id":"web-24-简约但不简单","depth":3,"charIndex":6838},{"text":"web-25 神奇的计算器","id":"web-25-神奇的计算器","depth":3,"charIndex":7008},{"text":"web-26 天女散花","id":"web-26-天女散花","depth":3,"charIndex":7257},{"text":"web-27 想获取flag吗","id":"web-27-想获取flag吗","depth":3,"charIndex":7432},{"text":"web-28 神奇的魔方","id":"web-28-神奇的魔方","depth":3,"charIndex":7668},{"text":"web-29 拿到管理员权限就能得到flag啦！","id":"web-29-拿到管理员权限就能得到flag啦","depth":3,"charIndex":8086},{"text":"web-30 魔法再现","id":"web-30-魔法再现","depth":3,"charIndex":8299},{"text":"web-31 密钥，密钥，不能默认","id":"web-31-密钥密钥不能默认","depth":3,"charIndex":8791},{"text":"web-32 Actuator 404","id":"web-32-actuator-404","depth":3,"charIndex":8937}],"domain":"","frontmatter":{"layout":"post","title":"小米2023CTF安全赛道writeup","date":"2023-05-06T12:00:00.000Z","categories":["CTF"],"tags":["CTF","writeup"]},"version":""},{"id":21,"title":"重放攻击与Rust与WebAssembly","content":"#\n\n> 本文主要介绍重放攻击的原理和防范措施。并尝试使用rust编译的wasm模块实现重放攻击中的请求签名算法。\n\n\n什么是重放攻击？#\n\n重放攻击（Replay Attack）是一种网络攻击方式，攻击者通过录制合法用户的网络通信报文，再将其在未经授权的情况下重新发送给目标服务器，\n以达到欺骗服务器的目的。\n\n重放攻击的原理是攻击者在通信过程中拦截了合法用户与服务器之间的数据包，并将其保存下来。当攻击者想要对服务器进行攻击时，\n他就将之前拦截到的数据包重新发送给服务器，从而欺骗服务器以为这是一个合法的请求。\n\n例如，一个简单的重放攻击可以是攻击者在进行抽奖的时候，记录下该请求，然后将请其重放到服务器上，以假乱真地模拟用户进行抽奖的过程。\n由于服务器并不能区别这些请求是否为重放攻击，因此攻击者可以通过这种方式获得更多的抽奖机会，从而提高自己中奖的概率。另一方面，\n攻击者通过脚本可以在短时间内大量的发送重放请求，影响正常用户的使用。这种攻击方式往往会导致用户的合法权益受到损失，\n因此对于网络安全来说，重放攻击是一种比较严重的威胁。\n\n\n防范重放攻击的措施#\n\n目前防范重放攻击的措施可以包括以下几个方面：\n\n * 加密通信数据：使用加密技术可以有效地防止重放攻击，因为攻击者即使拦截了通信数据，也不能破解加密后的数据内容。\n * 时间戳（timestamp）：在通信数据中加入时间戳，在服务器端接收到请求后，检查时间戳的合法性，如果时间戳已经过期，则拒绝请求。\n * 随机数（nonce）：在通信数据中加入随机数，服务器端接收到请求后，检查随机数的合法性，如果随机数已经被使用过，则拒绝请求。\n * 消息摘要（sign）：使用消息摘要技术可以防止重放攻击。在通信数据中加入消息摘要，服务器端接收到请求后，计算消息摘要，如果计算结果与请求中的消息摘要不符，\n   则拒绝请求。\n\n总之，防范重放攻击的关键在于在通信过程中加入一些验证机制，以确保每个请求都是合法唯一的。\n\n\n消息摘要的实现#\n\n\n普通js实现消息摘要#\n\n要实现消息摘要算法比较容易，下面以axios框架为例：\n\n\n\n将url请求地址和query拼接后形成需要签名的url，对url使用HmacSHA1进行签名。最后生成签名后的sign。这其中有几部分需要注意：\n\n * 签名附带url，使得当前签名只针对该接口，防止将请求参数赋给其它url使用。\n * timestamp，一般是请求的当前时间，用于后端校验签名的有效期，后端只会处理在有效期内的接口。\n * nonce，是一个随机字符串，保证请求在一段时间内（一般与timestamp的有效期一致）只会使用一次。这个参数是防止重放攻击的关键。需要后端缓存记录已经\n   使用过的nonce字符串。\n * token和secretKey，是一对加密密钥，用于区分不同的后端系统，防止相同的url地址重放给不同的后端系统服务使用。\n\n签名方法保障的是在有效期内，一次签名的请求只会被请求响应一次，而通过加密验签保障了客户端的请求参数不会被随意修改。\n\nTIP\n\n但是随之而来的问题是，这个计算请求摘要的逻辑由于是js实现，通过浏览器的控制台很容易被逆向，知道了加密规则和密钥的签名很容易被伪造。于是如何更好的混淆代码，保障\n加密密钥的安全性，是下一步应该考虑的问题。\n\n\nwasm与rust#\n\n要隐藏消息计算的计算逻辑，首先想到的是客户端采用更加难以理解的混淆代码的方式。正好在前端领域里，WebAssembly就是这样一种格式。\n\n\n什么是wasm？#\n\nWebAssembly是一种二进制指令格式，简称为Wasm，它可以运行在适用于堆栈的虚拟机上。\n\nWebAssembly存在的意义就是成为编程语言的可移植编译目标，让在Web上部署客户端和服务端应用成为可能。\n\n\n\n由于wasm是一种二进制的文件格式，相对于解释型的js语言来说，就有更快的执行速度、更高的安全性等优势。\n\n\n\nTIP\n\n在这里，wasm被用来混淆加密逻辑，并隐藏计算请求摘要的对称加密token。如何方便的编写wasm代码，是下一个需要解决的问题。\n\n\n为什么是Rust？#\n\n> Rust是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust在语法上和C++类似，\n> 但是设计者想要在保证性能的同时提供更好的内存安全。 Rust最初是由Mozilla研究院的Graydon Hoare设计创造，然后在Dave Herman、\n> Brendan\n> Eich以及很多其他人的贡献下逐步完善的。Rust的设计者们通过在研发Servo网站浏览器布局引擎过程中积累的经验优化了Rust语言和Rust编译器。\n\nRust在编写node工具链和WebAssembly等领域的贡献非常大，市面上大部分node工具都打算使用Rust进行重写，以提升安全性和性能。特别提到的是，\n下一代webpack打包工具Rspack，就是使用Rust编写的，号称有10x以上的性能提升。\n\n总之，使用Rust来编写wasm代码会非常简单。当然，我们也不是想用Rust来替代JavaScript的语言，而是与其形成互补，在需要更高性能的地方借助系统编程\n语言来提升效率。\n\n\n从零开始的Rust#\n\n在开始使用Rust编写代码之前，先了解一些Rust系统的工具链概念。\n\ncargo#\n\ncargo是rust的代码组织和包管理工具，你可以将它类比为node.js中的npm。\n\n\n\ncargo 提供了一系列强大的功能，从项目的建立、构建到测试、运行直至部署，为rust项目的管理提供尽可能完整的手段。\n同时，它也与rust语言及其编译器rustc本身的各种特性紧密结合。\n\nrustup#\n\nrustup是Rust的安装和工具链管理工具，并且官网推荐使用rustup安装Rust。\n\n\n\nrustup将rustc和cargo等工具安装在Cargo的bin目录，但这些工具只是Rust工具链中组件的代理，真正工作的是工具链中的组件。 通过\nrustup 的命令可以指定使用不同版本的工具链。\n\nwasm-bindgen#\n\n\n\nwasm-bindgen提供了JS和Rust类型之间的桥梁，它允许JS使用字符串调用Rust API，或者使用Rust函数来捕获JS异常。\n\nwasm-bindgen的核心是促进javascript和Rust之间使用wasm进行通信。它允许开发者直接使用Rust的结构体、javascript的类、字符\n串等类型，而不仅仅是wasm支持的整数或浮点数类型。\n\nwasm-pack#\n\n\n\nwasm-pack 由 Rust / Wasm 工作组开发维护，是现在最为活跃的 WebAssembly 应用开发工具。\n\nwasm-pack 支持将代码打包成 npm 模块，并且附带 Webpack 插件（wasm-pack-plugin），借助它，我们可以轻松的将 Rust\n与已有的 JavaScript 应用结合。\n\nwasm32-unknown-unknown#\n\n\n\n通过 rustup 的 target 命令可以指定编译的目标平台，也就是编译后的程序在哪种操作系统上运行。\n\nwasm-pack 使用 wasm32-unknown-unknown 目标编译代码。\n\n\n实现一个简单的wasm程序#\n\n下面实现一个简单的wasm-helloworld程序，通过调用浏览器的alert指令弹出消息提示。\n\n创建一个新的rust项目#\n\n\n\n将会创建 rust 库工程，并创建src/lib.rs。修改为以下内容：\n\n\n\n这段代码的含义是：\n\n * 第6行：从外部导入alert函数，使得rust可以调用js的alert语句。\n * 第11行：导出一个greet函数，该函数接收一个name参数，并调用导入的alert指令输出hello {{name}}的语句。\n\n接着在 Cargo.toml 文件中添加 wasm-bindgen 依赖，wasm-bindgen 来提供 JavaScript 和 Rust 类型之间的桥梁，\n允许 JavaScript 使用字符串调用 Rust API，或调用 Rust 函数来捕获 JavaScript 异常。\n\n\n\n打包#\n\n下载 wasm-pack，用于将 rust 代码打包成 .wasm 文件\n\n\n\n执行构建命令\n\n\n\n就会在pkg目录下生成打包好的js文件、wasm文件和ts类型文件。\n\n\n\n借助 wasm-pack 可以非常轻松的将 rust 打包成 wasm，同时还提供了 js 相关支持。直接打包成 js 可导入的 npm 包， 而不是让用户导入\nwasm 文件然后通过浏览器 WebAssembly 对象来加载 WebAssembly 代码，其他语言的 WebAssembly 开发也是如此。\n\n运行#\n\n本地运行的话可以将pkg拷贝到项目目录，然后添加以下代码进行引用：\n\n\n\n\n使用Rust编写消息摘要计算逻辑#\n\n根据前面的逻辑，生成时间戳、随机数、拼接URL的逻辑都可以在JS端完成。确定这里rust需要实现的逻辑是，拿到url之后，在最后拼接token，然后对其进行hm\nac-sha1加密。\n\n和从npm找需要的包一样，这里需要从 crates.io 中也可以找到你想要的库。这里用两个库ring（用于加密）和hex（用于生成转十六进制字符）。\n\n\n\n下面是封装的签名代码，可以放在一个单独的模块文件里signer.rs\n\n\n\n然后在开始的lib.rs文件引用这个模块，并导出一个签名函数：\n\n\n\n此时通过 wasm-pack 将上述代码打包成 lib 库，在代码中调用sign函数实现的签名逻辑。至此就实现本标题的内容了。\n\n\n更好的开发体验#\n\n每次开发调试都要打包构建、引入，然后重启服务。未免有点繁琐，其实借助 @wasm-tool/wasm-pack-plugin 的webpack插件，\n就能实现rust代码的实时热更新功能。提升开发体验。\n\n在rust模块项目下增加一个package.json，用于引入依赖库。\n\n\n\n增加一个webpack.config.js的配置文件，用来启动devServer。\n\n\n\n最后增加一个index.js的入口文件：\n\n\n\n执行命令启动devServer，在浏览器的控制台里就能看到输出的签名结果。\n\n\n\n而且编辑rust代码，能实时触发热更新，可谓是非常的nice~\n\n\n思考：如何提高签名模块的安全性和通用性#\n\n虽说使用wasm可以隐藏加密密钥，但是如果获取了wasm文件，还是能本地调用的。\n\n思考一下这个问题，可以校验当前浏览器的域名，只有符合域名规则的浏览器才能使用本服务。当前这种方法也不是绝对的，因为本地也可以用反向代理、改/etc/hosts等\n方法将域名指向本地服务。\n\n另一方面如何针对不同服务使用不同的加密密钥？\n\n这里考虑了两个方案，一个是将密钥表硬编码到wasm中，根据传入的app_id来找到对应的加密密钥。\n\n另一个可以考虑将app_id和密钥再通过非对称加密之后的字符串，作为参数传入到签名方法里，签名方法解密获取到app_id和密钥再执行消息摘要的逻辑。这就是典型的\n把钥匙锁在保险箱里的方法了。\n\n\n总结#\n\n从最近几年的发展来看，Rust在大前端领域的势头锐不可当。为了不脱离大趋势，于是本文借助一个url验签的安全场景，\n尝试使用rust解决代码中存在的安全问题。后续也会继续思考rust在前端其它方面的应用，以此提高代码的安全性和运行效率。\n\n“没有绝对的安全，只有相对的安全”。就在这种攻防互搏的观念中，代码逻辑变得复杂起来了。\n\n\n参考内容#\n\n * web前端培训：使用 Rust 编写 React 组件\n * Rust实现MD5加密并打包成WebAssembly调用","routePath":"/2023/04/29/replay-attack-and-rust-and-webassembly/","lang":"","toc":[{"text":"什么是重放攻击？","id":"什么是重放攻击","depth":2,"charIndex":59},{"text":"防范重放攻击的措施","id":"防范重放攻击的措施","depth":3,"charIndex":473},{"text":"消息摘要的实现","id":"消息摘要的实现","depth":2,"charIndex":841},{"text":"普通js实现消息摘要","id":"普通js实现消息摘要","depth":3,"charIndex":852},{"text":"wasm与rust","id":"wasm与rust","depth":2,"charIndex":1398},{"text":"什么是wasm？","id":"什么是wasm","depth":3,"charIndex":1481},{"text":"为什么是Rust？","id":"为什么是rust","depth":3,"charIndex":1728},{"text":"从零开始的Rust","id":"从零开始的rust","depth":3,"charIndex":2202},{"text":"cargo","id":"cargo","depth":4,"charIndex":2250},{"text":"rustup","id":"rustup","depth":4,"charIndex":2401},{"text":"wasm-bindgen","id":"wasm-bindgen","depth":4,"charIndex":2560},{"text":"wasm-pack","id":"wasm-pack","depth":4,"charIndex":2757},{"text":"wasm32-unknown-unknown","id":"wasm32-unknown-unknown","depth":4,"charIndex":2934},{"text":"实现一个简单的wasm程序","id":"实现一个简单的wasm程序","depth":3,"charIndex":3062},{"text":"创建一个新的rust项目","id":"创建一个新的rust项目","depth":4,"charIndex":3129},{"text":"打包","id":"打包","depth":4,"charIndex":3453},{"text":"运行","id":"运行","depth":4,"charIndex":3702},{"text":"使用Rust编写消息摘要计算逻辑","id":"使用rust编写消息摘要计算逻辑","depth":2,"charIndex":3745},{"text":"更好的开发体验","id":"更好的开发体验","depth":3,"charIndex":4075},{"text":"思考：如何提高签名模块的安全性和通用性","id":"思考如何提高签名模块的安全性和通用性","depth":3,"charIndex":4371},{"text":"总结","id":"总结","depth":2,"charIndex":4703},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":4874}],"domain":"","frontmatter":{"layout":"post","title":"重放攻击与Rust与WebAssembly","date":"2023-04-29T00:00:00.000Z","categories":["果然还是前端"],"tags":["Rust","WebAssembly","重放攻击"]},"version":""},{"id":22,"title":"2022小米编程大赛题解","content":"#\n\n> 小米编程大赛是每年1024的固定活动，依托于力扣的周赛和双周赛，进行内部排名。\n\n\n第一场-第 90 场双周赛#\n\n\n2451. 差值数组不同的字符串#\n\n题目#\n\n给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。\n\n每个字符串 words[i] 可以被转化为一个长度为 n - 1 的 差值整数数组 difference[i] ， 其中对于 0 <= j <= n - 2 有\ndifference[i][j] = words[i][j+1] - words[i][j] 。 注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说\n'a' 的位置是 0 ，'b' 的位置是 1 ，'z' 的位置是 25 。\n\n * 比方说，字符串 \"acb\" 的差值整数数组是 [2 - 0, 1 - 2] = [2, -1] 。\n\nwords 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。\n\n请你返回words中 差值整数数组 不同的字符串。\n\n示例 1：\n\n\n\n示例 2：\n\n\n\n提示：\n\n * 3 <= words.length <= 100\n * n == words[i].length\n * 2 <= n <= 20\n * words[i] 只含有小写英文字母。\n\n思路#\n\n这个题目方法有很多，比如按照题目要求进行处理，将处理后的数组转换成字符串，通过HashMap判断。\n\n我的思路是，找到字符串中最小的字符，将所有字符的值向下平移，使最小字符的值为a。这样的字符串就是满足题目要求的字符串。\n统计这样字符串的数量，找到数量为1的字符串对应的原始字符串。\n\n> 足足写了7分钟😭老年人手速\n\n代码#\n\n\n\n\n2452. 距离字典两次编辑以内的单词#\n\n题目#\n\n给你两个字符串数组 queries 和 dictionary 。数组中所有单词都只包含小写英文字母，且长度都相同。\n\n一次 编辑 中，你可以从 queries 中选择一个单词，将任意一个字母修改成任何其他字母。 从 queries 中找到所有满足以下条件的字符串：不超过\n两次编辑内，字符串与 dictionary 中某个字符串相同。\n\n请你返回 queries 中的单词列表，这些单词距离 dictionary 中的单词 编辑次数 不超过 两次 。 单词返回的顺序需要与 queries\n中原本顺序相同。\n\n示例 1：\n\n\n\n示例 2：\n\n\n\n提示：\n\n * 1 <= queries.length, dictionary.length <= 100\n * n == queries[i].length == dictionary[j].length\n * 1 <= n <= 100\n * 所有 queries[i] 和 dictionary[j] 都只包含小写英文字母。\n\n思路#\n\n两层for循环的模拟，对于queries的每个单词，遍历dict中的单词，计算两个单词的距离是否小于等于2即可。\n\n代码#\n\n\n\n\n2453. 摧毁一系列目标#\n\n题目#\n\n给你一个下标从 0 开始的数组 nums ，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数 space 。\n\n你有一台机器可以摧毁目标。给机器 输入 nums[i] ，这台机器会摧毁所有位置在 nums[i] + c * space 的目标， 其中 c\n是任意非负整数。你想摧毁 nums 中 尽可能多 的目标。\n\n请你返回在摧毁数目最多的前提下，nums[i] 的 最小值 。\n\n示例 1：\n\n\n\n示例 2：\n\n\n\n示例 3：\n\n\n\n提示：\n\n * 1 <= nums.length <= 10^5\n * 1 <= nums[i] <= 10^9\n * 1 <= space <= 10^9\n\n思路#\n\n数学化简对于一个数字x，(x + space * n) % n = x % n，于是题目就转化成判断 x % n 的值的次数最大的值的最小那个。\n\n> 错了一次，最开始的思路对题目理解有点问题，以为需要连续，于是就做了一个链，数组从小到大。\n> 对于当前元素x，判断x-space是否存在，存在就将x-space的总次数+1。\n\n代码#\n\n\n\n\n2454. 下一个更大元素 IV#\n\n题目#\n\n给你一个下标从 0 开始的非负整数数组 nums 。对于 nums 中每一个整数，你必须找到对应元素的 第二大 整数。\n\n如果 nums[j] 满足以下条件，那么我们称它为 nums[i] 的 第二大 整数：\n\n * j > i\n * nums[j] > nums[i]\n * 恰好存在 一个 k 满足 i < k < j 且 nums[k] > nums[i] 。\n\n如果不存在 nums[j] ，那么第二大整数为 -1 。\n\n * 比方说，数组 [1, 2, 4, 3] 中，1 的第二大整数是 4 ，2 的第二大整数是 3 ，3 和 4 的第二大整数是 -1 。\n\n请你返回一个整数数组answer ，其中answer[i]是nums[i] 的第二大整数。\n\n示例 1：\n\n\n\n示例 2：\n\n\n\n提示：\n\n * 1 <= nums.length <= 10^5\n * 0 <= nums[i] <= 10^9\n\n思路#\n\n参考下一个更大的元素的思路，可以维护一个单调栈来解决。下下一个更大的元素，理论上需要两个单调栈。第一个单调栈出来的元素，\n说明已经找到第一个比它大的元素。放在第二个单调栈里等待找到第二个比它大的元素。\n\n> 两个栈的版本没有调试好该怎么做，错了两次之后，改成TreeMap的模式，自动排序。使用TreeMap的时候注意处理重复元素。\n\n代码#\n\n\n\n\n第二场-第 317 场周赛#\n\n\n2455. 可被三整除的偶数的平均值#\n\n题目#\n\n给你一个由正整数组成的整数数组 nums ，返回其中可被 3 整除的所有偶数的平均值。\n\n注意：n 个元素的平均值等于 n 个元素 求和 再除以 n ，结果 向下取整 到最接近的整数。\n\n示例1：\n\n\n\n示例2：\n\n\n\n提示：\n\n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 1000\n\n思路#\n\n模拟，过滤出满足要求（被3整除、被2整除）的整数，求和求平均值即可。\n\n> 这个题被坑了一次，主要没看到 偶数 这个关键词，其它的没什么难点。\n\n代码#\n\n\n\n\n2456. 最流行的视频创作者#\n\n题目#\n\n给你两个字符串数组 creators 和 ids ，和一个整数数组 views ，所有数组的长度都是 n 。 平台上第 i 个视频者是 creator[i]\n，视频分配的 id 是 ids[i] ，且播放量为 views[i] 。\n\n视频创作者的 流行度 是该创作者的 所有 视频的播放量的 总和 。 请找出流行度 最高 创作者以及该创作者播放量 最大 的视频的 id 。\n\n * 如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。\n * 如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 id 。\n\n返回一个二维字符串数组answer，其中answer[i] = [creator_i, id_i]表示creator_i 的流行度 最高 且其最流行的视频 id\n是id_i，可以按任何顺序返回该结果。\n\n示例1：\n\n\n\n示例2：\n\n\n\n提示：\n\n * n == creators.length == ids.length == views.length\n * 1 <= n <= 10^5\n * 1 <= creators[i].length, ids[i].length <= 5\n * creators[i] 和 ids[i] 仅由小写英文字母组成\n * 0 <= views[i] <= 10^5\n\n思路#\n\n模拟，这个题就是代码量大点，细心点没什么难点\n\n代码#\n\n\n\n\n2457. 美丽整数的最小增量#\n\n题目#\n\n给你两个正整数 n 和 target 。\n\n如果某个整数每一位上的数字相加小于或等于 target ，则认为这个整数是一个 美丽整数 。\n\n找出并返回满足 n + x 是 美丽整数 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。\n\n示例 1：\n\n\n\n示例 2：\n\n\n\n示例 3：\n\n\n\n提示：\n\n * 1 <= n <= 10^12\n * 1 <= target <= 150\n * 生成的输入保证总可以使 n 变成一个美丽整数。\n\n思路#\n\n贪心做法，由于数字只能增加，要减小所有数字的和，只能通过进位的方式让当前位变成0。\n\n例如467，每位数字和为17，通过进位让数字变为467+3=470，每位数字和为就变为了11，成功降低了每位数字和。\n通过补齐所有位数，最小可以降到1，467+533=1000。\n\n思路就变成了，枚举进位位置，找到最低位能够满足要求的进位位置。注意特判一下不需要任何操作0的情况。\n\n> 提交错了两次，问题出在想把0的情况融合在for循环中，最后还是特判了一下。\n\n代码#\n\n\n\n\n2458. 移除子树后的二叉树高度#\n\n题目#\n\n给你一棵 二叉树 的根节点 root ，树中有 n 个节点。每个节点都可以被分配一个从 1 到 n 且互不相同的值。 另给你一个长度为 m 的数组\nqueries 。\n\n你必须在树上执行 m 个 独立 的查询，其中第 i 个查询你需要执行以下操作：\n\n * 从树中 移除 以 queries[i] 的值作为根节点的子树。题目所用测试用例保证 queries[i] 不 等于根节点的值。\n\n返回一个长度为 m 的数组answer，其中answer[i]是执行第 i 个查询后树的高度。\n\n注意：\n\n * 查询之间是独立的，所以在每个查询执行后，树会回到其 初始 状态。\n * 树的高度是从根到树中某个节点的 最长简单路径中的边数 。\n\n示例 1：\n\n\n\n\n\n示例 2：\n\n\n\n\n\n提示：\n\n * 树中节点的数目是 n\n * 2 <= n <= 10^5\n * 1 <= Node.val <= n\n * 树中的所有值 互不相同\n * m == queries.length\n * 1 <= m <= min(n, 10^4)\n * 1 <= queries[i] <= n\n * queries[i] != root.val\n\n思路#\n\n首先树的总高度可以通过bfs或dfs得到，问题的关键点在于删除了某个节点后，树的高度是否受到影响。\n如果每删除一个节点都通过bfs或dfs判断一下，时间复杂度O(mn)≈10^9，必然超时。\n\n删除当前节点后，不受影响的是当前节点的兄弟节点。于是考虑能够通过兄弟节点获取高度，通过预处理的方式，\n可以获取到每个节点的兄弟节点（层级）和每个节点产生的树的高度。删除节点后，从遍历所有的兄弟节点，获取到的最大高度就是树的高度。\n特别考虑的是若删除节点没有兄弟节点，树的高度就是删除节点的父节点的层级。时间复杂度 $O(mlog_2n)$ 。\n\n> 此题错了一次，在删除的节点没有兄弟节点的时候，获取的高度应该是删除节点的level-1，手误写成了level。\n\n代码#\n\n","routePath":"/2022/11/02/solutions-to-xiaomi-programming-competition-2022/","lang":"","toc":[{"text":"第一场-第 90 场双周赛","id":"第一场-第-90-场双周赛","depth":2,"charIndex":46},{"text":"2451. 差值数组不同的字符串","id":"2451-差值数组不同的字符串","depth":3,"charIndex":63},{"text":"题目","id":"题目","depth":4,"charIndex":82},{"text":"思路","id":"思路","depth":4,"charIndex":585},{"text":"代码","id":"代码","depth":4,"charIndex":751},{"text":"2452. 距离字典两次编辑以内的单词","id":"2452-距离字典两次编辑以内的单词","depth":3,"charIndex":759},{"text":"题目","id":"题目-1","depth":4,"charIndex":781},{"text":"思路","id":"思路-1","depth":4,"charIndex":1226},{"text":"代码","id":"代码-1","depth":4,"charIndex":1289},{"text":"2453. 摧毁一系列目标","id":"2453-摧毁一系列目标","depth":3,"charIndex":1297},{"text":"题目","id":"题目-2","depth":4,"charIndex":1313},{"text":"思路","id":"思路-2","depth":4,"charIndex":1629},{"text":"代码","id":"代码-2","depth":4,"charIndex":1799},{"text":"2454. 下一个更大元素 IV","id":"2454-下一个更大元素-iv","depth":3,"charIndex":1807},{"text":"题目","id":"题目-3","depth":4,"charIndex":1826},{"text":"思路","id":"思路-3","depth":4,"charIndex":2240},{"text":"代码","id":"代码-3","depth":4,"charIndex":2413},{"text":"第二场-第 317 场周赛","id":"第二场-第-317-场周赛","depth":2,"charIndex":2421},{"text":"2455. 可被三整除的偶数的平均值","id":"2455-可被三整除的偶数的平均值","depth":3,"charIndex":2438},{"text":"题目","id":"题目-4","depth":4,"charIndex":2459},{"text":"思路","id":"思路-4","depth":4,"charIndex":2632},{"text":"代码","id":"代码-4","depth":4,"charIndex":2710},{"text":"2456. 最流行的视频创作者","id":"2456-最流行的视频创作者","depth":3,"charIndex":2718},{"text":"题目","id":"题目-5","depth":4,"charIndex":2736},{"text":"思路","id":"思路-5","depth":4,"charIndex":3310},{"text":"代码","id":"代码-5","depth":4,"charIndex":3339},{"text":"2457. 美丽整数的最小增量","id":"2457-美丽整数的最小增量","depth":3,"charIndex":3347},{"text":"题目","id":"题目-6","depth":4,"charIndex":3365},{"text":"思路","id":"思路-6","depth":4,"charIndex":3598},{"text":"代码","id":"代码-6","depth":4,"charIndex":3829},{"text":"2458. 移除子树后的二叉树高度","id":"2458-移除子树后的二叉树高度","depth":3,"charIndex":3837},{"text":"题目","id":"题目-7","depth":4,"charIndex":3857},{"text":"思路","id":"思路-7","depth":4,"charIndex":4375},{"text":"代码","id":"代码-7","depth":4,"charIndex":4709}],"domain":"","frontmatter":{"layout":"post","title":"2022小米编程大赛题解","date":"2022-11-02T00:00:00.000Z","categories":["读书笔记"],"tags":["LeetCode","Kotlin","Xiaomi","event"]},"version":""},{"id":23,"title":"node下基于MySQL实现分布式锁","content":"#\n\n业务里有一个清理数据库日志的功能，于是搞了个定时任务去删记录。为了不让多个机器的定时任务同时去删记录，就自然而然的想到了加锁。迫于现实技术栈限制，只能用“基本不\n用”的MySQL方式实现一个分布式锁。有条件最好的还是使用Redis吧。node框架使用了midwayjs和typeorm。\n\n\n分布式锁的概述#\n\n单机器环境下，得益于node的单线程事件模型，其实是不需要过度考虑共享资源的问题。\n\n当并发的去读写一个“共享资源”的时候，会出现两种情况：\n\n * 对结果没什么影响，但是会把某些操作多做几遍，为了效率需要控制一下。例如：清理过期数据、发送通知邮件等。\n * 对结果有很大的影响，造成数据不一致的情况发生，为了正确性需要控制一下。例如：发放奖励、处理订单数据等。\n\n\n分布式锁特点#\n\n分布式锁一般有如下的特点：\n\n * 互斥性： 同一时刻只能有一个线程持有锁\n * 可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁\n * 锁超时：和J.U.C中的锁一样支持锁超时，防止死锁\n * 高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效\n * 具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒\n\n\n分布式锁的实现方式#\n\n常见的实现分布式锁的方式有：基于Redis、基于数据库、基于zookeeper等。\n\n * Redis由于是单线程，会顺序处理收到的请求，通过竞争键值资源实现分布式锁。\n * 数据库通过事务和数据库锁竞争表级资源或行级资源，以此实现分布式锁。\n * ZK类似于一个文件系统，通过多系统竞争文件系统上的文件资源，起到分布式锁的作用。\n\n\nMySQL的分布式锁实现#\n\n\n基于唯一索引(insert)实现#\n\n在数据库中创建一张表，在表的字段上增加一个唯一索引。通过同时向数据库中插入唯一索引的数据，来进行获取锁的竞争过程。\n\n成功插入记录，表示获取锁。释放锁则将记录删除。\n\n\n基于表字段版本号实现#\n\n增加版本号字段。首先获取当前版本号，然后尝试进行版本号+1的更新操作。如果更新成功，表示获取锁。实际就是个CAS过程。没有释放锁的过程。\n\n\n基于排他锁(for update)实现#\n\n在select语句后面增加for\nupdate来给数据库增加排他锁，其它线程就无法在该记录上再增加排他锁，表示获取分布式锁成功。释放锁通过commit提交事务来实现。\n\n\nmidwayjs和typeorm代码#\n\n下面基于midwayjs和typeorm实现一个简易的分布式锁。\n\n\n数据库结构#\n\n在数据库新建一张表，用于记录锁信息。\n\n\n\n数据库实体类，用于操作数据库数据。\n\n\n\n\n数据库分布式锁实现#\n\n主要思路就是更新表对应的记录，通过更新操作影响的行数，判断是否成功获取锁。lockUntil字段表示锁持有的时间，在锁持有时间内其它线程无法更新当前字段。loc\nkedBy记录锁持有人，只有持有锁才能进行锁的续期和释放操作。释放锁就是将lockUntil字段设置为当前时间让锁过期即可。\n\n\n\n提供了几个方法：\n\n * lock() 获取锁，声明锁的持续时间，返回获取锁是否成功\n * unlock() 释放锁\n * extend() 锁续期，返回是否续期成功\n\n\n分布式锁的使用#\n\n\n\n\n参考内容#\n\n * https://github.com/pjmike/redis-distributed-lock\n * https://github.com/lukas-krecan/ShedLock\n * 微服务-分布式锁（一）-MySQL方案","routePath":"/2022/09/20/implement-distributed-lock-with-node-and-mysql/","lang":"","toc":[{"text":"分布式锁的概述","id":"分布式锁的概述","depth":2,"charIndex":148},{"text":"分布式锁特点","id":"分布式锁特点","depth":2,"charIndex":342},{"text":"分布式锁的实现方式","id":"分布式锁的实现方式","depth":2,"charIndex":525},{"text":"MySQL的分布式锁实现","id":"mysql的分布式锁实现","depth":2,"charIndex":705},{"text":"基于唯一索引(insert)实现","id":"基于唯一索引insert实现","depth":3,"charIndex":721},{"text":"基于表字段版本号实现","id":"基于表字段版本号实现","depth":3,"charIndex":825},{"text":"基于排他锁(for update)实现","id":"基于排他锁for-update实现","depth":3,"charIndex":909},{"text":"midwayjs和typeorm代码","id":"midwayjs和typeorm代码","depth":2,"charIndex":1017},{"text":"数据库结构","id":"数据库结构","depth":3,"charIndex":1073},{"text":"数据库分布式锁实现","id":"数据库分布式锁实现","depth":3,"charIndex":1125},{"text":"分布式锁的使用","id":"分布式锁的使用","depth":3,"charIndex":1370},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1383}],"domain":"","frontmatter":{"layout":"post","title":"node下基于MySQL实现分布式锁","date":"2022-09-20 00:00:00","categories":["技术"],"tags":["node","mysql","分布式锁"]},"version":""},{"id":24,"title":"深度广度优先搜索","content":"#\n\n> 所有的问题都能用搜索解决。——某人\n\n不要怂、就是干\n\n\n\n\n什么是“搜索”算法#\n\n搜索算法是利用计算机的高性能来有目的的穷举一个问题解空间的部分或所有的可能情况，从而求出问题的解的一种方法。\n\n常用的搜索算法有深度优先搜索和广度优先搜索。程序=算法+数据结构。要讨论算法，需要有特定数据结构的辅助。这里我们重点针对树和图这两种数据结构进行讨论。\n\n\n广度优先搜索（BFS）#\n\n广度优先搜索（Breadth-First-Search），直观的说就是按照层级一层一层进行搜索。\n这里有个简单的示意图，从1号节点开始，按照层级进行遍历，依次经过L1->L2->L3->L4的过程。\n\n\n\n由于BFS按照层级进行扩展，与起始节点层级近的会优先遍历到，所以一般用来解决最近、最小之类的问题。\n\n这里有个伪代码模板供大家参考。\n\n\n\n代码中有几个重要的辅助变量需要注意一下visited、queue。\n\n * visited 用于记录对应的节点是否已经被访问过，防止重复访问。如果节点v被访问过，那么就会有visited[v]=true。\n * queue 是一个队列，用来记录与已经访问过的节点相连但是还未访问的节点。\n\n\n时间复杂度#\n\n最坏情况下，终止顶点t离起始顶点s很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是O\n(V+E)，其中，V表示顶点的个数，E表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E肯定要大于等于V-1，所以，广度优先搜索的\n时间复杂度也可以简写为O(E)。\n\n\n题目 200. 岛屿数量#\n\n染色问题，BFS\n\n\n变体#\n\n根据使用场景的不同，可以对代码中的queue或节点扩展方式进行些许变化，产生不同的“变体”。\n\n按层级输出#\n\n针对树来说，需要按照层级进行遍历。目前queue里没有层级，可以给节点增加遍历层级的概念。\n\n\n\n或者参考之前介绍的方法，记录一下当前层级的数量，将当前层的数量遍历结束后再开始下一层。\n\n\n\n之前分享已经说过了，这里不多展开介绍了。\n\n记录路径#\n\n现在BFS只是记录了一个最终的结果值，如果需要记录抵达最终结果的一条路径，需要怎么做？\n\n这里可以使用一个前向指针，记录是从哪个节点扩展过来的（即父节点的下标）。用一棵树可以形象的表示这种关系。从终点一直回溯回起始节点就是要寻找的路径了。\n\n\n\n\n\n\n深度优先搜索（DFS）#\n\n深度优先搜索（Depth-First-Search），就是“走迷宫”，不撞南墙不回头的那种。\n\n\n\n深度优先搜索使用的是回溯思想。为了能够在遍历过程中“快速”快速回到上一个状态，深度优先搜索一般会使用递归来实现。\n\n\n\n深度优先搜索和广度优先搜索一样，也使用了变量记录遍历的一些状态，不同的是，有些变量可以写在函数参数上，方便快速回溯现场。\n\n * cur 一般用来表示当前遍历到的节点\n * visited 记录该路径上遍历过的节点，防止重复遍历已经经过的节点\n\n\n时间复杂度#\n\n深度优先遍历从图中可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是O(E)，E表示边的个数。\n但是深度优先搜索的时间复杂度就不同了，主要看遍历经过的节点顺序不同是否算是不同结果。例如生成三位数字的深搜，1-2-3和1-3-2就算是不同的结果。那么它的时间\n复杂度会是指数级的O(C^N)，C是每一层可能的情况，N是需要搜索的层数。\n\n\n题目 129. 求根节点到叶节点数字之和#\n\n树，深搜\n\n\n变体#\n\n记录路径#\n\nDFS与BFS不同的是，DFS不需要prev进行父节点，因为DFS连续的从起点遍历到终点，所以它到达终点时途中经过的节点，就是最终的路径了。\n\n797. 所有可能的路径\n\n剪枝#\n\n在深搜的过程中，如果发现在当前条件下，即使按照最优策略去寻找，也无法获取到比已得到的结果更优的结果时，就没必要继续向下搜索了。这时候可以直接退出当前搜索路径，转\n而从其它路径继续寻找其它可能的情况。这种勇于（合理）舍弃部分搜索情况，但是对最终正确结果不会造成影响的方式叫做剪枝。\n\n例如一个二叉树，所有的节点的值都大于0。现在寻找从根节点到叶子节点和的最小值。\n\n\n\n如果在遍历的过程中，已经发现当前的和超过了之前找到的一个结果，那么即使后面节点的值都为1，最终找到的结果一定大于当前的结果，于是就没比较继续向下搜索了。\n\n111. 二叉树的最小深度\n\n\n总结#\n\n广度优先搜索和深度优先搜索是最常用、最基本的搜索算法，相比其它搜索算法（A*、IDA*等）没有进行什么优化，所以这两种算法只能针对数据量不大的题目。\n\n> 广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径\n> 。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是O(E)，空\n> 间复杂度是O(V)。\n\n回到开头那句话。因为广度优先搜索和深度优先搜索会将所有可能的情况进行搜索，所以理论上所有的问题都能通过搜索解决。像是破解密码这种就特别适合用搜索解决，而且一定能\n破解出来，别管什么数据规模了，剩下的就交给时间吧。（做题之前一定要看好数据范围！）\n\n\n综合练习#\n\n * 827. 最大人工岛\n * 126. 单词接龙 II","routePath":"/2022/08/16/bfs-dfs-search-template/","lang":"","toc":[{"text":"什么是“搜索”算法","id":"什么是搜索算法","depth":2,"charIndex":35},{"text":"广度优先搜索（BFS）","id":"广度优先搜索bfs","depth":2,"charIndex":181},{"text":"时间复杂度","id":"时间复杂度","depth":3,"charIndex":514},{"text":"题目 200. 岛屿数量","id":"题目-200-岛屿数量","depth":3,"charIndex":703},{"text":"变体","id":"变体","depth":3,"charIndex":729},{"text":"按层级输出","id":"按层级输出","depth":4,"charIndex":782},{"text":"记录路径","id":"记录路径","depth":4,"charIndex":908},{"text":"深度优先搜索（DFS）","id":"深度优先搜索dfs","depth":2,"charIndex":1041},{"text":"时间复杂度","id":"时间复杂度-1","depth":3,"charIndex":1289},{"text":"题目 129. 求根节点到叶节点数字之和","id":"题目-129-求根节点到叶节点数字之和","depth":3,"charIndex":1491},{"text":"变体","id":"变体-1","depth":3,"charIndex":1521},{"text":"记录路径","id":"记录路径-1","depth":4,"charIndex":1526},{"text":"剪枝","id":"剪枝","depth":4,"charIndex":1619},{"text":"总结","id":"总结","depth":2,"charIndex":1902},{"text":"综合练习","id":"综合练习","depth":2,"charIndex":2284}],"domain":"","frontmatter":{"layout":"post","title":"深度广度优先搜索","date":"2022-08-16T00:00:00.000Z","categories":["算法"],"tags":["算法","搜索","深度优先搜索","广度优先搜索"]},"version":""},{"id":25,"title":"动态polyfill方案调研","content":"#\n\n\n什么是polyfill#\n\n简单来说，polyfill是为了抹平不同浏览器的api之间的差异。使我们在开发的过程中不需要过多关注浏览器版本之间的差异。\n\n\n\nhttps://caniuse.com/mdn-javascript_builtins_promise_allsettled\n\n一个语言需要不断发展，语言的不同阶段会产生差异。需要抹平不同浏览器的差异主要来自以下几个方面：\n\n 1. JavaScript语言层面的差异。JS也在不断发展，不同阶段提出了不同的API。为了在旧浏览器上能够使用新版的API，就需要进行polyfill。\n 2. 不同浏览器版本之间的差异。如IE和Chrome不同内核的差异，Chrome和Chrome不同版本的差异。DOM\n    API、HTML5等特性的实现不同，就需要进行polyfill。\n\n\n抹平不同浏览器的API差异#\n\n要使代码抹平不同浏览器的API差异、兼容低版本浏览器，主要从以下几方面入手：\n\n 1. 不同浏览器内核 => 判断+转换成统一方法。不同浏览器内核的API方法有些许不同，可以判断浏览器内核转化成统一的方法调用。\n\n\n\nhttps://caniuse.com/addeventlistener\n\n\n\n 2. 新语法、语法糖 => 转换成兼容代码。新语法无法直接在旧版浏览器中执行，只能对其进行等义转换。\n\n以运算符 ?? 为例：\n\n\n\nhttps://caniuse.com/mdn-javascript_operators_nullish_coalescing\n\n\n\nhttps://www.typescriptlang.org/play?#code/MYewdgzgLgBAhjAvDAjAKFJWAjJMBMG40MAHng\ngPyUzZA\n\n这类转换一般通过babel插件进行。\nbabel插件在打包的时候会根据package.json配置的环境范围对不兼容的语言进行转换。当然tsc也有对应的功能，它主要是读取tsconfig.json中\n配置的target确定需要转换语法的范围。\n\n 3. 新对象、新方法 =>\n    补丁代码进行补充。后续浏览器更新会增加新方法，或者增加新对象。可以通过添加补丁代码的方式进行兼容。这类做法就是我们常说的polyfill。\n\n以Promise.any为例\n\n\n\nhttps://caniuse.com/mdn-javascript_builtins_promise_any\n\n\n\nhttps://github.com/Financial-Times/polyfill-library/blob/master/polyfills/Promis\ne/any/polyfill.js\n\n\n使用polyfill#\n\n使用polyfill总的来说，有两种方式：手动和自动。\n\n\n手动polyfill#\n\n以Object#assign为例，这类常用函数在IE11等旧浏览器上也会报错，但是有些库已经进行了实现，我们就能够借助这些库进行手动polyfill。\n\n\n\n优势是能够保证最先依赖引入。缺点是不便维护和管理，无法适应多端和复杂的浏览器环境。\n\n\n自动polyfill#\n\n借助webpack的babel插件，可以实现根据代码自动polyfill。主要由以下插件和库可以实现该能力@babel/preset-env、\n@babel/plugin-transform-runtime、 core-js、@babel/polyfill。\n\n 1. @babel/preset-env - 按需编译和按需打补丁\n\n> @babel/preset-env is a smart preset that allows you to use the latest\n> JavaScript without needing to micromanage which syntax transforms (and\n> optionally, browser polyfills) are needed by your target environment(s). This\n> both makes your life easier and JavaScript bundles smaller!\n\n翻译过来就是 @babel/preset-env 会根据目标环境来进行编译和打补丁。具体来讲，是根据参数 targets 来确定目标环境，\n默认情况下它编译为ES2015，可以根据项目需求进行配置：\n\n\n\n具体 targets 参数可参见 browserlist。\n\n 2. core-js JavaScript 标准库\n\ncore-js 是实现 JavaScript 标准运行库之一，它提供了从ES3～ES7+ 以及还处在提案阶段的 JavaScript 的实现。\n\n 3. @babel/plugin-transform-runtime - 重利用 Babel helper 方法的babel插件\n\n> A plugin that enables the re-use of Babel's injected helper code to save on\n> codesize.\n\n@babel/plugin-transform-runtime 是对 Babel 编译过程中产生的 helper\n方法进行重新利用(聚合)，以达到减少打包体积的目的。 此外还有个作用是为了避免全局补丁污染，对打包过的 bundler 提供\"沙箱\"式的补丁。\n\n 4. @babel/polyfill - core-js 和 regenerator-runtime 补丁的实现库\n\n> Babel includes a polyfill that includes a custom regenerator runtime and\n> https://github.com/zloirock/core-js.\n> \n> This will emulate a full ES2015+ environment (no < Stage 4 proposals) and is\n> intended to be used in an application rather than a library/tool. (this\n> polyfill is automatically loaded when using babel-node)\n\n@babel/polyfill 通过定制 polyfill 和 regenerator，提供了一个ES2015+ 环境\npolyfill的库。因为它是由其他两个库实现的， 直接引入其他两个库即可，所以已被废弃。\n\n\n\n通过插件的方式，能够分析代码中使用的函数，根据浏览器覆盖率动态的生成polyfill进行加载，使得polyfill的体积和功能达到了一个平衡。\n\n\n动态polyfill#\n\n以上的polyfill方案，无法避免的问题就是冗余。如果用户的浏览器环境本身就支持，就无需加载某个/些polyfill方法。\n\nPolyfill.io 就是实现这个方案的服务，它会根据浏览器的UA不同，返回不一样的补丁。如想要 Promise 补丁，在页面引入：\n\n\n\n如在高版本的浏览器(Chrome 75)上，打开链接会返回空页面：\n\n\n\n如果将浏览器的UA改为IE 11，将会返回相应的 polyfill:\n\n\n\n还可以附加查询参数来定制Polyfill，具体可参照官方文档。\n\n此外，如果对 http://polyfill.io 的稳定性和安全性有要求，可以根据开源的 polyfill service 搭建自己的服务，然后部署到 CDN\n上。\n\n\n动态polyfill优化#\n\n动态polyfill听起来很美好，但是也存在一些问题。\n\n 1. 为了提供动态的特性，一个远端服务的支持。远端服务需要根据请求ua动态生成js文件。动态生成存在计算的过程，对服务的稳定性要求比较高。\n 2. 作为一个JS基础库，另一个考虑的因素就是访问和加载速度。免不了需要CDN的支持，但是ua的组合多种多样，使用CDN缓存会有庞大的成本问题。\n\n如果平台所处的环境相对固定，就可以对polyfill进一步优化。借助埋点提供的浏览器环境数据，按照webview版本将polyfill拆分成固定的几个版本，在不\n同的版本阶段加载不同的polyfill。\n\n\n基于线上版本分布的polyfill优化#\n\n从 sentry 上查看浏览器的版本分布\n\n\n\n可以看到出现频率最常见的两个版本是 66.0.3369 和 56.0.2924 ，这里准备了这两个环境的UA字符串：\n\n\n\n以将特性polyfill到es2015为例，https://polyfill.io/v3/polyfill.js?features=es2015\n，我们只需要准备三个版本的polyfill文件即可。\n\n\n\n高于66的只polyfill\nArray.prototype.sort函数，在56-66之间的使用Array.prototype.sort和Array.prototype.values，其余\n的引用全量的polyfill。\n\n相比全量和动态的polyfill，该方案能有效降低polyfill存储和传输的成本。\n\n\n基于固定版本的polyfill优化#\n\n我们的服务如果可以定制化或者自带webview控件，就可以将WebView的版本进行锁定到固定版本。由此进一步缩小浏览器之间的内核和版本差异，达到版本分布可控的\n状态。\n\n在版本可控的情况下，可以将当前WebView版本专有的polyfill文件缓存到系统本地，通过本地文件加载的方式进一步优化传输速度。\n\n\n总结#\n\npolyfill是为了解决浏览器版本差异而出现的一种补丁措施。随着对性能和体验要求的提升，动态polyfill剔除了没必要的补丁，\n使更多函数能够调用浏览器原生的函数实现。在变量中寻找不变量，对非必要变量进行剪枝，是动态polyfill优化的一个方向。","routePath":"/2022/08/12/research-on-dynamic-polyfill-solutions/","lang":"","toc":[{"text":"什么是polyfill","id":"什么是polyfill","depth":2,"charIndex":3},{"text":"抹平不同浏览器的API差异","id":"抹平不同浏览器的api差异","depth":2,"charIndex":373},{"text":"使用polyfill","id":"使用polyfill","depth":2,"charIndex":1154},{"text":"手动polyfill","id":"手动polyfill","depth":3,"charIndex":1197},{"text":"自动polyfill","id":"自动polyfill","depth":3,"charIndex":1333},{"text":"动态polyfill","id":"动态polyfill","depth":2,"charIndex":2896},{"text":"动态polyfill优化","id":"动态polyfill优化","depth":2,"charIndex":3238},{"text":"基于线上版本分布的polyfill优化","id":"基于线上版本分布的polyfill优化","depth":3,"charIndex":3532},{"text":"基于固定版本的polyfill优化","id":"基于固定版本的polyfill优化","depth":3,"charIndex":3901},{"text":"总结","id":"总结","depth":2,"charIndex":4076}],"domain":"","frontmatter":{"layout":"post","title":"动态polyfill方案调研","date":"2022-08-12T22:00:00.000Z","categories":["前端"],"tags":["polyfill","webview"]},"version":""},{"id":26,"title":"小米电视 6095 端口 HTTP API 整理","content":"#\n\n小米电视在 6095 端口有一个内置的服务，很神奇的导出了一些 API 接口。\n\n\n获取电视基础信息#\n\n\n\n\n获取电视安装的APP#\n\n\n\n\n启动APP#\n\n\n\n\n按键输入#\n\n\n\nkeycode 可以是以下值：\n\nKEYCODE      功能\npower        设备开关\nup           控制光标上\ndown         控制光标下\nleft         控制光标左\nright        控制光标右\nenter        确认键\nhome         返回桌面\nback         回退键\nmenu         打开菜单\nvolumeup     增加音量\nvolumedown   减小音量","routePath":"/2022/08/05/xiaomi-tv-6095-port-http-api/","lang":"","toc":[{"text":"获取电视基础信息","id":"获取电视基础信息","depth":2,"charIndex":44},{"text":"获取电视安装的APP","id":"获取电视安装的app","depth":2,"charIndex":58},{"text":"启动APP","id":"启动app","depth":2,"charIndex":74},{"text":"按键输入","id":"按键输入","depth":2,"charIndex":85}],"domain":"","frontmatter":{"layout":"post","title":"小米电视 6095 端口 HTTP API 整理","date":"2022-08-05T22:00:00.000Z","categories":["技术"],"tags":["小米电视","api"]},"version":""},{"id":27,"title":"小米CTF2022安全赛道writeup","content":"#\n\n> 参加了下CTF比赛，最终获得了第五名的成绩。奖品是个电烤箱，很喜欢的一个奖品因为冬天烤🍠真的好棒。\n> 做CTF基本上就是边学边做，这篇文章主要记录下过了的CTF题目，以及一些解题思路。\n\n\nre-1 maze#\n\n使用IDA pro反编译伪代码\n\n\n\n大概逻辑是，输入1234组成的20位字符串。根据题目描述——迷宫，可以将v5和v6理解为横坐标和纵坐标，1234表示下上右左。需要从左上走到右下。\n迷宫的地图在box中定义，1是不可通过，2是可以通过。\n\n\n\n转换成地图（手绘了一下，大概看一下）\n\n\n\n按照步骤行走，最终得到flag\n\n\n\n\nweb-1 签到题#\n\n签到题\n\n打开控制台找到注释里的flag\n\n\n\n\nweb-2 你会抓包吗#\n\n请求响应头里找到flag\n\n\n\n\nweb-3 爆破弱口令#\n\n6位密码很慢，花1积分买个hint，难度立即降低。\n\n爆破代码\n\n\n\n\nweb-4 手速要快#\n\n网页会自动跳转，使用postman请求，在源码中看到flag。控制台保留日志跳转也可以。\n\n\n\n\nweb-5 Actuator配置不当会发生什么呢#\n\n访问spring默认actuator地址，在env中找到flag。\n\nhttps://actuator-ctfd.dun.mi.com/actuator/env\n\n\n\n\nweb-6 接口文档在哪儿呢#\n\n猜测接口文档地址，spring比较常用的接口文档服务还是swagger，但是没有配置swagger-ui。\n\nhttps://api-doc-ctfd.dun.mi.com/v2/api-docs\n\n往下找有个flag-controller，post请求，需要一个boolean参数。\n\n\n\n构造请求，获取flag\n\n\n\n\nweb-7 破解uid#\n\n简单试了一下，uid范围大概是1-99，写个程序遍历一下，看看输出什么\n\n\n\n在uid=77的时候发现flag\n\n\n\n\nweb-8 听说你也了解HTTP#\n\n先根据提示一步一步的构造请求，到最后一步需要本地IP才能访问，通过header伪造本地IP。\n\n\n\n不知道哪个参数管用，一股脑全部设置成127.0.0.1吧\n\n\nweb-9 被清空的文件#\n\n下载.bash_history文件，从文件中找到flag\n\n\n\n\nweb-10 一个安全配置引发的血案#\n\n该题使用 Tomcat 远程代码执行漏洞分析（CVE-2017-12615）\n\n> CVE-2017-12615漏洞利用需要将 readonly 初始化参数由默认值设置为 false，经过实际测试，Tomcat\n> 7.x版本内web.xml配置文件内默认配置无readonly参数，需要手工添加，默认配置条件下不受此漏洞影响。 Apache\n> Tomcat默认开启PUT方法，org.apache.catalina.servlets.DefaultServlet的readonly默认为true，而且\n> 默认没有在conf/web.xml里写，需要手工添加并且改为false，才可以测试。\n> 主要在conf文件夹的web.xml文件中添加readonly参数并设置值为false：\n\n\n\n根据要求，构造PUT请求，上传一句话，然后蚁剑连接，从目录中找到flag\n\n\n\n\nweb-11 就一个上传操作能有啥问题#\n\n先上传一个图片简单的试了下，发现文件被放在upload目录下，并且页面可以访问到。而且文件名还是上传文件的文件名。文件类型只支持.jpg|.png|.gif，但\n是这个类型判断在前端页面判断。想办法绕过文件类型的判断，上传一句话，然后蚁剑连接，获取flag。\n\n构造一句话的php文件\n\n\n\n上传文件，页面下断点，把类型判断改掉\n\n\n\n\n\n蚁剑连接完毕。\n\n\nweb-12 只有本人才能查看哦#\n\n我也很了解HTTP\n\n\n\n\nweb-13 写个phpinfo能有多大风险#\n\n这个题目卡了好久，通过url判断考查的是php文件包含，构造filter抓取了index.php的文件，发现特别直白。\n\nhttps://include-ctfd.dun.mi.com/index.php?page=php://filter/read=convert.base64-\nencode/resource=index.php\n\n\n\n但是 php://input 协议没有，果然没有这么简单。\n\n说是有个phpinfo，找了一圈在info.php找到了。\n\n\n\n可以看到allow_url_include是off，怪不得php://input无效。\n\n百度找到一个smb加载远程文件的方法，但是只针对Windows环境，从phpinfo中看出这明显是一个linux环境。\n\n继续百度，找一个session上传进程漏洞利用。当session.upload_progress.enabled开启的时候会将上传文件的进度序列化保存到本地文件\n中， 这个文件的路径和文件名可以通过猜测获得。于是通过包含这个进度文件，能够实现执行自定义命令的效果。\n\n但是这个过程极快，需要一个脚本不停的尝试。\n\n\n\n开启两个线程，一个线程上传文件，另一个线程访问index.php获取包含的结果。\n\n经过不断的尝试和猜测路径，最终在/home/mywww/flag_is_here发现flag。\n\n\nweb-15 魔法的力量#\n\n该题利用了ImageMagick的CVE-2016-3714漏洞。\n\nImageMagick流行的原因之一，就是它功能强大，可以处理很多情况，而有一个功能delegate，作用是调用外部的lib来处理文件。调用外部lib就是执行s\nystem命令，从而产生命令执行漏洞。\n\n解析https图片的时候，使用了curl命令将其下载，payload只需使用反引号或闭合双引号，就可以执行任意命令。\n\n将一下内容保存为xxx.png，上传既可触发列目录。\n\n\n\n从文件名中可以找到flag。\n\n\nweb-16 你听说过Thinkphp吗#\n\n听说过\n\n网页看出thinkphp版本是thinkphp 5.0.23\n\n推荐一个网站查看thinkphp的漏洞 https://www.exploit-db.com/ ，在网站里搜索thinkphp，找到\n\nhttps://www.exploit-db.com/exploits/46150\n\n这里没有开启debug模式，我们选择thinkphp 5.0.23(完整版)提到的内容\n\n\n\n构造请求执行命令\n\n\n\n感谢无名氏提前放置的一句话，这里借花献佛，直接无耻的用蚁剑连接了。\n\n翻找目录找到flag。\n\n\nweb-17 简陋的留言板#\n\nxss\n\n基本上没有过滤任何内容，这里使用一个重定向将cookie补充在路径中转发过去。需要一个服务查看访问的路径。\n\n\n\n预留1s的时间，考验你点提交给管理员按钮的手速。\n\n管理员访问链接后可以看到cookie，将获取cookie写入浏览器，重新留言即可看到flag。\n\n\nweb-18 极简的Spring#\n\nCVE-2022-22965：Spring Framework远程代码执行漏洞\n\ngithub上找了一个exploit稍微修改了一下，修改成反弹shell\n\n\n\n不知道怎么搞得，把服务打挂了一次。。。好像有内存泄露。。。\n\n\nweb-19 为什么不能用默认配置呢#\n\nnacos权限绕过漏洞(CVE-2021-29441)\n\n在AuthFilter过滤器中存在如下条件语句：\n\nuseragent请求头如果以Constants.NACOS_SERVER_HEADER开头，则直接放通，执行后续的业务处理，而Constants.NACOS_\nSERVER_HEADER定义的正是\"Nacos-Server\"。\n\n\n\n有了user-agent: Nacos-Server之后，可以调用接口获取当前用户、添加用户。添加用户后，登录系统可以从系统的配置中获取flag。\n\n\nweb-20 记日志能有什么问题呢#\n\n猜测题目应该是把输入的用户名密码记录到日志中。\n\n想到了去年沸沸扬扬的 Apache Log4j远程代码执行漏洞（CVE-2021-44228）\n\nhttps://github.com/tangxiaofeng7/CVE-2021-44228-Apache-Log4j-Rce\n\nExploit执行反弹shell命令\n\n\n\n找一台服务器按照github说明开启jndi服务，用户名密码有一处填写\n\n\n\n反弹成功后，翻找目录找到flag。\n\n\nweb-22 破解Token认证#\n\n提示说找找其它端口，发现开启了9999端口，结合端口和分布式调度关键词，查找获取信息，可能是XXL-JOB调度的executor。\n\n访问地址，果然是这样。executor开启了token认证，但是弱口令猜测123456成功。\n\n基于以上，构造数据发送给executor执行shell命令，反弹shell。\n\n\n\n翻找目录获得flag。\n\n\nweb-23 简单小游戏#\n\n小游戏挺好玩\n\n\n\n翻找源码，发现在通过13关后，会从/flag.php文件获取flag，但是直接访问提示关键信息在/dog.png文件中。\n\n这里卡了好久，一直以为要分析狗的IDAT数据，或者是什么图片隐写之类的内容。\n\n后来发现，key就赤裸裸的写在dog.png文件里。\n\n\n\n访问 https://ezhack-ctfd.dun.mi.com/flag.php?key=627bb02a22 获取flag。\n\n\nweb-25 路径引发的惨案#\n\npython代码审计\n\n\n\n关键点在exec那句话，程序会将path放在exec命令中执行，我们就需要构造path，绕过waf对import、方括号、builtins和竖线的过滤。\n\n\n\n通过字符串连接将import隔开，通过访问远程路径的方式，将信息传输出去。\n\n这个题目可以在本地起服务，慢慢调试。\n\n\nembedded-1 躲猫猫#\n\n文件打开，在最后发现了flag信息，这两块的****的内容可以相互补充。\n\n\n\n\ncrypto-1 乱码中的奥妙#\n\n给了三个文件，加密文本、密码列表和一个加密解密算法。写个程序用密码列表中的密码依次解密加密文本，找到以fl开头的解密结果。\n\n\n\n\nmisc-1 图片中的秘密#\n\n不解释\n\n\n\n\nmisc-2 弱密码不可有！#\n\n根据描述构造爆破密码\n\n * 14位英文和数字\n * 00后，包含生日\n * 第一位做了修改（应该是小写改大写）\n * 最后一位加了1个符号\n\n只有这些信息破解起来有点麻烦，还需要合理猜测，比如开头是xiaomi，这样正好6英文+8数字=14位。\n\n剩下的就是破解生日和特殊符号了。\n\n\n\n找到了 Xiaomi20020604@\n\n用上面的密码解压完给出的flag.zip，找到一个word文件。\n\n\n\n看格式是一种叫ook的语言，有个在线解码器 https://www.splitbrain.org/services/ook\n\n但是文本解出来的只有flag的前半部分，后半部分去哪儿了？原来藏在的work文件最后，该个颜色就出来了。\n\n\n\n将两部分合并，得到完整的flag。\n\n\nandroid-1 抓token#\n\n用jd-gui反编译smali代码转成java伪代码，发现大概算法是每两个字符经过运算出一个hash，和目标数组里的hash值比较是否一致。\n\n将逻辑提取出来，用程序搜索一下：\n\n\n\n\nandroid-2 easy android#\n\nso文件反编译，扔到IDA pro里，F5转换成伪代码\n\n\n\n大概意思是，将key和seed运算生成一个数组，作为密钥。用输入的字符串和密钥进行AES/128/ECB/noPadding进行加密，加密生成的字符串与mask\nData比较，判断输入字符串是否正确。\n\nmaskData的值\n\n\n\n写个程序反向解密\n\n\n\n最后解密出来的值和flag{}拼接生成最后的flag（不像flag的flag）\n\n\n\n\nandroid-3 来抽奖吧#\n\n反编译后核心逻辑在于号码的计算成兑奖凭证的一段。将核心逻辑提取出来，计算一下。\n\nDataHolder.java\n\n\n\nb.java\n\n\n\nAwards.java\n\n\n\n\nandroid-4 click_the_button#\n\n反编译，发现这个题要点10000次按钮才会有结果，将核心逻辑提取出来，重复10000次，获取的字符串。\n\n\n\n但得到的不是最终的flag，而是一串字符串。\n\n\n\n先用十六进制解码，又得到一个字符串，还不是flag。\n\n\n\n使用网站， https://www.dcode.fr/cipher-identifier ，猜测一下是哪种加密方式，挨个尝试。最终发现是base64编码\n\nhttps://www.dcode.fr/base-64-encoding\n\n解码获得flag。","routePath":"/2022/06/24/mi-ctf-writeup/","lang":"","toc":[{"text":"re-1 maze","id":"re-1-maze","depth":2,"charIndex":101},{"text":"web-1 签到题","id":"web-1-签到题","depth":2,"charIndex":279},{"text":"web-2 你会抓包吗","id":"web-2-你会抓包吗","depth":2,"charIndex":316},{"text":"web-3 爆破弱口令","id":"web-3-爆破弱口令","depth":2,"charIndex":347},{"text":"web-4 手速要快","id":"web-4-手速要快","depth":2,"charIndex":397},{"text":"web-5 Actuator配置不当会发生什么呢","id":"web-5-actuator配置不当会发生什么呢","depth":2,"charIndex":459},{"text":"web-6 接口文档在哪儿呢","id":"web-6-接口文档在哪儿呢","depth":2,"charIndex":571},{"text":"web-7 破解uid","id":"web-7-破解uid","depth":2,"charIndex":750},{"text":"web-8 听说你也了解HTTP","id":"web-8-听说你也了解http","depth":2,"charIndex":824},{"text":"web-9 被清空的文件","id":"web-9-被清空的文件","depth":2,"charIndex":924},{"text":"web-10 一个安全配置引发的血案","id":"web-10-一个安全配置引发的血案","depth":2,"charIndex":972},{"text":"web-11 就一个上传操作能有啥问题","id":"web-11-就一个上传操作能有啥问题","depth":2,"charIndex":1382},{"text":"web-12 只有本人才能查看哦","id":"web-12-只有本人才能查看哦","depth":2,"charIndex":1584},{"text":"web-13 写个phpinfo能有多大风险","id":"web-13-写个phpinfo能有多大风险","depth":2,"charIndex":1617},{"text":"web-15 魔法的力量","id":"web-15-魔法的力量","depth":2,"charIndex":2234},{"text":"web-16 你听说过Thinkphp吗","id":"web-16-你听说过thinkphp吗","depth":2,"charIndex":2493},{"text":"web-17 简陋的留言板","id":"web-17-简陋的留言板","depth":2,"charIndex":2772},{"text":"web-18 极简的Spring","id":"web-18-极简的spring","depth":2,"charIndex":2926},{"text":"web-19 为什么不能用默认配置呢","id":"web-19-为什么不能用默认配置呢","depth":2,"charIndex":3058},{"text":"web-20 记日志能有什么问题呢","id":"web-20-记日志能有什么问题呢","depth":2,"charIndex":3328},{"text":"web-22 破解Token认证","id":"web-22-破解token认证","depth":2,"charIndex":3569},{"text":"web-23 简单小游戏","id":"web-23-简单小游戏","depth":2,"charIndex":3759},{"text":"web-25 路径引发的惨案","id":"web-25-路径引发的惨案","depth":2,"charIndex":3984},{"text":"embedded-1 躲猫猫","id":"embedded-1-躲猫猫","depth":2,"charIndex":4155},{"text":"crypto-1 乱码中的奥妙","id":"crypto-1-乱码中的奥妙","depth":2,"charIndex":4213},{"text":"misc-1 图片中的秘密","id":"misc-1-图片中的秘密","depth":2,"charIndex":4297},{"text":"misc-2 弱密码不可有！","id":"misc-2-弱密码不可有","depth":2,"charIndex":4321},{"text":"android-1 抓token","id":"android-1-抓token","depth":2,"charIndex":4679},{"text":"android-2 easy android","id":"android-2-easy-android","depth":2,"charIndex":4791},{"text":"android-3 来抽奖吧","id":"android-3-来抽奖吧","depth":2,"charIndex":5019},{"text":"android-4 click_the_button","id":"android-4-click_the_button","depth":2,"charIndex":5122}],"domain":"","frontmatter":{"layout":"post","title":"小米CTF2022安全赛道writeup","date":"2022-06-24T00:00:00.000Z","categories":["读书笔记"],"tags":["CTF","writeup","小米CTF"]},"version":""},{"id":28,"title":"响应式编程初探","content":"#\n\n\n什么是响应式编程#\n\n> In computing, reactive programming is an asynchronous programming paradigm\n> concerned with data streams and the propagation of change. This means that it\n> becomes possible to express static (e.g. arrays) or dynamic (e.g. event\n> emitters) data streams with ease via the employed programming language(s), and\n> that an inferred dependency within the associated execution model exists,\n> which facilitates the automatic propagation of the change involved with data\n> flow.\n> \n> -- Wikipedia\n\n翻译过来就是：\n\n> 在计算中，响应式编程是一种面向数据流和变化传播的异步编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，\n> 而相关的计算模型会自动将变化的值通过数据流进行传播。\n\n概念说了很多，简单来说响应式编程是使用异步数据流进行编程。\n\n以上对响应式编程的说明中，有几个概念这里先介绍一下：\n\n\n同步与异步#\n\n同步（Synchronous）：代码依次执行，并阻塞等待结果返回。这是一种线性执行方式，执行流程不能跨越。\n\n异步（Asynchronous）：发出调用指令，不必等待结果返回。在这个过程中可以继续执行下面的流程。\n\n\n\n响应式编程基于异步调用，这就要求所处的环境为异步环境。\n\n\n流/Stream#\n\n作为响应式编程的核心，流的本质是一个按时间顺序排列的进行中事件的序列集合。\n\n\n\n流可以发送三种不同的事物：\n\n * 值\n * 错误 Error\n * 完成信号 Completed\n\n响应式编程针对流，可以对其进行处理、转换和响应。\n\n\n迭代器模式#\n\n迭代器（Iterator）模式又叫游标（Sursor）模式，迭代器具有 next 方法，可以顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表现。\n\n在JavaScript中，可以使用Symbol.iterator遍历一个数组对象。\n\n\n\n如果把流想象成一个无限大的数组，那么处理它的过程，也是一个遍历的过程。\n\n\n观察者模式#\n\n观察者模式（Observer）又叫发布订阅模式（Publish/Subscribe），指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，\n所有依赖于它的对象都得到通知并被自动更新。\n\n响应式编程的计算模型传播很大程度上依赖观察者模式。\n\n\n【前端】响应式编程#\n\n由于响应式编程是一种编程范式，对于各种语言都有自己的实现。下面为了方便讲解，将重点以前端进行说明响应式编程。\n\n\n从Vue3说起响应式#\n\n先思考一个问题：\n\n有一个普通的赋值语句，C=A+B。当这个语句执行完成后，即使我们再改变B或C的值，A的值也就不会发生变化了。\n\n\n\n但是在Vue3响应式的环境下，这个结果就不同了。\n\n> https://twitter.com/antfu7/status/1346584312079032320\n\n\n\n\n响应式编程的要素#\n\n为了更好的介绍响应式编程，此处开始，我们以RxJS为例：\n\n> 为了应对高并发服务器端开发场景，在2009 年，微软提出了一个更优雅地实现异步编程的方式——Reactive Programming，\n> 我们称之为响应式编程。随后，各语言很快跟进，都拥有了属于自己的响应式编程实现。\n> \n> RxJS 是 Reactive Extensions for JavaScript 的缩写，起源于 Reactive\n> Extensions，是一个基于可观测数据流 Stream 结合观察者模式和迭代器模式的一种异步编程的应用库。RxJS 是 Reactive\n> Extensions 在 JavaScript 上的实现。\n\n * Observable（可观察对象）： 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\n * Observer（观察者）： 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\n * Subscription（订阅）： 表示 Observable 的执行，主要用于取消 Observable 的执行。\n * Operators（操作符）： 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap\n   等这样的操作符来处理集合。\n * Subject（主体）： 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\n * Schedulers（调度器）： 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或\n   requestAnimationFrame 或其他。\n\nObservable#\n\nObservables是在一段时间内发出数据的对象。\n\n\n\n使用new Observable()创建一个Observable，可以通过传入的subscriber参数来发出数据。\n\n\n\nSubscribe#\n\n要观测到Observable中的对象数据，需要订阅Observable。使用.subscribe()可以订阅。\n\n\n\nsubscribe中的各种回调与observable相对应。\n\nSubjects#\n\nSubjects是一种特殊类型Observable，使用new Subject()可以创建Subject对象。\n\n\n\n与Observable不同的是，Observable是单播的，而Subjects是多播的。\n\nOperators#\n\nOperators分为创建操作符和管道操作符。\n\n要从其它对象创建一个Observable，可以使用创建操作符。\n\n\n\n\n\nObservable是不可变的，通过使用管道操作符可以将输入的Observable转换成新的Observable。\n\n\n\n\n\n各种操作符的概念可以去rxjs的官方文档查看。这里列举几个常用的操作符：\n\n 1.  mergeMap\n 2.  switchMap\n 3.  exhaustMap\n 4.  map\n 5.  catchError\n 6.  startWith\n 7.  delay\n 8.  debounce\n 9.  throttle\n 10. interval\n 11. from\n 12. of\n\n\n响应式编程是使用异步数据流进行编程#\n\n已经说了这么多了，下面以一个具体的示例来进行一次完整的响应式编程。\n\n\n第一次响应式编程？#\n\n> 现在有一个div，在双击的时候放大，在三击的时候缩小。\n\n双击事件在PC浏览器上可以通过监听dbclick事件进行触发，但是由于移动端机制的限制是无法触发dbclick事件的。\n此处我们考虑监听click事件，通过模拟的方式判断双击和三击行为。\n\n * 双击：300ms内触发了正好两次click事件。\n * 三击：300ms内触发了多于两次click事件。\n\n这里可以先思考一下用原有的方式如何实现这个功能。\n\n传统方式#\n\n\n\n在这段代码中你需要同时处理事件、中间变量、还有计算时间间隔。幸运的是js是单线程的，你不需要考虑并发变量更新的问题。\n\n响应式编程方式#\n\n如果使用rxjs会怎么做？\n\n\n\n除了一些响应事件处理页面元素的代码，真正的核心逻辑只有四行。下面用一个图表示以上的处理流程：\n\n\n\n图中的线代表一个Steam流，圆圈是流中的事件，灰色方块是用来转换流的函数。\n\n * 首先我们将div的click事件处理成一个ClickStream流，然后通过throttle()将一段时间内的事件累积到一个列表中，形成一个新的列表事件流\n   。\n * 然后通过map()把每个事件（列表）的长度映射成一个新的流。\n * 最后，通过filter将整数1过滤掉。\n\n就这样，通过3个操作，就获得了一个包含点击次数的事件流。\n\n最后，通过订阅监听这个流，对对应的点击次数做出对应的反应，触发双击操作还是三击操作。\n\n\n响应式编程的优与劣#\n\n听了以上的说明，你是不是也想试一试传说中的响应式编程？但是先别着急，先听一下下面的说明再做决定。\n\n\n优势就在于专注业务，提高线程利用率#\n\n响应式编程提高了代码的抽象层级，你可以只关注定义了业务逻辑的那些相互依赖的事件，而非纠缠于大量的实现细节。响应式编程的代码往往会更加简明。\n\n响应式编程在前端和客户端上的优势是明显的，这类平台需要与众多的UI事件进行高度交互。为了提高用户体验，现代应用需要处理大量的实时事件。\n\n响应式编程在后端也有其优点：\n\n * 减少资源占用的情况下（主要是线程）提高cpu利用率。\n * 编排异步任务，传统后端异步任务的编排能力非常差，而响应式编程可以通过操作符对任务进行编排，也可以任意组合。\n * 拥抱延迟执行，在没有订阅的情况下什么都不会发生（后面会说明为什么），流只是占位不会有任何副作用，只有订阅才回执行。\n * 可以非常方便的使用操作是执行异步，而不是显示使用线程池（从命令式并发到声明式并发）。\n * 通过操作符可以非常方便的处理异常，重试。而不是使用try catch。\n\n\n响应式编程的劣势#\n\n陡峭的学习曲线#\n\n响应式编程是一种新的编程模式，免不了需要一些成本去转换思维模式。\n\n\n\n难以调试#\n\n报错堆栈丢失了关键信息，使得难以定位问题。\n\n\n还有什么？#\n\n\npush系统与pull系统#\n\npull和push，是在软件中消费数据的两种方式，它们描述了数据生产者（或持有者）与数据消费者之间是如何通讯的。\n\n在pull系统中，数据消费者决定自己何时请求并接收数据；数据持有者只能被动地响应请求。\n\n在push系统中，数据生产者决定何时向消费者推送数据。数据消费者不知道何时会收到数据更新。\n\n       生产者            消费者\npull   被动。收到请求时返回数据   主动。决定何时请求数据\npush   主动。决定何时推送数据    被动。响应数据的更新\n\n在pull系统下，下游没有消费者的时候，整个系统是不工作的。\n\n在push系统下，上游生产数据的能力超过了下游的消费能力，会产生背压。\n\n\n生态与扩展#\n\n响应式编程的生态非常丰富，各种语言都有自己的实现，而且都有非常丰富的操作符。\n\nrxjs官方库#\n\nReactiveX/rxjs: A reactive programming library for JavaScript (github.com)\n\nspring+rxjava=webflux#\n\nSpring WebFlux :: Spring Docs (getdocs.org)\n\nrxjs+redux=redux-observable#\n\n\n\n等等#\n\n等等\n\n\n破圈#\n\n从RxJS到Flink#\n\nFlink（Apache Flink）是由 Apache\n软件基金会开发的开源流处理框架，用于在无边界和有边界数据流上进行有状态的计算。它的数据流编程模型在有限和无限数据集上提供单次事件（event-at-a-time\n）处理能力。\n\n\n\nFlink通常用于开发以下三种应用：\n\n * 事件驱动型应用\n   \n   事件驱动型应用从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。场景包括基于规则的报警，异常检测，反欺诈等等。\n * 数据分析应用\n   \n   数据分析任务需要从原始数据中提取有价值的信息和指标。例如双十一成交额计算，网络质量监测等等\n * 数据管道(ETL)应用\n   \n   提取-转换-加载（ETL）是一种在存储系统之间进行数据转换和迁移的常用方法。ETL\n   作业通常会周期性地触发，将数据从事务型数据库拷贝到分析型数据库或数据仓库。\n\n抛开Flink各种复杂的概念不谈（事件乱序、数据背压、Checkpoint），一个典型的Flink处理过程可以被简化为：\n\n源数据流 --转换--> 中间数据流 --订阅--> 消费数据流\n\n这个模型无论在响应式编程还是实时数据处理都是通用的。\n\n\n总结#\n\n响应式编程不是一个全新的概念，它从现有的概念而来，而体现出来的思想模式又回到其它的思想领域中。\n响应式编程不是只在一种语言或一种系统中才能使用的框架，本质上来说，它能在任何事件驱动开发中使用的编程范式。 响应式编程不是生搬硬套，学会Thinking in\nRP，以响应式编程的角度去思考问题，才能找到最适合它的地方。","routePath":"/2022/02/20/startup-with-observable-programming/","lang":"","toc":[{"text":"什么是响应式编程","id":"什么是响应式编程","depth":2,"charIndex":3},{"text":"同步与异步","id":"同步与异步","depth":3,"charIndex":669},{"text":"流/Stream","id":"流stream","depth":3,"charIndex":817},{"text":"迭代器模式","id":"迭代器模式","depth":3,"charIndex":947},{"text":"观察者模式","id":"观察者模式","depth":3,"charIndex":1118},{"text":"【前端】响应式编程","id":"前端响应式编程","depth":2,"charIndex":1252},{"text":"从Vue3说起响应式","id":"从vue3说起响应式","depth":3,"charIndex":1321},{"text":"响应式编程的要素","id":"响应式编程的要素","depth":3,"charIndex":1488},{"text":"Observable","id":"observable","depth":4,"charIndex":2240},{"text":"Subscribe","id":"subscribe","depth":4,"charIndex":2345},{"text":"Subjects","id":"subjects","depth":4,"charIndex":2448},{"text":"Operators","id":"operators","depth":4,"charIndex":2565},{"text":"响应式编程是使用异步数据流进行编程","id":"响应式编程是使用异步数据流进行编程","depth":2,"charIndex":2898},{"text":"第一次响应式编程？","id":"第一次响应式编程","depth":3,"charIndex":2954},{"text":"传统方式","id":"传统方式","depth":4,"charIndex":3175},{"text":"响应式编程方式","id":"响应式编程方式","depth":4,"charIndex":3244},{"text":"响应式编程的优与劣","id":"响应式编程的优与劣","depth":2,"charIndex":3580},{"text":"优势就在于专注业务，提高线程利用率","id":"优势就在于专注业务提高线程利用率","depth":3,"charIndex":3643},{"text":"响应式编程的劣势","id":"响应式编程的劣势","depth":3,"charIndex":4054},{"text":"陡峭的学习曲线","id":"陡峭的学习曲线","depth":4,"charIndex":4065},{"text":"难以调试","id":"难以调试","depth":4,"charIndex":4111},{"text":"还有什么？","id":"还有什么","depth":2,"charIndex":4142},{"text":"push系统与pull系统","id":"push系统与pull系统","depth":3,"charIndex":4151},{"text":"生态与扩展","id":"生态与扩展","depth":3,"charIndex":4481},{"text":"rxjs官方库","id":"rxjs官方库","depth":4,"charIndex":4529},{"text":"spring+rxjava=webflux","id":"springrxjavawebflux","depth":4,"charIndex":4615},{"text":"rxjs+redux=redux-observable","id":"rxjsreduxredux-observable","depth":4,"charIndex":4684},{"text":"等等","id":"等等","depth":4,"charIndex":4716},{"text":"破圈","id":"破圈","depth":3,"charIndex":4726},{"text":"从RxJS到Flink","id":"从rxjs到flink","depth":4,"charIndex":4731},{"text":"总结","id":"总结","depth":2,"charIndex":5267}],"domain":"","frontmatter":{"layout":"post","title":"响应式编程初探","date":"2022-02-20T00:00:00.000Z","categories":["技术"],"tags":["响应式编程","前端","rxjs"]},"version":""},{"id":29,"title":"Android Compose 对比 React hooks","content":"#\n\n\n前言#\n\n自2008年Android 1.0出现之后，Android开发的基本模式类似于一种MVC的命令式开发模式。\n\n\n\n用XML编写界面，Activity中获取界面元素的引用，根据外部数据的状态来改变界面元素的属性。\n\n纵观前端的发展历程，以上开发模式显然存在着一些弊端。后面前端也从MVC模式逐渐演变出现在的MVVM模式。\n有句话说，MVVM模式是现在前端开发的终极模式。随着Java8函数式编程的引入，MVVM思想的流行和Kotlin对Android开发代码的简化和体验提升，\nGoogle也在探索Android开发的新模式。\n\nJetpack Compose是Google在2019 I/O大会上公布的声明式UI框架。一经推出Google就鼓励更多的开发者去了解与使用它，\n就在今年7月份，Compose发布了它的1.0版本，标志着推翻10年之久的UI开发模式的战役已经打响。\n\n\n\n纵观Compose的设计理念和使用方式，你会发现它与React Hooks非常像。如函数组件、纯函数、副作用、声明式渲染、组件状态这些概念在Compose\n与React Hooks都是保持一致的。本文通过介绍React Hooks的相关内容，来对Compose大体上做个了解。\n\n\nReact Hooks#\n\nHook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\n\n函数式组件#\n\n提到Hook不得不说的一个概念是函数式组件。React Hooks设计的初衷是为了 Hook 使你在无需修改组件结构的情况下复用状态逻辑 。\n组件可以复用，函数可以复用，但是组件内的逻辑如何复用没有一个合理的方式。\n\n一个函数，给定输入，就会有输出。函数式组件是，给定参数props输入，输出渲染组件的一个函数。如果一个函数，只要输入值相同，\n输出值也一定相同，那么这个函数被称为 纯函数 。给函数式组件props相同的属性，展示应该一直保持一定。这就是 幂等性 的概念。\n\n\n\n如果一个函数依赖了外部的数据（全局变量、接口等），那么就不能保证它是一个 纯函数 了。\n当状态改变时，函数也可能跳出自身作用域去修改外部的一些数据（修改变量、请求接口），这里把这些都称为“副作用”（Side Effect）。\n\nReact通过 useState 为函数式组件引入状态，使用 useEffect 来管理状态产生的副作用。\n\n\nuseState#\n\nuseState 用于在React函数式组件上添加内部state。\n\n\n\n * 第一行: 引入 React 中的 useState Hook。它让我们在函数组件中存储内部 state。\n * 第四行: 在 Example 组件内部，我们通过调用 useState Hook 声明了一个新的 state 变量。它返回一对值给到我们命名的变量上。\n   我们把变量命名为 count，因为它存储的是点击次数。我们通过传 0 作为 useState 唯一的参数来将其初始化为 0。\n   第二个返回的值本身就是一个函数。它让我们可以更新 count 的值，所以我们叫它 setCount。\n * 第九行: 当用户点击按钮后，我们传递一个新的值给 setCount。React 会重新渲染 Example 组件，并把最新的 count 传给它。\n\n\nuseEffect#\n\nuseEffect用于在函数组件中执行副作用操作。\n\n\n\n * 第七行： 引入useEffect，在count发生变化的时候，修改页面title的值。\n\n\nCompose#\n\n上面介绍了React Hooks的两个函数useState和useEffect，下面用Compose实现对应的功能。\n\n\n一个Activity页面#\n\n在Compose模式下，一个Activity页面如下\n\n\n\n * 第 5 - 12 行： 为Compose控制的内容\n * 第 16 行： 用 @Composable 注解的函数就是一个函数组件\n * 第 21 行： 用 @Preview 注解表示可以进行本地UI预览\n\n\n状态#\n\n\n\n * 第 3 行： mutableStateOf创建一个状态，remember缓存状态\n * 第 7 行： 在Button被点击后触发onClick函数，通过 setCount 对state执行加1操作\n\n\n副作用#\n\n\n\n * 第 7 - 8 行： 在count变化后执行副作用，弹出一个toast\n\n\n总结#\n\n通过上面的对比，Compose与React Hooks在函数式组件、状态管理和副作用函数方面还是很相似的，\n声明式UI和数据驱动的思想也能在Android开发上得到运用。学会了React Hooks很容易入手Jetpack Compose。\n大前端统一技术栈的进程又进了一步。","routePath":"/2021/12/23/start-up-android-componse-vs-react-hooks/","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"React Hooks","id":"react-hooks","depth":2,"charIndex":541},{"text":"函数式组件","id":"函数式组件","depth":3,"charIndex":626},{"text":"useState","id":"usestate","depth":3,"charIndex":1044},{"text":"useEffect","id":"useeffect","depth":3,"charIndex":1426},{"text":"Compose","id":"compose","depth":2,"charIndex":1516},{"text":"一个Activity页面","id":"一个activity页面","depth":3,"charIndex":1587},{"text":"状态","id":"状态","depth":3,"charIndex":1739},{"text":"副作用","id":"副作用","depth":3,"charIndex":1850},{"text":"总结","id":"总结","depth":2,"charIndex":1899}],"domain":"","frontmatter":{"layout":"post","title":"Android Compose 对比 React hooks","date":"2021-12-23T10:00:00.000Z","categories":["Android"],"tags":["Android","Compose","React","Hooks"]},"version":""},{"id":30,"title":"前端实现在线预览文件","content":"#\n\n最近的项目，对接阿里OSS做了一个在线物料管理功能。其中就需要在前端预览文件。调研实现了常用文件格式的展示。\n\n\n图片文件#\n\n浏览器原生支持展示各类图片文件，需要做的就是将图片展示在div中，并通过css为图片预览添加缩放、画布拖动等功能。\n\n这里使用了 react-zoom-pan-pinch 来支持图片的缩放、画布拖动功能。\n\n\n\n\n视频文件#\n\n跟图片文件同理，视频浏览器也有原生控件支持播放。借助组件 react-player 实现了对原生播放器的控制，支持播放、暂停等功能。\n\n\n\n\npdf文件#\n\npdf是一个比较“规整”的文件格式。有插件能很好的支持pdf格式的渲染和展示。\n\n大部分库都是基于 pdfjs 进行的封装，这里选用 react-pdf 进行pdf的渲染。\n\n\n\n\ndocx文件#\n\nOffice\n2007开始，微软对文件格式进行了“升级”，原有三剑客doc、xls、ppt文件后缀增加了x，即docx、xlsx、pptx。新文件格式使用zip格式封装了各种\nmeta数据。使得浏览器解析成为了可能。\n\nword文件基于 mammoth 库进行了封装。它做的是将docx文件转换成HTML进行展示，所以无法做到原汁原味的格式渲染。\n\n这里有个demo页面可以尝试一下转换效果。\n\n\n\n其它的x系文件，这里不再介绍（因为没有用到展示。\n\n\ndoc文件#\n\nOffice 2007之前的文件，结论是不支持。因为微软没有公开文件的编码格式，目前市面上的各类办公软件对doc文件的支持，都是自己解析的。\n\n这里有个trick可以临时支持这类文件的展示，就是使用iframe引入微软和谷歌官方的文件预览服务。\n\n\n\n将这两个地址中的url替换为远程的文件链接嵌入就能够看到了。\n\n\n\n\n\n需要“科学上网”。","routePath":"/2021/10/16/preview-document-file-in-webpage/","lang":"","toc":[{"text":"图片文件","id":"图片文件","depth":2,"charIndex":59},{"text":"视频文件","id":"视频文件","depth":2,"charIndex":173},{"text":"pdf文件","id":"pdf文件","depth":2,"charIndex":251},{"text":"docx文件","id":"docx文件","depth":2,"charIndex":350},{"text":"doc文件","id":"doc文件","depth":2,"charIndex":586}],"domain":"","frontmatter":{"layout":"post","title":"前端实现在线预览文件","date":"2021-10-16T15:28:02.000Z","categories":"果然还是前端","tags":["doc","docx","image","pdf","video","文件预览"]},"version":""},{"id":31,"title":"从《Nintendo Switch Sports》导出表情贴纸","content":"#\n\n最近一直奋战的Sports的保龄球里，虽说一直3局滚粗游戏体验不好吧，但是为了每周的装扮也是可以忍忍的。:smile:\n\n游戏里的贴纸可以说非常的可爱，为了“永久的”获得这些有些贴纸，就考虑能不能从游戏数据里获取到原始的贴纸图片文件。\n\n贴纸不是运行时从网络下载的，那就应该是封装在游戏数据里。只能解包游戏数据了。第一次解包ns的游戏数据，好多概念不太懂，不过好在工具比较“齐全”，操作起来还是比较\n容易的吧。。。\n\n\n准备工作#\n\n要解包游戏，需要准备一下工具软件：\n\n * Windows系统 —— 大部分工具都是windows系统的，在windows系统下操作比较方便。\n * 游戏ROM文件 —— 包括xci本体和nsp升级文件，可以网盘见。\n * hactool —— 解包ROM工具。GITHUB\n * prod.key —— 配合hactool使用的解包密钥，与系统版本有关系，旧的密钥无法解包新的游戏，注意游戏版本。密钥不宜传播，还是自行搜索。\n * NSCB —— 游戏包数据修改工具，功能很多，这里只用到nsz格式转nsp的功能。GITHUB\n * Switch Toolbox —— 用来浏览解包后的数据。GITHUB\n * WinHex —— 十六进制文本编辑工具。\n\n\n解包游戏本体xci#\n\n这里准备了《Nintendo Switch Sports》的本体文件 Sports [0100d2f00d5c0000][v0].xci 。\n\n 1. 解压 hactool，并把prod.keys和它放在同一目录下\n 2. 打开命令行，输入以下命令从本体中提取nca文件\n\n\n\n 3. 所有的文件被解压到nca文件夹中，如何找到主要的nca文件，就是看文件大小最大的那个\n 4. 接着执行以下命令，提取主要nac中的文件资源\n\n\n\n 5. ROM资源文件被提取到了romfs文件夹中，可以使用switch tool工具查看大部分的游戏文件。\n\n\n解包游戏升级版本nsp#\n\n本体文件中的内容可能不是最新的，没有包含你想要的那部分资源。比如本体中的Sports只有最初的四款贴纸。这时候就要将升级文件当做补丁与本体结合产生最新的游戏RO\nM。这里准备了v1.2.0的更新包 Nintendo Switch Sports [0100D2F00D5C0800][v131072].nsz 。\n\n如果更新包的格式是nsp，则可以跳过转换这一步，这里准备的是nsz，需要先转换成nsp文件。\n\n 1. 打开准备的NSCB工具，第一次使用要将准备的prod.keys更名为keys.txt放置在ztools目录下\n 2. 打开NSCB.bat会出现一个蓝色的界面，这里要解压，选择功能8\n 3. 将准备的nsz文件拖动到窗口里，回车添加到处理列表。之后选择1开始处理。\n 4. 稍等一段时间，等处理完成后在NSCB_output文件夹里就能找到处理后的文件。\n\n处理好解压文件后，继续合并解压ROM文件：\n\n 1. 打开命令行，输入以下命令，从升级文件中提取nca文件\n\n\n\n 2. 文件被解压到update_nca_1.2.0文件夹中。在开始解压资源资源，还需要一个titlekey的数据，这个数据在update_nca_1.2.0文\n    件夹中的一个tik后缀的文件中。用WinHex打开，从180位置处开始的32个字符就是titlekey。\n 3. 接下来就是将升级文件的nca与本体的nca合并，解压出最终的ROM资源。同理这里升级文件nca也是找最大的那个。\n\n\n\n这里的basenca参数就是之前解压的本体的nca路径。\n\n\n查看资源文件#\n\n将romfs_1.2.0文件夹加载到Toolbox中，就可以查看解压出的大部分文件了。我在Model文件夹找到了需要的贴纸文件。\n右键导出成png文件，就可以了。完美~\n\n\n参考内容#\n\n * 如何解包switch游戏（动森为例） - 知乎 (zhihu.com)\n * 【图片】【教程】XCI和NSP提取资源简单流程【符文工房吧】_百度贴吧 (baidu.com)\n * 【教程】Switch 如何使用NSCB 转换XCI NSP NSZ教程详解【1.01版本含13.01key秘钥】-游戏年轮 (bibgame.com)","routePath":"/2022/08/20/extract-emotestamp-from-nintendo-switch-sports/","lang":"","toc":[{"text":"准备工作","id":"准备工作","depth":2,"charIndex":212},{"text":"解包游戏本体xci","id":"解包游戏本体xci","depth":2,"charIndex":550},{"text":"解包游戏升级版本nsp","id":"解包游戏升级版本nsp","depth":2,"charIndex":835},{"text":"查看资源文件","id":"查看资源文件","depth":2,"charIndex":1527},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1623}],"domain":"","frontmatter":{"layout":"post","title":"从《Nintendo Switch Sports》导出表情贴纸","date":"2021-08-20T22:00:00.000Z","tags":["Switch","Nintendo","Sports","贴纸"],"categories":["游戏人生"]},"version":""},{"id":32,"title":"太鼓达人歌曲《タベテモタベテモ》","content":"#\n\n最近玩太鼓的时候，发现了一首比较好听的歌曲——《タベテモタベテモ》。无奈日语为零的我不知道去哪里才能找到歌词。在求助网抑云无果后，从某个打字网站上找到了对应的歌\n词。\n\n机器人代打视频\n\n然后就是歌词了，可惜没有中文翻译\n\n","routePath":"/2021/06/20/taiko-song-lyrics-タベテモタベテモ/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"太鼓达人歌曲《タベテモタベテモ》","date":"2021-06-20T17:53:01.000Z","categories":"游戏人生","tags":["太鼓达人","歌曲","歌词"]},"version":""},{"id":33,"title":"SSH终端工具MobaXterm介绍","content":"#\n\n说起终端工具大家一定不陌生，目前比较常见的终端工具有cmd、cmder、git-bash、powershell等。这些工具在执行命令上有各自的优势，\n有的还附带了cygwin模拟unix的执行环境。但是在SSH链接上表现都比较薄弱，只提供基础的ssh、scp指令，缺少会话管理的能力。\n\n说起SSH的会话管理，Windows系统下存在不少这类软件。如SecureCRT、XShell、WinSCP等。它们虽然功能强大，\n但还有另一个共同点就是——收费。\n\n今天的主角MobaXterm集各种优点于一身，虽然也有收费版，但是免费版功能强大。实在是居家开发、秃头 运维必备之工具。\n\n下面就以一些工作中的场景，来简单介绍一下MobaXterm的相关功能。\n\n\n下载#\n\nhttps://mobaxterm.mobatek.net/ 是MobaXterm的官方地址。\n\n\n\n根据功能分为家庭版和专业版，依据大家的购买能力，这里选择家庭版进行下载。\n\n\n创建SSH会话链接#\n\n点击右上角的Session①打开会话管理对话框。\n\n\n\n * 点击SSH②打开SSH配置\n\n * 在③输入要连接的远程服务器地址\n\n * ④打勾后，在⑤处输入用于连接的远程用户名\n\n * 如果通过密码进行连接，可以在⑥添加和管理密码\n\n * 如果通过pem私钥认证，可以在⑦指定认证用的私钥文件\n\n\n基本会话窗口#\n\n一个基本的SSH会话窗口如下：\n\n\n\n * 左侧有一个sftp文件管理器，可以在当前会话中上传下载文件。需要注意的是， 如果服务器经过了跳板机（多次ssh）登录，那么大概率sftp功能会失效。\n * 右侧就是普通的终端窗口，可以在里面使用服务器上的一些终端指令。\n\n\n文件传输功能#\n\nMobaXterm一个重要的功能是它对Z-modem协议支持比较好，如果恰好服务器也支持该协议，那么通过该协议可以方便的向当前终端内传输文件，\n这在多次ssh跳转环境下体验尤为好。\n\n\n\n在终端内打开上下文菜单（一般是右键或Ctrl+右键），选择 Send file using Z-modem 会弹出文件选择器，\n选择一个文件就能将文件上传到终端当前所在目录内。\n\n另外 Receive file using Z-modem 就是从终端下载一个文件，比如下载打包好的日志，可以尝试一下。\n\n\n其它#\n\nMobaXterm除了会话管理、SSH连接和文件传输功能外，还有其它功能：\n\n * VNC连接\n * 自带文本编辑器\n * cmd\n * 小游戏\n * 等等\n\n在使用过程中可以慢慢尝试。","routePath":"/2021/06/11/ssh-terminal-tools-mobaxterm/","lang":"","toc":[{"text":"下载","id":"下载","depth":2,"charIndex":330},{"text":"创建SSH会话链接","id":"创建ssh会话链接","depth":2,"charIndex":425},{"text":"基本会话窗口","id":"基本会话窗口","depth":2,"charIndex":587},{"text":"文件传输功能","id":"文件传输功能","depth":2,"charIndex":730},{"text":"其它","id":"其它","depth":2,"charIndex":986}],"domain":"","frontmatter":{"layout":"post","title":"SSH终端工具MobaXterm介绍","date":"2021-06-11T22:00:00.000Z","categories":["工具"],"tags":["SSH","MobaXterm"]},"version":""},{"id":34,"title":"一种通过svg-sprite-loader引入svg图标的方法","content":"#\n\nsvg-sprite-loader 可以将 svg icon文件整合到一起。利用 svg 的 symbol 元素，将每个 icon 包括在 symbol 中，\n通过 use 元素使用该 symbol 。配合 SvgIcon 组件，可以方便的添加和引用 svg 图标文件。\n\n\n安装并配置svg-sprite-loader#\n\n首先安装 svg-sprite-loader 插件，并在 webpack 构建文件中进行配置。\n\n引入 svg-sprite-loader 依赖\n\n\n\n在 webpack 中增加配置\n\n\n\n\n引入svg文件#\n\n为了让 webpack 处理 svg 文件，还需要在 js 中显式引入（import/require）文件。这里使用一种批量导入方式。\n\n 1. 新建存放 svg 图标的文件夹 ./src/icons\n 2. 在其中创建一个 index.js 文件\n\n\n\n 3. 将准备好的 svg 图标文件放在 ./src/icons/svg 目录下\n 4. 在入口文件处引入 ./src/icons/index.js 文件\n\n\n\n\n编写SvgIcon组件#\n\n还需要一个组件可以方便的引入打包好的 svg 图标。\n\n\nReact模式#\n\n在 ./src/components/SvgIcon/index.tsx 创建组件。\n\n\n\nPS：为了与 antd 的图标样式保持一致，这里使用了 anticon 类名。\n\n在相同目录下 ./src/components/SvgIcon/svg-icon.css 创建样式文件。\n\n\n\n\nVue模式#\n\n创建 ./src/components/SvgIcon.vue 组件文件。\n\n\n\n\n使用图标#\n\niconClass 属性是放置在 ./src/icons/svg 目录下文件的名称。\n\nclassName 属性是补充的样式类名。\n\n在 React 中使用\n\n\n\n在 Vue 中使用\n\n\n\n\n参考资料#\n\n * react复现vue中svg-sprite-loader的使用svg方法_桃饱の店-CSDN博客\n * vue-cli创建项目后优化更多配置（三）_桃饱の店-CSDN博客","routePath":"/2021/06/07/use-svg-sprite-loader-to-svg-icon/","lang":"","toc":[{"text":"安装并配置svg-sprite-loader","id":"安装并配置svg-sprite-loader","depth":2,"charIndex":140},{"text":"引入svg文件","id":"引入svg文件","depth":2,"charIndex":261},{"text":"编写SvgIcon组件","id":"编写svgicon组件","depth":2,"charIndex":481},{"text":"React模式","id":"react模式","depth":3,"charIndex":524},{"text":"Vue模式","id":"vue模式","depth":3,"charIndex":678},{"text":"使用图标","id":"使用图标","depth":2,"charIndex":728},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":831}],"domain":"","frontmatter":{"layout":"post","title":"一种通过svg-sprite-loader引入svg图标的方法","date":"2021-06-07T22:00:00.000Z","categories":["前端"],"tags":["webpack","svg"]},"version":""},{"id":35,"title":"基于WSL2搭建Win10开发环境","content":"#\n\n距离微软发布 Windows Subsystem for Linux (WSL) 有好一段时间了，也一直没想到什么场景下能够用到这个子系统。最近给新电脑\nWin10 系统搭建开发环境的时候，感觉好多开发软件不是特别顺手。猛然间想起了还有子系统，随即尝试了一下。作为开发环境没有什么问题的，下面把基本过程记录一下。\n\n> 适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 -\n> 且不会产生传统虚拟机或双启动设置开销。 什么是适用于 Linux 的 Windows 子系统 | Microsoft Docs\n\n使用WSL有以下一些优点：\n\n 1. 外壳系统还是 Windows，但是可以运行 Linux 的一些命令\n 2. 可以使用 Linux 的包管理，使用 Linux 的软件和调试环境\n 3. 开发环境可以借助 VSCode 和 Intellij IDEA 访问 WSL 中的代码\n\n\n安装WSL#\n\n官方提供了安装WSL的教程在 Windows 10 上安装 WSL | Microsoft Docs。重新总结一下安装步骤：\n\n 1. 更新 Win10 系统\n 2. 在Windows设置里搜索【启动或关闭Windows功能】\n\n\n\n 3. 找到其中的【适用于 Linux 的 Windows 子系统】选中，点【确定】，等待安装重启\n\n\n\n 1. 在Windows Store商店里安装Ubuntu发行版\n\n\n\n商店里也有CentOS的发行版，但是需要花钱。。。\n\n 1. 在终端（命令提示符 或 PowerShell）中输入bash就可以启动WSL了。之后就可以像是用 Linux 一样用这个系统了。\n\n\n更新到 WSL2#\n\n如果只是使用 WSL1 ，那么以上步骤就足够了。这里强烈建议更新到 WSL2 以获取更好的性能支持和更优秀的文件变更监控特性。\n\n关于一代和二代的区别，可以参考这篇文章比较 WSL 1 和 WSL 2 | Microsoft Docs\n\n\n\n> 在开始更新之前，先要保证系统版本满足需要的最低版本，建议更新一下系统。除了通过系统版本号判断是否能够安装 WSL2 外，还可以通过命令简单的判断。 输入：\n> wsl --help 根据命令反馈的帮助信息里有没有包含相应的选项（例如--set-default-version）来判断是否可以升级 WSL2。\n\n以下步骤按照文章 在 Windows 10 上安装 WSL | Microsoft Docs 进行操作。\n\n 1. 启动虚拟化功能，在Powershell的管理员模式（右键开始菜单按钮，选择【Windows PowerShell（管理员）】）下执行：\n\n\n\n 2. 下载 Linux 内核更新包进行安装，适用于 x64 计算机的 WSL2 Linux 内核更新包\n\n 3. 打开 PowerShell，输入以下命令将WSL默认版本切换到WSL2\n\n\n\n 4. 转换已经创建的 WSL 到 WSL2\n\n\n\n\n安装Windows Terminal（可选）#\n\nWindows发布了一个命令行终端，可以尝试一下。\n\nGitHub - microsoft/terminal: The new Windows Terminal and the original Windows\nconsole host, all in the same place!\n\n在 Github 的 release 页面或者 Windows 系统的 Microsoft Store 可以下载安装。\n\n\n\n\n配置Node开发环境#\n\n直接上教程，按照说明操作一遍即可在 WSL 2 上设置 NodeJS | Microsoft Docs。\n\nVSCode 需要安装 Remote - WSL 插件才能打开存储在 WSL 中的项目。IDEA 可以直接打开 WSL 中的项目。\n\n\n参考内容#\n\n * WSL：搭建前端环境\n * 搭建完美的Windows10开发环境","routePath":"/2021/05/31/web-development-on-win-10-with-wsl2/","lang":"","toc":[{"text":"安装WSL","id":"安装wsl","depth":2,"charIndex":443},{"text":"更新到 WSL2","id":"更新到-wsl2","depth":2,"charIndex":755},{"text":"安装Windows Terminal（可选）","id":"安装windows-terminal可选","depth":2,"charIndex":1297},{"text":"配置Node开发环境","id":"配置node开发环境","depth":2,"charIndex":1530},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1665}],"domain":"","frontmatter":{"layout":"post","title":"基于WSL2搭建Win10开发环境","date":"2021-05-31T23:47:24.000Z","categories":"高效生活","tags":["windows","wsl2","开发环境","前端"]},"version":""},{"id":36,"title":"在Github上玩贪吃蛇游戏吧","content":"#\n\n说好不想再挖坑的，结果还是没有控制住自己，结果又开了一个新坑，明明有那么多的坑已经填不完了。。。这次玩点不一样的内容，写一个贪吃蛇游戏吧。但是也不能仅仅是一个贪\n吃蛇游戏，还想在其中增加些不一样的内容。Kotlin跨平台开发出来好久了，这次就体验一下Kotlin2JS的能力。另一方面，只做一个贪吃蛇游戏没有什么意思，最近\n经常逛Github，看到贡献墙眼前一亮，为什么不在这里进行游戏呢？将自己的代码逻辑嵌入网站，还是做成一个扩展比较方便。于是就打算按照扩展的模式开发。\n\n本文的重点不在于贪吃蛇游戏逻辑的实现，在于感受Kotlin跨端开发的体验和最后扩展上线的流程。\n\n\n项目概览#\n\n贪吃蛇游戏的名称叫 gitsnackhub，其实简单来说就是在github的中间插入了snack的英文。\n\n图标也是仿照Github贡献墙的配色，在其中画出贪吃蛇的形状。\n\n\n\n最终游戏的呈现方式，代码已开源到Github，欢迎进行指导。\n\n\n\n\n创建跨平台项目#\n\n使用IntelliJ IDEA可以创建Kotlin/JS类型的项目。\n\n 1. 打开Intellij IDEA，新建一个新的项目。\n 2. 项目类型选择 Kotlin。\n 3. 输入项目名称后，选择 Browser Application 项目，点击下一步\n 4. 保持默认配置，选择完成项目。\n\n\n开发过程体验#\n\n项目创建完成后，会出现 build.gradle.kts 配置文件，其中包含 kotlin(\"js\") 的插件和其它依赖。\n\nKotlinJs相对于普通的JavaScript项目而言，其内部也是通过webpack进行的构建，但是各种配置都通过js插件整合到gradle配置中。\n\n\nnpm依赖与webpack配置#\n\n如果想增加npm依赖包，可以在Gradle中通过配置引入：\n\n\n\n不要忘记Kotlin是一个类型安全语言，要使用引入包中的函数，还要通过external的方式将函数声明导出。期望以后能够通过types文件直接导出函数声明。\n\n当然也可以在Gradle中配置一些webpack配置项，例如将输出项从默认的umd改为commonjs2：\n\n\n\n以上配置可以在Kotlin的教程中查看，https://kotlinlang.org/docs/js-project-setup.html#webpack-bu\nndling\n\nKotlinJS的构建过程是，先将kotlin代码转换成JavaScript代码，然后生成webpack配置，基于webpack构建和打包生成最后代码。\n\n\n类型安全#\n\n使用Kotlin开发JavaScript最大的感受就是类型安全，虽然类型安全能够在编译阶段发现问题，但是相对于JavaScript这种动态语言来说，就丧失了很多\n动态性。\n\n例如通过document.querySelector()可以获取到指定的元素，这个方法会类型为Element?的对象。要想获取对应的属性值，根据查询到的DOM类\n型，将这个Element父类强制转换成我们需要的对象类型。例如查询标签需要将其当做SVGRectElement类型进行处理。\n\n在JavaScript中，DOM对象作为一个普通的对象，可以以对象的方式在其中增加修改对象属性。但是在Kotlin中，一个对象中含有的属性是固定的，很难进行增加\n属性的操作。\n\n\n动态语言支持#\n\n为了支持JavaScript的动态语言的特性，Kotlin在语言层面也做了一些改变。\n\n增加dynamic类型，表示这个类型是一个动态类型。针对动态类型Kotlin编译器有一些特权操作，动态类型可以代表任何值，编译器会跳过类型检查，你可以用任意参数\n调用动态类型的任意方法（包括不存在的方法）。\n\n还可以在Kotlin中直接书写JavaScript代码，使用js()函数可以以字符串方式执行一段JavaScript代码，类似于eval()函数。该函数的返回值\n类型也是dynamic类型的。\n\n\n扩展的基本结构#\n\n扩展能够使用的表现模式有好多种：\n\n * 点击图标弹出一个浮窗\n * 右键菜单\n * 嵌入式脚本\n * devtools插件\n * 后台进程\n\n这些类型的具体功能可以查阅相关的资料。扩展需要引用的资源和使用的权限通过一个叫 manifest.json 的文件控制。\n\ngitsnackhub通过将脚本注入到github个人信息页的方式，实现操控页面的逻辑。这里就使用了扩展的嵌入式的方式。\n\n\n\ncontent_scripts 的作用是会将其指定的css和js文件，在 matches\n匹配后，插入到页面中。gitsnackhub只用到了js文件，并打算将其插入到github的域名中。\n\n\n上架扩展#\n\n为了让用户方便的下载到你的扩展，最好的方式就是上架到Chrome Web Store应用商店里。\n\n第一次上架需要消费5$激活开发者账号。打开https://chrome.google.com/webstore/devconsole，第一次会提示以下内容：\n\n这里的支付可以国内的visa信用卡，注意账单地址需要填写一个地图上真实的账单地址。\n\n注册完成后，新建一个新内容，上传打包好的扩展压缩zip包。第一次上架填写的内容比较多，需要注意以下项目的填写：\n\n * 扩展说明，需要详细说明扩展的使用方式，不要直接复制manifest.json中的摘要信息，会被驳回\n * 商店图标，注意尺寸\n * 截图，注意尺寸\n * 单一用途，描述扩展的单一用途\n * 请求权限，需要描述所有你扩展声明的权限，并说明必要原因\n\n截止目前，我的扩展还没有审核通过。审核频率大概1天1次。第一次因为扩展描述太随便而被驳回。重新修改提交审核即可。\n\n终于，扩展审核通过了，Gitsnackhub - Chrome 网上应用店。找了位勇士试用了一下，后面再慢慢把一些细节优化一下。\n\n\n参考内容#\n\n * sumy7/gitsnackhub - Github\n * Get started with Kotlin/JS for React\n * 【干货】Chrome插件(扩展)开发全攻略 - 我是小茗同学 - 博客园\n * Gitsnackhub - Chrome 网上应用店","routePath":"/2021/05/15/play-snake-game-on-github-contribute-graph/","lang":"","toc":[{"text":"项目概览","id":"项目概览","depth":2,"charIndex":290},{"text":"创建跨平台项目","id":"创建跨平台项目","depth":2,"charIndex":421},{"text":"开发过程体验","id":"开发过程体验","depth":2,"charIndex":581},{"text":"npm依赖与webpack配置","id":"npm依赖与webpack配置","depth":2,"charIndex":731},{"text":"类型安全","id":"类型安全","depth":3,"charIndex":1087},{"text":"动态语言支持","id":"动态语言支持","depth":3,"charIndex":1416},{"text":"扩展的基本结构","id":"扩展的基本结构","depth":2,"charIndex":1673},{"text":"上架扩展","id":"上架扩展","depth":2,"charIndex":1979},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2468}],"domain":"","frontmatter":{"layout":"post","title":"在Github上玩贪吃蛇游戏吧","date":"2021-05-15T13:16:38.000Z","categories":"游戏人生","tags":["kolin","kotlin-js","github","snake","game","chrome-extension"]},"version":""},{"id":37,"title":"VueRouter4路由权重","content":"#\n\nVue3正式版发布也有一段时间了，各个相关组件也趋于稳定。前些天听了VueRouter4的一个分享会，了解到了新版的设计理念和一些主要的改动，其中一个改动就是舍\n弃了原来的路由顺序匹配，改为计算权重的方式。趁着这个上午，把其中的部分逻辑研究一下。\n\n\n路由权重#\n\n路由权重也不是一个新的概念，在nginx里就有类似的实现。nginx将路径匹配分为：精确匹配、普通字符匹配、正则匹配。location的书写顺序只会影响同类的匹\n配，nginx会按照一个特定的分类顺序进行匹配。总的来说nginx匹配的目标是精确、规则优先，最后才会考虑采用最长前缀匹配的方式。\n\n除了nginx里有隐性权重（按照大类+顺序）这个概念外，CSS选择器的选择也有这种思想。此处不再过多描述。\n\n这次vuerouter4舍弃了顺序匹配的方式，采用了计算路径权重（Path\nRanking）的方式。相对于nginx的这种约定式的权重，vuerouter4采用了更加明确的量化路由权重。在多个路由满足匹配规则的情况下，优先选择权重高的路\n由。\n\n\n转换路径#\n\nvuerouter4还是采用将路由转换成正则方式进行匹配，但是为了方便记录路由权重，没有再采用以前path-to-regexp库进行直接转换。\n\n在源码pathTokenizer.ts文件中，vuerouter4通过语法分析的方式，将路由定义拆分成静态路径(Static)、命名路径(Param)、带正则的\n命名路径(ParamRegExp)、可重复带正则的命名路径(ParamRegExpEnd)这四类路径，然后将每个路径都会是一个Token。\n\n举例来说，/about这种是静态路径，/:userId这种是命名路径，/:orderId(\\\\d+)这种在命名后面包含一个正则表达式的是带正则的命名路径，最后/\n:chapters+这种在最后存在存在重复记号的是可重复带正则的命名路径。\n\n下面是命名路径的TokenParam定义，其余的也将类似。\n\n\n\n将路径的每段解析成Token之后，会在计算路由权重得分时转换成正则表达式。这里简单介绍一下各类路径的正则转换规则。\n\n 1. 静态路径直接使用原先的路径值，注意也需要转义其中的一些特殊字符。\n 2. 命名路径会使用([^/]+)（至少有一个字符不是斜杠 / ）正则来匹配路径。\n 3. 带有正则表达式的，会尝试用路径中书写的正则表达式，即TokenParam中的regexp所定义的内容。\n 4. 可重复的会使用((?:${re})(?:/(?:${re}))*)（至少匹配一次路径表达式）来重新拼装正则表达式。\n 5. 可选的会在最后拼接?（0个或1个）选项。\n\n\n计算权重#\n\n转换正则表达式和计算得分的逻辑在pathParserRanker.ts文件中。首先看一下vuerouter4对得分的定义。\n\n\n\n分数计算的基础倍数是10倍，每条路由计算先按照路径分隔符拆分分别计算，最后形成一个分数列表。\n\n * 每一段默认会得到Segment的40分\n * 静态路径会额外得到Static的+40分，如/about默认是40+40=80分\n * 命名路径会额外得到Dynamic的+20分，如/:userId是40+20=80分\n * 只有一个/的路径只能得到Root的90分\n * 命名路径中带有表达式，会额外获得BonusCustomRegExp的+10分，如/:orderId(\\\\d+)是40+20+10=70分\n * 如果路径正则表达式是.*（匹配所有字符），还会扣除动态路径和正则表达式的分数BonusWildcard的-50分，如/:orderId(.*)是40+20\n   +10-50=20分\n * 如果路径是重复或可选的，会对应扣除BonusRepeatable的-20分和BonusOptional的-8分，如/:chapters+是40+20-20\n   =40分\n * 如果对路径设置了绝对匹配和不忽略大小写选项，会增加BonusStrict的0.7分（只针对最后一段路径有效）和BonusCaseSensitive的0.2\n   5分（对所有路径有效）\n\n\n路由匹配#\n\n在路由匹配之前，需要先对路由进行加权排序。前面提到对每段路径计算得分后，会得到一个分数列表，例如：\n\n\n\n\n\n排序的时候会按照每段分别比较，相同位置得分比较大的靠前，所有得分都一致的情况下才考虑路由的定义顺序。\n\n按照权重排好序后，在排序好的列表里就可以按照顺序来匹配路径和结果了。\n\n\n总结#\n\n通过计算路由权重匹配的方式，可以让描述越精确的路由能够越先匹配到。相比上版本使用的顺序匹配，能够大大降低人为顺序对匹配结果的影响，减少出错几率。而且对动态路由来\n说，计算路径权重的方式也能使新增加的路由按照一致的逻辑处理，而不用考虑插入的顺序问题。\n\n以上vuerouter4路由解析的结果，可以通过Vue Router Path Parser进行查看，可以看到各个路径计算的得分，也支持将你的路由分享给其他人。\n\n\n参考内容#\n\n * Understanding Nginx Server and Location Block Selection Algorithms |\n   DigitalOcean\n * Reach Router - Path Ranking\n * Vue Router Path Parser","routePath":"/2021/05/11/vue-router-4-path-ranking/","lang":"","toc":[{"text":"路由权重","id":"路由权重","depth":2,"charIndex":128},{"text":"转换路径","id":"转换路径","depth":2,"charIndex":462},{"text":"计算权重","id":"计算权重","depth":2,"charIndex":1131},{"text":"路由匹配","id":"路由匹配","depth":2,"charIndex":1741},{"text":"总结","id":"总结","depth":2,"charIndex":1892},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2106}],"domain":"","frontmatter":{"layout":"post","title":"VueRouter4路由权重","date":"2021-05-11T10:14:45.000Z","categories":"果然还是前端","tags":["vuerouter","路由"]},"version":""},{"id":38,"title":"再次从零开始捣鼓一个Electron应用——菜单和再次发布","content":"#\n\n时隔一段时间，其实每天还是在断断续续的“水”Electron的功能，本次在菜单和构建问题上又进了一步。i18n功能需要一个切换语言的位置，由于没有设置专门的设置\n窗口，就把切换语言放置在菜单栏中。Electron默认已经有一部分菜单了，这次就需要在菜单上加上语言列表。另一项任务是发布，每次手动发布也好麻烦（其实也就手动发\n布了一次而已），这次看看能不能利用Github Actions功能将构建和发布自动化。\n\n\n菜单#\n\nElectron的菜单通过一个(MenuItemConstructorOptions |\nMenuItem)[]类型数组进行声明，然后在窗口的ready事件后才能执行修改菜单的命令。\n\n修改菜单先是要将菜单模板构建成菜单对象，然后再应用到ApplcationMenu上。\n\n\n\n以一个简单菜单来说，一个独立的菜单包含label、accelerator、role这三项。label是菜单展示；accelerator是菜单快捷键；role是菜\n单角色，有些内置的菜单角色可以触发系统的默认行为，比如undo就会触发撤销行为等。将type设置为separator会绘制一个菜单分隔条。如果默认角色没有符合要\n求的也可以使用click属性向菜单绑定点击事件。\n\n下面是菜单的一个简单用法：\n\n\n\n使用了自定义菜单之后，会丢失默认菜单的配置，如果还想保留默认菜单，建议将默认菜单项重新拷贝一遍，与新菜单合并放置在一起。可以使用https://github.c\nom/carter-thaxton/electron-default-menu/blob/master/index.js提供的模板稍加修改。\n\n\n发布#\n\n上篇文章之后，就一直在捣鼓怎么进行更有效的发布操作，初步想法是用Github Actions在push\ntags操作后，触发构建然后推送将成品推送到release中，以此来替代手动构建上传的操作。\n\n后来发现，原来electron-builder存在构建后自动上传github的方式，而使用的vue-cli-plugin-electron-builder引用了\nelectron-builder，自然也存在这项功能。\n\n要想在本地使用，首先需要申请Github Token。打开Personal Access Tokens，选择“Generate new\ntoken”，然后将repo下的所有权限选中，生成一个新的token。\n\n\n\n这样就会在本地构建mac、windows、linux的成品，并上传Github对应仓库的releases里。\n\n除了在本地操作，还可以将这个步骤整理成一个Github\nActions，在push的时候自动进行。新建.github/workflows/build.yml文件，并输入以下内容。\n\n.github/workflows/build.yml\n\n\n\n步骤就是用macos、ubuntu和windows这三个操作系统，分别去构建成品。如果存在GH_TOKEN环境变量，会自动触发上传操作。当然这个GH_TOKEN\n也不需要配置和填写，执行的时候Github会自动生成token并进行替换。\n\n这个Actions构建依赖几个命令，可以提前放在package.json里：\n\n\n\n然后将文件push到仓库里，就自动创建Github\nActions了。以后有push操作的时候，都会自动构建。还会根据当前最新的tag创建版本号，但是这样自动创建的releases是一个草稿状态，还需要手动编辑然\n后进行发布操作。\n\n\n参考内容#\n\n * Multi Platform Build - electron-builder","routePath":"/2021/05/09/restart-from-the-very-beginning-for-electron-with-menu-and-release-2/","lang":"","toc":[{"text":"菜单","id":"菜单","depth":2,"charIndex":210},{"text":"发布","id":"发布","depth":2,"charIndex":713},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1493}],"domain":"","frontmatter":{"layout":"post","title":"再次从零开始捣鼓一个Electron应用——菜单和再次发布","date":"2021-05-09T18:35:17.000Z","categories":"体验Electron","tags":["electron","release","github-actions"]},"version":""},{"id":39,"title":"美化你的Github个人信息页","content":"#\n\n闲逛Github的时候，会发现有的Profile页面出现了一个README的头部，里面可以使用markdown自定义一些信息进行展示。查询了一下发现是Githu\nb新出现的一个秘密功能模块。不由分说，赶紧弄起来。\n\n\n新建个人仓库#\n\n要展示这个特殊的模块，就需要新建一个”特殊“的仓库。这个仓库名称与你的Github用户名相同。如果你以Github用户名新建仓库，就会提示一段话：\n\n\n\n> You found a secret! sumy7/sumy7 is a ✨special ✨ repository that you can use to\n> add a README.md to your GitHub profile. Make sure it’s public and initialize\n> it with a README to get started.\n\n记得创建仓库的时候初始化一个README.md文件。\n\n\n编辑README.md文件#\n\n打开README.md文件，就会发现Github已经创建好了一段信息，给你补充的灵感。当然，也可以按照自己的想法进行修改。\n\n\n\n编辑好文件打开个人首页就可以看到效果了。\n\n\n展示控件#\n\n下面介绍几个不错的展示组件和灵感来源。\n\n\n动态GitHub Readme Stats#\n\nanuraghazra/github-readme-stats提供了一个展示Github动态的方式，支持展示Github基本信息、编码语言分布、仓库信息。最常用\n的还是Github基本信息和仓库信息。\n\n\n\n引用也是非常简单，按照仓库的说明文档，将其中的用户名替换成自己的用户名即可。比如我的就是：\n\n\n\n\nAwesome READMEs#\n\n如果没有灵感，可以参考一下其他人的Github个人信息页。这里有个仓库收集了一些人的Github信息页，可以翻翻参考一下。\n\nhttps://github.com/kautukkundan/Awesome-Profile-README-templates\n\n\n访问计数#\n\n可以添加访问计数的徽章，这类服务不少，也可以自己搭建一个。这里列举一些只需要将其中的用户名替换成自己的用户名。\n\n\n\n\n图标徽章#\n\n很多仓库都有这类图标徽章 ，https://shields.io/提供了好多预制的徽章信息可供选择。\n\n除了预制的徽章，shields也能自定义徽章样式。先从https://simpleicons.org/选择一个图标，shields支持直接使用simpleico\nns的图标。然后按照对应部分修改或替换到以下地址中，具体参数还是继续查看官网说明吧。\n\n\n\n\n模板#\n\n各种布局、配件、模板真是挑花了了眼，尤其是其中技能图标，一个一个找好麻烦。幸好这里有一个Github\nprofilinator模板生成器，一部分一部分的选择，可以快速生成需要的首页信息。\n\n生成的README.md文件不只是局限于使用他的模板，更重要的是将其中的元素提取出来，复用其中的元素。比如技能图标 等。\n\n\n我的成果#\n\n最后我的首页就是这样子了，欢迎前来参观。\n\nhttps://github.com/sumy7/\n\n\n参考内容#\n\n * Github个人首页美化指北","routePath":"/2021/04/25/beautify-your-github-profile-readme/","lang":"","toc":[{"text":"新建个人仓库","id":"新建个人仓库","depth":2,"charIndex":111},{"text":"编辑README.md文件","id":"编辑readmemd文件","depth":2,"charIndex":422},{"text":"展示控件","id":"展示控件","depth":2,"charIndex":526},{"text":"动态GitHub Readme Stats","id":"动态github-readme-stats","depth":3,"charIndex":555},{"text":"Awesome READMEs","id":"awesome-readmes","depth":3,"charIndex":733},{"text":"访问计数","id":"访问计数","depth":3,"charIndex":881},{"text":"图标徽章","id":"图标徽章","depth":3,"charIndex":948},{"text":"模板","id":"模板","depth":3,"charIndex":1135},{"text":"我的成果","id":"我的成果","depth":2,"charIndex":1298},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1355}],"domain":"","frontmatter":{"layout":"post","title":"美化你的Github个人信息页","date":"2021-04-25T22:42:01.000Z","categories":"高效生活","tags":["github","markdown","profile","readme"]},"version":""},{"id":40,"title":"再次从零开始捣鼓一个Electron应用——监控、构建与发布","content":"#\n\n在连续捣鼓了这个应用好几天后，感觉大部分功能实现的差不多了，就打算发布一版看一下。这次打算将成品包直接放到github上，github提供了release功能。\n本次发布过程还只是手动的，后续考虑如何自动的构建成品并进行发布操作。不知道Github Action支不支持这个功能。\n\n\n应用监控#\n\n发布之后如何快速获取到应用崩溃的信息？这个时候就需要一个监控来帮忙了。Sentry\n是一个开源的实时错误追踪系统，提供了多种语言的错误上报接入和在线的错误分析平台，还有官方试用或者自建上报服务端的功能。\n\n接入sentry也是非常简单，首先访问 https://sentry.io/ 注册并登陆，创建或使用默认的组织。\n\n在项目中增加sentry客户端的依赖\n\n\n\n在 background.ts 和 main.ts 开始的位置增加启动监控的代码：\n\n\n\n需要注意的是不同项目的dsn是不同的，在官网的引导中会明确指出需要填写的dsn。而且官网的文档也有更详细的说明。\n\n\n构建#\n\n执行项目默认的构建命令，就可以在 dist_electron 中生成对应操作系统的成品包：\n\n\n\n需要注意的是，在某个平台构建，只能生成对应平台的安装和运行包。比如在Windows平台下会生成.exe文件，在Mac平台下会生成.dmg镜像文件。如果要生成全部\n的三个平台就需要找齐对应平台的系统进行构建。\n\n\n发布#\n\n在github仓库页面，可以新增Releases。\n\n\n\n需要填写的内容：\n\n * 选择需要发布的分支，版本号。填写的版本号会自动创建Tag。\n * 填写发布标题。\n * 填写发布说明。\n * 上传构建的成品包。\n\n保存后就成功发布了一个版本了。\n\n\n参考内容#\n\n * Electron | Sentry Documentation","routePath":"/2021/04/24/restart-from-the-very-beginning-for-electron-with-monitor-build-and-publish/","lang":"","toc":[{"text":"应用监控","id":"应用监控","depth":2,"charIndex":145},{"text":"构建","id":"构建","depth":2,"charIndex":439},{"text":"发布","id":"发布","depth":2,"charIndex":599},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":730}],"domain":"","frontmatter":{"layout":"post","title":"再次从零开始捣鼓一个Electron应用——监控、构建与发布","date":"2021-04-24T16:11:17.000Z","categories":"体验Electron","tags":["electron","sentry","build","git-release"]},"version":""},{"id":41,"title":"再次从零开始捣鼓一个Electron应用——项目配置","content":"#\n\n上一篇介绍如何从新搭建了一个项目，本篇重点说明一下在开发过程中遇到的一些问题，以及如何解决。鲁迅曾说过，世界上没有两个相同的程序。本系列也不会介绍代码如何编写，\n只是将开发过程中遇到的重点的问题记录一下，避免以后出现相同的问题。\n\n\nVue Devtools 无法使用（未解决）#\n\n安装DevTools的代码在 background.ts 文件中，installExtension()\n方法会尝试从应用商店下载插件。但是由于已知原因，经常无法下载，导致无法正常安装调试插件。\n\n\n\n尝试过将插件解压到本地进行加载的方式，也无法使用。最终只有将上述代码注释掉。\n\n\n进程通信#\n\n在electron中分为 渲染进程 和 主进程\n。渲染进程负责展示界面，有着跟浏览器一样的沙盒系统，无法直接接触原生资源。主进程负责操作原生数据，启动渲染进程展示界面。这两个进程之间通常需要传输数据。\n\n一般方法可以在渲染进程中使用require('electron').remote获取到主进程对象，从而直接操作方法同步获取数据。但是这种方法有安全问题，现在已经\n默认关闭不推荐使用，打开需要在background.ts文件中创建Window的时候指定参数打开：\n\n\n\n现在比较推荐的方法是使用ipc进行通信，主进程和渲染进程之间通过事件传递信息操作数据。\n\n\n\n\n\n使用事件的好处是可以分离主进程和渲染进程之间的逻辑，而无需关注真正的代码和方法名称。\n\n\nipc通信的精简#\n\nelectron一般只需要存在主进程中，但是上面的方法在使用require('electron')的时候，会将整个electron模块引入到渲染进程中，而在渲染\n进程中往往只需要访问 ipcRenderer 即可。\n\n可以使用一个前置脚本 preload.ts 将 ipcRenderer 导出并挂载到window对象里。\n\npreload.ts\n\n\n\n然后在vue.config.js文件里挂载preload脚本：\n\n\n\n在background.ts脚本中也要指定preload脚本：\n\n\n\n如果你使用的typescript，还需要在window对象上补充声明ipcRenderer的类型。\n\nglobal-window.d.ts\n\n\n\n\n无法编译本地模块#\n\n如果项目依赖的包包含了操作系统相关的本地绑定模块（如fsevents.node），那么在构建打包的时候会出现以下异常：\n\n\n\n这是因为打包构建的时候没有找打合适的处理器来处理.node后缀的文件，但事实上这类文件本身不需要处理。就可以通过vue.config.js配置项，将这类模块进行\n排除。\n\n\n\n\n参考内容#\n\n * Cannot build project due to fsevents with Electron app on Mac\n * Guide | Vue CLI Plugin Electron Builder","routePath":"/2021/04/23/restart-from-the-very-beginning-for-electron-with-configure-project/","lang":"","toc":[{"text":"Vue Devtools 无法使用（未解决）","id":"vue-devtools-无法使用未解决","depth":2,"charIndex":119},{"text":"进程通信","id":"进程通信","depth":2,"charIndex":285},{"text":"ipc通信的精简","id":"ipc通信的精简","depth":2,"charIndex":622},{"text":"无法编译本地模块","id":"无法编译本地模块","depth":2,"charIndex":954},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1117}],"domain":"","frontmatter":{"layout":"post","title":"再次从零开始捣鼓一个Electron应用——项目配置","date":"2021-04-23T21:28:26.000Z","categories":"体验Electron","tags":["electron","node"]},"version":""},{"id":42,"title":"再次从零开始捣鼓一个Electron应用——使用electron-builder","content":"#\n\n自从17年接触过electron后，不知过了多久就弃坑，实在想不到会重起这个系列。\n\n先说一下重起的原因，Github会扫描仓库中使用的npm包的版本，如果发现使用了含有漏洞的版本会给出提示，需要进行升级。于是就尝试升级了一下老项目的版本依赖，在\n升级到最新版本之后，很自然的项目跑不起来了。\n\n考虑到一个一个的适配版本太麻烦，而且当时使用的一些内容也过时了，所以想着不如推倒再次从零开始捣鼓一个Electron应用。希望这次能够顺利按照思路走下去，不要再\n无缘无故鸽了。\n\n\n新建的思路#\n\n要新建一个electron项目，按照3年前的思路是，首先新建一个空白的electron工程，然后想办法在渲染层引入vue进行构建。\n\n最近发现另一个思路，基于electron-builder可以在现有的vue项目上，增加electron的测试、调试和构建功能。\n\n然后我们就按照这次的思路走下去。\n\n\n新建一个Vue3项目#\n\n本次我们使用的是最新的Vue3作为基础，需要先检查一下目前的vue-cli版本。\n\n\n\n截止目前我的vue-cli版本是4.5.10，低版本可能无法正常创建vue项目。\n\n创建Vue项目vue-cli提供了两种方式，命令行交互方式和网页方式。这里使用命令行交互方式：\n\n\n\n接下来的各种选项也不进行详细说明了，根据自身的需要选择。最后vue-cli会创建默认项目并尝试安装依赖。\n\n到达这一步的时候，使用启动命令，就能看到默认的vue页面了。\n\n\n\n\n增加electron-builder构建#\n\nelectron-builder 是一个vue-cli插件，帮助我们在原来的vue-cli基础上增加electron打包功能。\n\n在项目的目录里执行：\n\n\n\n选择electron版本后等待安装完成。\n\nelectron-builder 会在原有项目里增加一些内容：\n\n * 默认测试方法\n * 主进程启动方法\n * vue.config.js相关配置\n\n\n基本操作#\n\n在上面的一系列操作之后，一个简单的electron+Vue构建的项目就完成了。electron-builder已经在package.json中注入了一部分操作，\n可以使用这些命令进行本地的调试工作。\n\n\n\n现在项目已经重新搭建完毕了，可以再次愉快的编码了。\n\n\n参考内容#\n\n * Electron+vue-cli3开发跨平台桌面应用","routePath":"/2021/04/22/restart-from-the-very-beginning-for-electron-with-electron-builder/","lang":"","toc":[{"text":"新建的思路","id":"新建的思路","depth":2,"charIndex":241},{"text":"新建一个Vue3项目","id":"新建一个vue3项目","depth":2,"charIndex":400},{"text":"增加electron-builder构建","id":"增加electron-builder构建","depth":2,"charIndex":639},{"text":"基本操作","id":"基本操作","depth":2,"charIndex":840},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":978}],"domain":"","frontmatter":{"layout":"post","title":"再次从零开始捣鼓一个Electron应用——使用electron-builder","date":"2021-04-22T23:05:51.000Z","categories":"体验Electron","tags":["electron","vue","vue-cli","electron-builder"]},"version":""},{"id":43,"title":"从视频网站下载视频的那件事","content":"#\n\n最近有朋友想从视频网站下载视频，于是稍微研究了一下如何下载。想当年下载视频的时候都有工具能够自动解析，随着时间的发展，这类工具要不不再更新了，要不无法支持某些视\n频网站的下载。这里使用的工具是m3u8-downloader，主要探讨如何手动获取各个视频网站的m3u8文件。找到m3u8文件后，通过m3u8-download\ner工具就可以实现视频片段的下载和自动合并工作。\n\n\n腾讯视频#\n\n首先吐槽一下腾讯视频的广告时间好长。广告时间过去后，在播放器右键选择【复制调试信息】，会得到一串JSON格式串。\n\n\n\n找一个格式化JSON的网站，可以更方便的看到里面的结构。其中的vurl部分就是被编码的m3u8地址。\n\n\n\n再使用一个urlDecode的工具，解码出来地址就可以使用了。\n\n\n\n\n优酷视频#\n\n优酷视频就比较简单了，打开控制台，切换下对应的清晰度，在Network标签页，搜索m3u8就可以看到对应的地址了，这个地址直接可以下载。需要注意的是VIP和超前\n点播有加密，虽然能下载但是却无法播放。另外想吐槽的是，优酷的水印居然不是加在视频上的。\n\n\n\n\n芒果TV#\n\n芒果TV和优酷视频一样，也是打开控制台，然后搜索对应的m3u8文件。但是不同的是直接下载的话会提示下载失败，需要提供【请求头】。这部分信息也可以在控制台里找到，\n复制【Request Headers】里的内容到下载器里即可。\n\n","routePath":"/2021/04/08/find-m3u8-file-to-download-video-from-video-website/","lang":"","toc":[{"text":"腾讯视频","id":"腾讯视频","depth":2,"charIndex":191},{"text":"优酷视频","id":"优酷视频","depth":2,"charIndex":348},{"text":"芒果TV","id":"芒果tv","depth":2,"charIndex":484}],"domain":"","frontmatter":{"layout":"post","title":"从视频网站下载视频的那件事","date":"2021-04-08 23:30:41","categories":["高效生活"],"tags":["m3u8","视频","下载"]},"version":""},{"id":44,"title":"使用Jetpack Compose For Desktop创建生成式艺术和算法创作探索程序","content":"#\n\n日常刷微博的时候，发现了有人推荐一个生成式艺术的github仓库，看到里面的样例图片，展示出的艺术形式看起来很不错。不过这个代码是用go语言编写的，而且只支持命\n令行模式，没有图像化的界面。本着重复造轮子的思想，就想着能不能用kotlin重新来一遍，又考虑到最近关注的 jetpack compose for\ndesktop ，就这样一个整合式的想法就诞生了。\n\n这个程序到底是干什么？也没有什么定论。不要问，问就是 艺术 ！总之喜欢什么就往里放什么，最后会变成一个大杂烩的形式。\n\n在开始说明之前，欢迎大家前来体验，并给个三连sumy7/an-arts。\n\n\n生成式艺术#\n\n如何理解生成式艺术（generative）？\n\n> 自动生成艺术是指如果仔细观察艺术家与科学家利用计算机所做的事情，那就是让赋予计算机自主性，设计了一定的规则让它们自由发挥，从而得到了无法复制、美丽的结果。\n\n我的理解是根据输入参数（大小、颜色、多少）和一些随机数，经过一系列的绘制变换，最终生成的一幅图像。这个过程离程序自主学习、自由发挥的场景还比较遥远。还是只能以人\n工的方式介入一个固定的算法。\n\n说到绘制图像，不得不提到 Canvas\n，这个神奇的名字不止出现的前端Web领域，在Android和Java也有一席之地。为了兼顾效率和成本，生成式艺术不得不借助此类技术。幸运的是，处于开发阶段的\njetpack compose for desktop 对 canvas 有了实现，这就为本程序鉴定了基础。\n\n\n程序架构#\n\n第一印象下构想出来的界面是一个左右分栏，左边可以对Arts进行配置，右侧展示配置后的效果。\n\n\n\n上图展示了浏览界面的一个效果，topbar展示当前浏览的Arts名称，点击左侧的按钮可以出现一个列表用于快速切换到其它Arts。\n\n\n可配置化表单#\n\n借助于 jetpack compse\n使得对响应式变量的改变能够迅速反映到界面上，有一种正在写vue的感觉。而恰恰是这种响应式，让我可以将以前在Web端构想的“自定义表单”模式在此处加以实现。\n\n使用反射获取到配置类中的各个属性，判断属性上是否有对应的注解。根据注解的类型渲染出对应的表单项，并将注解所在的响应式变量与表单项进行绑定。\n\n一个典型的表单项配置如下：\n\n\n\n@ColorChooseFormItem\n就是一个用于单个渲染颜色选择器的注解。目前已实现了静态文本、输入框、滑块、单选框、单个颜色选择和系列颜色选择的注解表单项。后续还会根据需要不断补充和完善。\n\n操作表单项会引起绑定的响应式属性的变化，而属性的变化又会间接影响到渲染内容的刷新。整个过程就这样一气呵成。\n\n\n支持动画#\n\n我不仅考虑了静态Arts，还想将动态的Arts也一并展示出来。谁又不爱魔性的动画呢？\n\n说起动画就不得不提到动画渲染和主循环，动画渲染这里仍然使用Canvas进行渲染，那么主循环该如何实现？一般动画的主循环要完成两件事情——Update和Draw。\nUpdate阶段对属性进行重新计算，更新对应属性值。Draw阶段则会利用新的属性值重新绘制（这里没有使用增量过程）所有的画面。每循环一次就会完成一帧画面，不断的\n循环量不断的重绘，动画就这样出现了。\n\n要支持动画就要解决Update和Draw这两个问题。Draw阶段借助于 jetpack compse 的 recompse\n过程，只要将一些关键属性设置为响应式模式，修改这些关键属性自然会引起重绘。Draw虽然解决了，但是Update还是需要一个循环来控制它。\n\n\n\n这里借助协程切入到动画效果更新中。由此作为主循环执行Update操作。\n\n于是每个Arts就要出现三个生命周期，onInit、onUpdate和onDraw。在这三个生命周期里onInit完成变量的初始化，onUpdate对关键属性进\n行更新，onDraw描绘单次绘制的方法。而动画Arts和普通Arts差异仅仅体现在onUpdate是否会进行调用。\n\n\n\n有了动画Arts类型之后，我又尝试收集一些动画效果进行实现，其中不乏对svg和javascript动画效果的迁移。\n\n这里还实现了一个暂停播放的功能，也是非常的简单，主要原理是在循环中停掉Update的过程，相对应的Draw过程也会停止，即使发生了重绘，由于属性值没有发生变化，\n与上一帧也会是相同的。\n\n\n未来#\n\n目前已经实现（借鉴？抄？迁移？）了一些生成式艺术的算法，总体感觉来说还是可以接受的。但是也不会止步于此，后续有时间还会继续进行补充，目标是《十万个生成式艺术》。\n\n现在一进入程序就会出现一个默认的（字母序第一个）Arts，考虑到后续增多，可以考虑做个首页，从首页进入各自的详情页。\n\n当然还有几个方面不太理想，界面还需要继续打磨，现在用的还只是默认样式，相信随着学习的深入，一定会变得越来越能看的。图像只能观看不能保存，这个暂时没有找到什么好方\n法解决，等以后解决了再单独开个文章进行讲解吧。\n\n\n参考内容#\n\n * sumy7/an-arts\n * jdxyw/generativeart","routePath":"/2021/04/05/generative-art-explorer-in-kotin-with-jetpack-compse-for-desktop/","lang":"","toc":[{"text":"生成式艺术","id":"生成式艺术","depth":2,"charIndex":283},{"text":"程序架构","id":"程序架构","depth":2,"charIndex":649},{"text":"可配置化表单","id":"可配置化表单","depth":2,"charIndex":772},{"text":"支持动画","id":"支持动画","depth":2,"charIndex":1123},{"text":"未来","id":"未来","depth":2,"charIndex":1823},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2077}],"domain":"","frontmatter":{"layout":"post","title":"使用Jetpack Compose For Desktop创建生成式艺术和算法创作探索程序","date":"2021-04-05 00:12:49","categories":["艺术人生"],"tags":["kotlin","generative-art","generative","jetpack-compose"]},"version":""},{"id":45,"title":"博客评论系统迁移到Valine","content":"#\n\n原来博客的评论系统使用的disqus，个人还是比较喜欢disqus评论的，无奈被“限制”的太厉害，常年加载不出来。无奈只好寻求其它的解决方案。\n\n参考几个评论系统，有几款基于Github Issues的评论系统，有专门的评论系统（来必力等）。基于Github\nIssues的在存储上不成问题，但是考虑到评论导入的问题，就不太好操作了，切换到这类评论系统需要舍弃以前的评论信息。第三方的评论系统就要考虑随时被墙的问题，而且\n打开速度也有影响。\n\n最后选择了Valine，主要看中了其没有后端，可以操作数据库，“伪造”评论 :sweat_smile:。\n\n\n添加评论系统#\n\n首先需要获取评论系统使用的appId和appKey，这个就不多介绍了，可以参考valine文档中的快速开始部分进行获取。\n\n本博客使用了 maupassant 主题，没有配置对应的评论模块，需要自己手动添加。\n\n先在博客配置文件 _config.yml 中增加关于valine主题的配置。\n\n\n\n添加好配置后，找到评论渲染的位置 _partial/comments.pug 文件，引入公共js并渲染评论控件。\n\n\n\n可以用valine的访问统计替换掉busuanzi的访问统计，找到 post.pug 文件中的访问统计位置，增加以下模板：\n\n\n\n这样基本上就能使用了。\n\n\n迁移评论数据#\n\n接下来需要将评论数据从disqus迁移到valine中。从disqus导出评论数据。在disqus后台，Export可以导出所有的评论数据。导出后从邮件里就会获\n取一个所有评论的xml文件。\n\n下载完数据后，找到一个disqus导入valine数据的网站，https://taosky.github.io/disqus-to-valine/可以将disq\nus评论数据转换成valine并直接导入到数据库中。\n\n导入完成之后，还需要调整下数据权限，防止客户端随便删除评论。\n\nLeanCloud上有个批量操作数据的功能，将所有数据的ALC更新成 {\"*\":{\"read\":true}} 即可。\n\n\n\n这样数据迁移就完成了。\n\n\n其它#\n\n现在评论已经切换到valine中，还有一些功能，比如 最近评论列表 和需要展示的 评论数量 看怎么能实现，目前这两个功能暂时先空缺了。\n\n\n参考内容#\n\n * 评论系统从Disqus迁移到Valine\n * valine","routePath":"/2021/03/29/blog-switch-to-valine-comments-plugin/","lang":"","toc":[{"text":"添加评论系统","id":"添加评论系统","depth":2,"charIndex":279},{"text":"迁移评论数据","id":"迁移评论数据","depth":2,"charIndex":575},{"text":"其它","id":"其它","depth":2,"charIndex":898},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":973}],"domain":"","frontmatter":{"layout":"post","title":"博客评论系统迁移到Valine","date":"2021-03-29 15:58:01","categories":["网站"],"tags":["valine","评论"]},"version":""},{"id":46,"title":"使用树莓派制作一个电子日历","content":"#\n\n闲暇时候看到一篇文章，介绍可以用树莓派加一块墨水屏制作一个电子日历，然后心血来潮就打算自己也制作一个。前前后后磨蹭了一年的时间，终于克服了懒癌在去年十一假期的时\n候制作出来了。这段时间看到小米有品也出了一款电子日历，算下来成本和自己制作的差不多。但是怎么说，自己制作的日历可是带了一个树莓派呀，四舍五入就价值一个亿了呀。\n\n先来看一下成品：\n\n\n\n整个日历用一个收纳盒包装起来，日历展示了时间、日期、天气和一年进度。这个展示模板只是考虑尽量不联网情况下的内容。不得不说，在不联网的情况下能够展示的资源比较少，\n基于网络上的其它API进行功能的扩展，可用性就大大增强了。\n\n\n材料准备#\n\n主要“材料”是一个树莓派、一块电子墨水屏和两张sd卡。\n\n * 树莓派使用的是树莓派3b+，某宝上可以搜索一下，很容易找到\n * 电子墨水屏用的是微雪4.3inch e-Paper\n * 两张sd卡和读卡器，一张用来做树莓派的存储安装系统，另一张为墨水屏展示提供图片素材存储，容量不需要太大\n * 建议再准备一套外接的键盘、鼠标、显示器和hdmi线，方便在树莓派上调试和操作\n\n\n树莓派准备#\n\n\n安装系统#\n\n首先需要安装系统，从官网https://www.raspberrypi.org/downloads/raspberry-pi-os/下载系统镜像，选择\nRaspberry Pi OS with desktop and recommended software进行下载。\n\n下载完镜像之后，需要一个软件win32diskimager将镜像写入到sd卡中，Image File 选择刚下载的系统镜像，Device\n选择sd卡的盘符，注意不要选错了。写入完成后将sd卡插入到树莓派中，然后就可以开机使用树莓派了。\n\n\n硬件连接#\n\n我也是嵌入式苦手，在接线这点也卡了好久，主要是确定哪个引脚叫什么比较麻烦，参考了好多个教程才搞定。这里提供树莓派和墨水屏的引脚图进行参考。\n\n\n\n墨水屏的引脚说明图在连线的下方，很容易就能找到。\n\n\n\n按照以下进行连接，线色仅供参考。再提一句，树莓派3V的引脚在实物图的左侧。\n\n屏幕     树莓派          线色\nDIN    TX(GPIO14)   绿\nDOUT   RX(GPIO15)   白\nGND    GND          黑\nVCC    3V           红\n\n\n软件配置#\n\n树莓派默认的串口已经有其它用途，所以需要释放串口用于控制墨水屏。\n\n先连接无线网络，常规操作更新一下系统\n\n\n\n编辑 /boot/config.txt 添加一行\n\n\n\n禁用自带蓝牙\n\n\n\n释放串口，编辑 /boot/cmdline.txt\n\n\n\n安装墨水屏驱动\n\n\n\n\n电子日历展示程序#\n\n这个墨水屏是通过屏幕里的sd加载图片资源和字体资源的，所以需要将sd卡格式化成FAT32格式，分配单元大小选择 4096\n字节，然后把展示程序附带的资源拷贝到sd卡中，再插入到屏幕卡槽里使用。\n\n这里可以使用我提供的展示程序\nhttps://github.com/sumy7/rasepbarry-pi-epaper，或者参考附录里提供的展示程序也可以。只要注意屏幕的资源相匹配即可（俩\n用的应该是相同的资源）。\n\n\n\n在程序目录 /home/pi/rasepbarry-pi-epaper/ 里执行 python ./main.py 命令，就可以看到屏幕刷新了。\n\n\n定时程序#\n\n屏幕不是自动刷新的，而是每执行一次命令则刷新一次。这样需要配置一个定时任务让屏幕可以自动刷新。\n\n\n\n命令配置的是每个1分钟刷新一次，间隔不用太长，墨水屏的刷新率本身就很低。\n\n\n参考内容#\n\n * emptyhua/epaper_clock\n * 树莓派+串口墨水电子屏幕+温度湿度传感器打造专属时钟","routePath":"/2021/03/23/raspberry-pi-with-ink-screen-to-build-electronic-calendar/","lang":"","toc":[{"text":"材料准备","id":"材料准备","depth":2,"charIndex":289},{"text":"树莓派准备","id":"树莓派准备","depth":2,"charIndex":486},{"text":"安装系统","id":"安装系统","depth":3,"charIndex":495},{"text":"硬件连接","id":"硬件连接","depth":3,"charIndex":758},{"text":"软件配置","id":"软件配置","depth":3,"charIndex":1018},{"text":"电子日历展示程序","id":"电子日历展示程序","depth":3,"charIndex":1160},{"text":"定时程序","id":"定时程序","depth":3,"charIndex":1456},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1553}],"domain":"","frontmatter":{"layout":"post","title":"使用树莓派制作一个电子日历","date":"2021-03-23 00:13:30","categories":["实践"],"tags":["树莓派","电子日历","墨水屏","raspberry_pi"]},"version":""},{"id":47,"title":"解析用户输入表达式的值，简易的JS沙箱","content":"#\n\n有时候我们需要解析用户输入的表达式，用户输入的表达式千奇百怪，如何控制只能使用指定的函数，制作一个简易的沙箱环境？\n\n参考Vue的代码，实现以下效果：\n\n 1. 获取用户输入表达式字符串的值\n 2. 只能访问指定对象上的值\n 3. 不能访问global/window上定义的变量属性\n\n代码及测试代码如下：\n\n\n\n稍微解释一下原理：使用JS的Proxy代理，hasHandler用于拦截判断某个属性是否存在对象上的操作。这里用到了Proxy的两个拦截器——has 和\nget。has 用于表明给定的属性是否在该对象内，如果不在引擎会尝试向外层作用于查找。get 用于从查找到的作用于里获取对应属性的值。\n\n这里使用了 has 进行拦截操作：\n\n * 如果访问的属性已经存在vm对象上，则 has 直接声明存在当前对象上\n * 如果属性不在vm对象上，但是在allowedGlobal中，则 has\n   声明变量不在该对象上，引擎会往外层作用域查找，最终找到window/global对象上的属性\n * 如果属性不在vm对象上，也不在allowedGlobal中，则 has 声明变量在该对象上，拦截引擎的外层作用域查找操作。后续通过 get\n   在当前对象返回属性值时只能获取到 undefined，达到拦截对window/global属性访问的目的\n\n\n参考内容#\n\n * proxy.js-vuejs-Github","routePath":"/2021/03/22/eval-js-expression-that-can-only-use-allowed-functions/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":582}],"domain":"","frontmatter":{"layout":"post","title":"解析用户输入表达式的值，简易的JS沙箱","date":"2021-03-22 23:42:01","categories":["果然还是前端"],"tags":["javascript","expression","表达式","沙箱"]},"version":""},{"id":48,"title":"使用Bootstrap的popovers时鼠标移动到tips也保持展示","content":"#\n\n目的是需要制作一个点击可以打开OA进行聊天的链接，鼠标放置上去可以展示当前人的邮箱等联系方式。\n\n以前的平台使用的是Bootstrap的前端控件，所以选择popover控件作为实现的基础控件。但是使用时发现，popover控件提供的几种方式，hover模式下\n鼠标移开之后tips就会关闭，而click的体验不太好。想要的效果是，鼠标移动展示邮箱tips，鼠标移动到tips上可以进一步操作（选中复制邮箱等）。\n\n参考了Stack Overflow上的一个问题，最终实现了该功能。\n\n核心代码如下：\n\n\n\n实现的大体思想是，将popover的触发模式改为手动manual。然后监听鼠标进入离开的事件。\n\n * 如果鼠标进入触发位置，则弹出popover，并注册一个离开tips则隐藏的事件\n * 如果鼠标离开触发位置，则300ms后判断，鼠标不在tips时则隐藏\n * 鼠标离开tips时，触发进入时注册的事件，进行隐藏\n\n实现效果：\n\n直接使用的是Stack Overflow的栗子，可以进行适当改进，原理还是差不多的。如果有幸能找到以前的代码，会再修改完善一下。\n\n\n参考内容#\n\n * jquery - How can I keep Bootstrap popovers alive while being hovered? - Stack\n   Overflow","routePath":"/2021/03/17/keep-bootstrap-popovers-alive-while-hovered-tips/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":488}],"domain":"","frontmatter":{"layout":"post","title":"使用Bootstrap的popovers时鼠标移动到tips也保持展示","date":"2021-03-17 23:24:45","categories":["果然还是前端"],"tags":["bootstrap","jquery","popover"]},"version":""},{"id":49,"title":"Maven构建Spring时连同进行npm构建并合并部署","content":"#\n\n前后端分离已成为现在的主流。一个项目后端使用Java+SpringBoot的模式，提供接口；前端使用Vue提供用户界面。前后端的差异也体现在了部署上，后端需要一\n套JDK环境，而前端可能只需要一个静态网页服务器。\n\n在这种前后端模式成熟的基础上，为什么还需要将前后端部署在一起（同一容器）呢？可能有以下几个原因：\n\n 1. 前端后端都是一个人写的，关联性比较强，可能更适合一起部署\n 2. 对JSP等模板渲染有情怀，不想让页面和数据分离\n 3. 合并部署可以节省一个容器，节省部署成本 :thinking:\n\n那如何进行前后端合并部署？下面直接说配置方法：\n\n\n合并部署#\n\n首先需要有一个Maven构建的SpringBoot项目，在此基础上，增加前端代码模块。\n\n\n增加前端代码模块#\n\n在maven中增加一个模块，将所有前端代码都拷贝到模块目录里，假如你的前端项目使用的也是vue，那么你就会得到一个类似于这样的目录结构。\n\n\n\n别忘了在其它模块中引用该模块的成品jar，使其能够正常参与到构建中。\n\n下面分步骤来说明如何配置pom.xml文件。\n\n\n准备node环境#\n\n没有node环境，就需要提前做一步操作，将node环境安装到本机中。如果使用jenkins构建，可以增加一步shell操作，用来安装部署node环境。使用的命令\n如下：\n\n\n\n需要注意的是下载node的地址需要根据实际情况进行修改。\n\n\n存在node环境#\n\n如果你的构建环境比较给力，恰巧有node，那一切都简单了。只需要一个 exec-maven-plugin\n插件，依赖执行配置镜像源、安装依赖、构建成品的npm指令即可。\n\n此处配置的镜像源使用的是华为云，实际情况下可以更换成对应的内网npm源。需要执行的命令需要根据前端项目package.json里的指令进行修改。\n\n\n\n\n拷贝打包生成的文件#\n\n前面执行完成npm命令后，会生成一些静态的成品文件，需要将其拷贝到默认的静态资源目录中。\n\n这里将 /dist 目录输出的成品文件拷贝到 /META-INF/resources 目录下。\n\n\n\n这样生成的jar包里，就带有了前端的资源文件。\n\n\nnginx转发配置#\n\n前端路由在使用了 history 模式下，刷新会出现404的情况，这时候就需要 nginx 出手解决资源无法找到的问题。\n\n\n\n这里要做的有三件事：\n\n * 一是/api开头的接口请求正常通过\n * 二是/statics目录下的静态资源放过请求原地址\n * 三是其余链接全部修改成返回index.html文件\n\n/api 和 /statics 需要跟前端协调好，前端打包构建也要生成创建对应的目录。\n\n\n一个小技巧#\n\n本地调试的时候，只需要启动服务端，前台UI有专门调试服务器。但是每次启动服务端的时候都要进行一次页面构建，就比较的不人性。\n\n可以通过 Maven 的 Profiles 功能，为 exec-maven-plugin 插件增加 profile release\n配置，在本地调试的时候不启用此配置，而线上打包的时候增加 -P release 参数。这样本地调试的时候可以充分利用前后端各自的热加载特性。\n\n\nWhy#\n\n基本原理就是，frontend-maven-plugin 插件调用npm执行安装和构建Vue的命令。然后将构建好的文件当做静态资源供SpringBoot引用。\n\n这里用到的最重要的一个是webjars。这是将css和js等静态资源打包到jar中，以maven依赖的形式对其进行管理的一种方式。而servlet3.0以上版本\n，可以直接访问jar包中/META-INF/resources目录中的文件作为静态资源。\n\n所以说本方法只是使用了webjars的资源加载方式来加载生成的静态资源。脚本中还有一些“奇怪”的配置，是为了解决存在内网镜像，但是无法访问外网资源，如何进行构建\n的该问题。\n\n\n参考内容#\n\n * webjars\n * 使用exec-maven-plugin插件实现Maven和npm混合编译","routePath":"/2021/03/16/spring-maven-package-with-npm-build-dist/","lang":"","toc":[{"text":"合并部署","id":"合并部署","depth":2,"charIndex":283},{"text":"增加前端代码模块","id":"增加前端代码模块","depth":3,"charIndex":336},{"text":"准备node环境","id":"准备node环境","depth":3,"charIndex":480},{"text":"存在node环境","id":"存在node环境","depth":3,"charIndex":610},{"text":"拷贝打包生成的文件","id":"拷贝打包生成的文件","depth":3,"charIndex":784},{"text":"nginx转发配置","id":"nginx转发配置","depth":3,"charIndex":919},{"text":"一个小技巧","id":"一个小技巧","depth":3,"charIndex":1133},{"text":"Why","id":"why","depth":2,"charIndex":1343},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1646}],"domain":"","frontmatter":{"layout":"post","title":"Maven构建Spring时连同进行npm构建并合并部署","date":"2021-03-16 20:46:06","categories":["实践"],"tags":["spring","maven","npm","node"]},"version":""},{"id":50,"title":"“毕业” or “辍学”","content":"#\n\n今天北京的沙尘暴真是几年难得一遇，我也怀着平静的心情去公司（就叫做公司A吧）走完最后的离职流程。整个流程持续了两周的事件，最后从公司带走的是一台联想ThinkP\nad、一台显示器还有一连串可能会被渐渐忘却也不知从何说起的回忆。如果把离职比作“毕业”，我更想把我的这次经历比作“辍学”。我想从头开始，稍微回忆一下博客消失的这\n一段时间的经历。\n\n\n入职——象牙塔里的百草书屋#\n\n抛开面试过程不谈，加入公司A是在2017年年底，当时还没毕业就借着实习名义“杀”过去了。领完电脑去找工位时，同事把领导旁边一个放电脑杂物位置腾挪了出来。这就是我\n这3年所在工位最初的模样，左边是我的直属领导，右边是我的小组长。\n\n这里先介绍一下组织架构，整个三级部门在直属领导下又划分出来一个虚拟部门，我们向项目组长汇报，项目组长再向直属领导汇报。项目组和项目组之间的交集很少。\n\n就这样我在一个项目组里定居了下来，这个项目组负责项目B，算是一个内部的核心项目。虽然整个三级部门人员流动频繁，但是项目总体来说还是比较稳定的。现在细想一下，要不\n是大老板想出了一个拓宽业务方向的战略，我可能会成为项目组的关门弟子了，毕竟前两年一直没有新人加入。\n\n\n奋斗——亦真亦幻的终点线#\n\n我负责的项目算是一个比较核心的项目，经历了三个大版本的迭代更新，现在是已经是第四个版本了。刚来的时候还是3个版本并行，2号版本面临下线的时期。项目核心功能是进行\n定时执行，虽然功能不是很复杂，但是从中延伸出来的上层应用却是呈“指数”增长。前期平台为了扩大影响力，承接了很多不属于核心功能的开发和维护工作，这也为后续的迁移工\n作埋下了伏笔。\n\n17年初第四版立项并开发，当时还是使用的比较流行的Bootstrap和Spring3作为底层，虽然在现在看来比较“落后”。第四版平台处于上升期，由于需要跟第三版\n平台的功能对齐，于是平台从不缺功能和需求的开发工作。我也是借着这个契机将平台和业务逐渐熟练起来。\n\n虽然平台不是很完美，经过自己的努力完成任务，并看着平台渐渐完善的感觉充实而又美好。期间同事一起去参加了一个分享会，也从开源上找到了平台的一些灵感，恍惚一瞬间找到\n了自己努力的方向。\n\n\n工作和生活——天平的失衡#\n\n随着对业务和平台的熟悉程度的增加，我的工作也从开发往运维倾斜，就是俗话说的开发运维。基本上的状态是，上午在群里解决用户遇到的使用上的问题，下午进行需求确认，晚上\n开发需求。\n\n生活上与同事的代沟比较大，虽然离一旬还远，但是关注的内容就天差地别了。房子？车子？罚单？基金？孩子？我的心里就是这些都是啥。。。每天的乐趣也就是找几个要好的同时\n一起吐槽吐槽工作，畅想一下未来项目的发展，还有便利蜂有什么打折。\n\n期间也离开了不少同事，也经历了角色改组。感觉再也见不到了，但是还是从心里为他们能有更好的未来而高兴。这么说起来，在公司里找“同好”还是比较困难的。我至今没找到一\n起玩Switch的同事，虽然安利了好几次，却没有被我生动的描述所打动。我完全不适合做推销（雾。\n\n平时没事喜欢刷刷微博，看到什么有意思的东西总想试试。比如我发现上线的时候没有changelog，我就自己维护，感谢测试同学给予的鼓励，但到最后还是没有了。好多“\n小玩具”就这样没有人在乎于是就没了，有一些还是保留下来了，比如mapstruct、lombok、git\nrebase等等。项目上的话语权也比较小，这可能与小组的结构有关，提过几个方向虽然大家觉得还不错，但是没有得到领导的响应，一直准备着也没有等到将“幻想”变为现实\n的一天。项目参与度越来越高，但是认同感和归属感却于日递减。\n\n\n离职前兆——恶魔的低语#\n\n听到过一句话感觉很有道理，一个人在公司留下的资本是“钱”“事”“人”，要留下至少要有两项看起来还不错。我自认为坚持5年应该没什么问题，然而去年下半年却是全面崩盘\n的一年。\n\n20年下半年在保平台稳定的前提下，启动了一个战略性的项目——xxxxxx（六个字），这个项目由研发牵头，旨在建立一个类似于阿里dataworks的平台，将审批功\n能提升到一个新的高度。但是这个项目却没有与其配合的底层实现，把其它各个项目的功能“缝合”到一起，就是一个换汤不换药的项目。\n\n我自然也是反对的一方，我的理由是平台业务乱，需要先规整，底层未配合，上层有些点落地难度大，技术栈落后，老代码难以承载新功能。产品经理侧也有反对的声音。虽然有反对\n，项目还是继续搞了起来。就这样一个组的人搞了半年，出来一个半成品，没有产品经理，被外面的人牵着鼻子走，需求改动频繁，项目上线推广分了三个阶段，战线拉长，推动困难\n，士气低落。最终项目推广只好被叫停。\n\n在这期间项目组又走了一位“老人”，只剩下我和小组长。而新来的员工业务不熟悉，我就在帮新同事分析需求、分析系统、指导代码、应付六个字项目的过程中渐渐失去了耐心。小\n组长“荣升”管理层，半年内没有碰过核心代码，成了开会、需求、组会、催进度一条龙服务。那段时间的感觉就是，找不到目标找不到方向，每天在**的海洋里堆代码，没有价值\n。原项目停滞发展了六个月，有时候我就在想做什么不比做六个字的项目强，白白错过了一个相对快速发展的黄金时期。最终我把这些事归因到了小组长身上。\n\n同事J和同事L劝我，不要因为一个人就想不开，实在不行换个项目也行。但是真的感觉看到他就烦，也不知道如何面对。最终迎来了领导谈话。\n\n谈话分了两次。上午领导先是举了个栗子说要跳出舒适圈？！！我比较蒙这是啥意思——赶人走？。然后询问了我原因，我说不喜欢六个字项目，因为ABCD，然后领导一一作了解\n释。晚上的时候我说原来的项目没有向着目标第一的方向发展，领导反驳说人员少、上层压力大、任务重。我说想建立“前端共荣圈”整合前端资源，领导说给我个账号让我负责这阶\n段的招聘。跟领导谈话无非想确认自己的价值，还有今后项目发展的方向。果然没有得到自己想要的回答。最后我的结论是“想出去看看”。\n\n在1月份发表了“想出去看看”后，也没有一心扑到求职上，还是在按部就班的工作。谈话之前还发生了一件事，就是有一次晋升的机会没有给，当时的具体原因和判断逻辑已经不清\n楚了，后面给的原因也很难信服。总之，至此标志着“钱”“事”“人”的全面崩溃。\n\n又过了两个月，转眼间来到了春天，虽然大家在微妙的平衡里度过，貌似没有人记得起这件事，但是有些事却又在无时无刻不在摧残着我。就仿佛一部好剧被剧透了一样，每一个需求\n，每一次反馈，都歪歪扭扭写着两个字——敷衍。这样的状态既占用公共资源，又使需求实现大打折扣，最终还是决定。。。\n\n\n再会——无限远点的交织体#\n\n最终还是决定走了。。。提离职的那天，我想了好久如何表达，想想我为什么就不能理直气壮一些？——老子不干了？！！我没注意领导的表情，他只是说你想清楚了，现在走可就再\n也回不来了，还可能上“黑名单”。我最终还是没有将心里话说出来（其实也没什么心里话），只是狠狠的回复了个Y。“两周时间工作交接，好了就这样了”。\n\n在回来的公交车上看着沙尘暴，突然有了一种释怀的感觉。我在群里发了个红包，“祝大家事业顺利”。就这样不辞而别，真是一个渣男的作风呀，我苦笑着。\n\n两周的工作交接虽然工作轻松了不少，但就像一辆车的惯性，依旧的向前行驶。最后一个需求，一份交接文档，一份需求上线tips，提测，收拾工位，跟用户请个“长假”。你的\n话还是那么恶毒，但也无所谓了。没有告诉任何人，就像开始突然“杀”过来一样，我又突然“飞”走了。\n\n回想这几年，感谢各位同事对我的包容，包容我的犯错，包容我的任性。这次的决定可能不是最好的决定，也可能是最坏的决定。\n\n最后，江湖路远，各自珍重。","routePath":"/2021/03/15/leave-from-company-a-resign-or-quit/","lang":"","toc":[{"text":"入职——象牙塔里的百草书屋","id":"入职象牙塔里的百草书屋","depth":2,"charIndex":175},{"text":"奋斗——亦真亦幻的终点线","id":"奋斗亦真亦幻的终点线","depth":2,"charIndex":515},{"text":"工作和生活——天平的失衡","id":"工作和生活天平的失衡","depth":2,"charIndex":925},{"text":"离职前兆——恶魔的低语","id":"离职前兆恶魔的低语","depth":2,"charIndex":1519},{"text":"再会——无限远点的交织体","id":"再会无限远点的交织体","depth":2,"charIndex":2732}],"domain":"","frontmatter":{"layout":"post","title":"“毕业” or “辍学”","date":"2021-03-15 23:49:12","categories":["随笔"],"tags":["离职"]},"version":""},{"id":51,"title":"使用git中的rebase简化commit提交历史","content":"#\n\nGit作为“现代”开发中不可获取的一部分，平时的最常用的几个命令是 init clone push pull\norigin。但Git包含的功能却远远不止这些。说起命令，就想起之前面试官提到了rebase，然后就尝试了一下rebase这个命令，最后发现这完全是强迫症的福利\n。只要平时的开发流里再多几个简单操作，世界就能变得很美好，而且有了IDE的加持，用起来更加简单便捷了。然后，虽然这个前言感觉很唐突，天道好轮回，技术债也是要还的\n。\n\n\n合并的策略#\n\n合并从场景来说分为两种， 不同分支的合并 和 单个分支的合并 。\n\n不同分支的合并这个没什么可说的，参照 git merge --no-ff xxx 的命令执行。\n而单个分支的合并一般在多人开发同一个分支的时候，如果有人提前提交到了远程仓库，那么其它人再想提交的话，就必须先把远程仓库的修改合并到本地，才能再次提交。\n\n同事们大多数都是commit后发现提交不上去，然后pull一下执行一次同分支合并。这样提交记录里就会华丽丽的看到很多分支自己merge自己的情况了，而这种提交记\n录是完全没有必要的。（忽略黑黑的打码）\n\n\n\nmarge 特点：自动创建一个新的commit 如果合并的时候遇到冲突，仅需要修改后重新commit 优点：记录了真实的commit情况，包括每个分支的详情\n缺点：因为每次merge会自动产生一个merge commit，所以在使用一些git的GUI tools，特别是commit比较频繁时，看到分支很杂乱。\n\nrebase 特点：会合并之前的commit历史 优点：得到更简洁的项目历史，去掉了merge commit\n缺点：如果合并出现代码问题不容易定位，因为re-write了history\n\n单分支 下，建议使用rebase将远程分支更新到本地。 多分支 合并，使用merge策略合并分支。\n\n\nrebase使用#\n\nrebase的其它用法就不再介绍了（其实是暂时用不上，等用上了再说），只说明一下pull的时候的用法。\n\n有人可能会说，那我在commit之前先pull一下，这样不就可以了？\n\n这种方法完全可以，“事前”可以用来规避单分支合并出现无用commit的问题，但是不小心到“事后”了会怎样。\n\nrebase使用起来非常简单，命令行模式下记得在pull的后加 --rebase 参数。常用命令如下：\n\n\n\nGUI以Intellij为例\n\n提交代码前先更新项目，使用rebase方式\n\n\n\n遇到冲突时解决冲突，IDE会自动执行 --continue 命令。\n\n\n\n与平时使用的merge真的很像。\n\n\n总结一下#\n\nrebase的一些用法：\n\n 1. 合并多个commit为一个完整的commit\n 2. 将某一段commit粘贴到另一个分支上\n\nrebase实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。\n\nrebase会改写历史记录，永远不要在已经push了的commit上使用。\n\n还是稍微吐槽一下 变基 这个名词吧，感觉很magic:star:\n\n\n参考内容#\n\n * Rebase 代替合并\n * git rebase 和 git merge 的区别","routePath":"/2018/10/28/simplify-commit-history-with-git-rebase/","lang":"","toc":[{"text":"合并的策略","id":"合并的策略","depth":2,"charIndex":223},{"text":"rebase使用","id":"rebase使用","depth":2,"charIndex":798},{"text":"总结一下","id":"总结一下","depth":2,"charIndex":1105},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1296}],"domain":"","frontmatter":{"layout":"post","title":"使用git中的rebase简化commit提交历史","date":"2018-10-28 18:50:26","categories":["高效生活"],"tags":["git","git rebase"]},"version":""},{"id":52,"title":"魔法の筆 呪文で絵描くよ 君も描こう！","content":"#\n\n好久没更新博客了，今天趁着月末就再来水一篇吧。\n\n\n起因原来是太鼓达人#\n\n前十几天刷微博的时候发现一个有意思的歌曲，就是歌曲的歌词其实是一个程序，有人还把这首歌的歌词听写出来，然后跑起来了。\n\n听完魔性的音乐后，一颗搞事的心在熊熊燃烧，就把这段代码抄了下来。。。\n\n\n\n\nvoid_setup的即兴转换#\n\n查了一下这段代码所用的语言，使用的是一个叫Processing的语言。好巧的是前段时间又正好了解了这个语言的 JavaScript 实现版\np5.js。能不能将上面的语言实现成下面的这种呢？\n\n在一个周末，借助文档、搜索引擎和零食，成功的完成了代码的转换工作。由于是同一种语言的不同实现，代码的相似度还是挺高的。这段代码可以直接运行。\n\n\n魔法的画笔，你也一起来画吧#\n\n在转换的过程中，遇到了一些“不太兼容”的问题。\n\n在网页上需要转换成Canvas画布，于是 size() 命令就转成了 createCanvas() 命令。\n\nProcessing中的颜色可以直接作为常亮使用，而JavaScript中的颜色使用字符串的形式表示，不同的写法代表不同的意义。如 rgba()\n是颜色附带了透明度的形式。\n\n颜色还有一个不同的地方是JavaScript的颜色不能直接相加。在Processing中小红的颜色是根据小蓝的颜色 #68c0c0 加上 #8f8768\n得到的，这里直接使用了计算后的小红的颜色值 #fb4828 。颜色相加就是普通的二进制相加。\n\n绘制的算法主要分为两个步骤，第一步是进行画布变换，对画布进行位移、旋转、缩放的变换。第二步则是在变换后的画布上绘制两个图像，图像的绘制由 kao() 函数完成。\n\n\n\n一个很简单的绘图小程序就这样出现了（再次。\n\n\n最后才开始吧#\n\n对了，忘了说这首歌叫《void setup》，可惜的是网易云音乐还没有收录该音乐。不过自己已经从油管上下载了音频文件，有空的时候可以慢慢回味一下。\n\n\n参考内容#\n\n * Processing\n * p5.js","routePath":"/2018/07/31/p5js-version-for-taiko-drum-master-song-void-setup/","lang":"","toc":[{"text":"起因原来是太鼓达人","id":"起因原来是太鼓达人","depth":2,"charIndex":28},{"text":"void_setup的即兴转换","id":"void_setup的即兴转换","depth":2,"charIndex":139},{"text":"魔法的画笔，你也一起来画吧","id":"魔法的画笔你也一起来画吧","depth":2,"charIndex":327},{"text":"最后才开始吧","id":"最后才开始吧","depth":2,"charIndex":744},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":829}],"domain":"","frontmatter":{"layout":"post","title":"魔法の筆 呪文で絵描くよ 君も描こう！","date":"2018-07-31 13:48:45"},"version":""},{"id":53,"title":"记一次简单的域名解析找回操作","content":"#\n\n前段时间搞了点东西，想放到自己的域名上。很自然的在域名解析里配置了将域名解析到自己服务器上，结果过了一段时间发现，域名被解析到一个**彩网站上面去了。以为自己搞\n错了解析，再三确认了配置没有错误。然后开始了解析错误查找之旅。\n\n首先确认了解析有没有过来，使用了站长工具Ping检测测试了域名的连通情况，发现国内的解析都指向了一个IP地址，国外的解析都是正常的。而直接访问这个IP地址，就是\n那个什么什么的网站。\n\n国内国外出现了不同的解析地址，下一步用 dig 命令看一下域名的dns情况：\n\n\n\n可以发现解析被dnspod接管了，但是我之前并没有在上面配置相关的dns解析？不管怎样还是登陆上去看一看。\n\ndnspod与域名解析的网站很相似，关键是可以 自定义\n输入域名，即使那个域名不是dnspod所有。我试着输入了我的域名，提示域名已经被其它账户占用了，是否需要认领。\n\n\n\n认领域名需要认证 WHOIS 邮箱，还好之前已经在域名里配置了相关的邮箱，通过WHOIS成功将域名取回到了自己的账户里。\n\n认领回来第一步就是把错误的域名解析删除，然后 不情愿 的换上了自己的域名解析。\n\n查看了域名操作记录，发现它在几天前就已经恶意注册了域名解析，过了几天才被我发现。\n\n\n\n限于自己的水平，就没对这个邮箱做进一步处理，域名解析找回来了，可喜可贺，可喜可贺。\n\n回想这件事，dnspod这种先来先得的域名认领方式存在很大的隐患，还不知道有多少人的域名被恶意认领。规则之下，无至则溃。","routePath":"/2018/06/26/domain-resolves-to-an-unknown-website/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"记一次简单的域名解析找回操作","date":"2018-06-26 22:38:55","categories":["网站"],"tags":["域名","解析","dnspod"]},"version":""},{"id":54,"title":"优化SQL查询时候的性能","content":"#\n\n最近是特殊时期，都在强调系统性能的优化。在师傅的指导下，对系统中一个比较费劲的功能进行了优化。师傅的理念是： 能用SQL解决的问题绝不用程序处理\n。在实际场景下，通过优化，将3分钟无法完成的业务优化到了1分钟以内。虽然没有优化到极致，但对SQL查询性能的了解前进了一大步，于是稍微记录一下。\n\n\n建立索引#\n\n索引是避免全表扫描的一个重要手段。有索引和没有索引，好的索引和差的索引，对于性能的影响都是不同的。对于经常查询的字段可以建立索引，如主键；对于经常组合查询的字段\n可以建立联合索引。\n\n这次遇到的情况是：\n\n\n\n这样子可以考虑将 (a, b) 建立组合索引。\n\n\n使用IN进行批量查询#\n\n一般情况下，通过一次查询之后可能不会完全返回需要的所有数据，这时候会对每一条数据进行一次补充查询。\n\n\n\n如果数据条目比较多，会频繁进行访问数据库操作。\n\n为了减轻数据库的压力，可以将第一次查询初始数据后的值整合到列表中，查询补充数据的时候通过 IN 操作一次全部查询出来，然后在内存中转成map与初始数据对应结合。\n\n\n\n\n避免将不同字段作为条件进行OR查询#\n\n使用 OR 可以查询出满足多个条件中至少一个条件的数据。但是如果遇到没有索引的字段，可能会造成无用的全表扫描。\n\n\n\n这种情况下通过将OR进行拆分，作为两个select语句，通过 UNION ALL 的方式结合数据。\n\n\n\n这样使得两个SQL可以分别根据自己的条件进行优化，避免全表扫描的出现。\n\n\n避免进行大量的JOIN操作#\n\n大多数情况下，需要的数据会存在两个或多个表中。使用 JOIN\n可以很方便的将多个表中需要的字段数据聚合起来。但是如果JOIN的表过多，数据库引擎会先将各个表根据JOIN条件聚合成一个宽表，然后从中查询。JOIN后表记录数是\n乘积式的增长。\n\n\n\nJOIN的表不易过多，1-2张为易，最近看到一张JOIN了5张表的查询，这样做的原因是想在SQL中查询其它表中的字段的聚合数据。这个时候可以考虑使用子查询进行改\n写：\n\n\n\n如果实在需要其它表的一些字段数据，可以参考前面提到的 批量查询\n的方法，先是几张表进行关联查出基础数据，然后其它表关联查询附加数据，最后在内存中对这些数据进行整合。\n\n如果这样关联的表还是很多，说明数据库设计有问题。\n\n\n总结#\n\n拜拜。:hand:","routePath":"/2018/05/31/optimize-sql-queries-to-improving-the-performance/","lang":"","toc":[{"text":"建立索引","id":"建立索引","depth":2,"charIndex":150},{"text":"使用IN进行批量查询","id":"使用in进行批量查询","depth":2,"charIndex":288},{"text":"避免将不同字段作为条件进行OR查询","id":"避免将不同字段作为条件进行or查询","depth":2,"charIndex":464},{"text":"避免进行大量的JOIN操作","id":"避免进行大量的join操作","depth":2,"charIndex":634},{"text":"总结","id":"总结","depth":2,"charIndex":971}],"domain":"","frontmatter":{"layout":"post","title":"优化SQL查询时候的性能","date":"2018-05-31 21:43:49","categories":["实践"],"tags":["sql","mysql","优化","数据库"]},"version":""},{"id":55,"title":"自定义域名在Github Pages中支持通过HTTPS访问","content":"#\n\n最近Github官方博客上已经宣布自定义域名也支持通过HTTPS进行访问。之前也没想过要弄个HTTPS，借着这个机会就搞一搞HTTPS访问吧。不过都现在了，已经\n过了尝鲜期了。\n\n\n更新域名解析地址#\n\n之前已经将域名访问指向了 192.30.252.153 和\n192.30.252.154，这次要使用最新的HTTPS需要将域名记录指向新的IP地址，官方给出了四组IP地址：\n\n> 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153\n\n我用了顶级域名当做博客的域名，将顶级域名的A记录全部接卸到了以上四个IP地址上。解析规则如下：\n\n\n\nGithub上给出了很详细的说明，可以参考一下如何自定义域名。\n\n\n启用HTTPS域名跳转#\n\n修改域名解析之后根据解析时间的长短，需要几个小时到1天不等的时间来同步DNS解析。这个时候可以去设置里看一看能不能行。\n\n在Github上，打开你存放博客的那个仓库，选择 Settings，在 “GitHub Pages” 下如果可以选中 Enforce HTTPS\n，那么恭喜你已经开启HTTPS解析了。\n\n但大多数情况还是会出现 Unavailable for your site because your domain is not properly\nconfigured to support HTTPS 的提示：\n\n\n\n这个时候需要先清空 Custom Domain 里的设置，保存后重新填入域名，触发一下Github生成页面的机制。如果这时候看到 Not yet\navailable for your site because the certificate has not finished being issued\n的提示，说明再等一段时间，等Github为你的域名签发证书就选中了。\n\n我在这个过程中遇到了一些问题，修改了DNS解析，删除并添加域名好多次都无法成功生成证书。后来发现之前在DNSPod设置了域名解析，于是把上面的解析删除掉。过了一\n天左右，通过在线DNS解析测试，发现所有的域名都已经解析到正确的IP地址上：\n\n\n\n但还是无法选中 Enforce HTTPS ，无奈之下用蹩脚的英语给Github Staff发了邮件，最后Staff大大帮忙解决了问题。\n\n> Hey there,\n> \n> Thanks for reaching out! I just gave your certificate a nudge and you should\n> be all set now.\n> \n> Best, Shawna\n\n可喜可贺，可喜可贺。\n\n\n\n\n检查网站内容#\n\n接下来要做的事情是让网站默认跳转到HTTPS，这里从网上 借鉴 了一段代码代码就可以搞定了：\n\n\n\n由于HTTPS访问中不允许出现http和https链接混用的情况，需要检查你网站中的链接，想办法将http升级到https。\n\n其它的以后再说吧，我先去嘚瑟一下了。:sunglasses:\n\n\n参考内容#\n\n * Custom domains on GitHub Pages gain support for HTTPS\n * Securing your GitHub Pages site with HTTPS\n * Using a custom domain with GitHub Pages\n * Troubleshooting custom domains","routePath":"/2018/05/28/custom-domains-on-github-pages-support-for-https/","lang":"","toc":[{"text":"更新域名解析地址","id":"更新域名解析地址","depth":2,"charIndex":93},{"text":"启用HTTPS域名跳转","id":"启用https域名跳转","depth":2,"charIndex":344},{"text":"检查网站内容","id":"检查网站内容","depth":2,"charIndex":1150},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1306}],"domain":"","frontmatter":{"layout":"post","title":"自定义域名在Github Pages中支持通过HTTPS访问","date":"2018-05-28 21:43:23","categories":["网站"],"tags":["github","https","域名"]},"version":""},{"id":56,"title":"一个处理JavaScript日期的时候出现的问题","content":"#\n\n好久没写博客了，有半年之久了吧。今天就之前遇到的一个bug聊一聊在用JavaScript处理日期的时候出现的一个问题。\n\n代码需要获取startDate和endDate之间的所有间隔的天数，传入的日期格式为 YYYY-MM-DD\n。代码的逻辑很明朗，设置开始时间，给开始时间增加天数，与结束时间相比较，直到多于结束时间为止。当时的代码如下：\n\n\n\n乍一看似乎没什么问题，但是就在今年的1月31日的时候，有人反馈，该代码的功能无法使用，获取的时间列表不正确，并提供了100%复现的方法。就这样开始了纠结的deb\nug之旅。\n\n奇怪的地方有三点：\n\n 1. 触发时间。之前一直正常，偏偏31号的时候使用不正常。\n 2. bug行为。表现是获取的时间列表只出现一个值。\n 3. 凑数用的第三点（忽略掉。。。\n\n最后，还是通过Console的单步Debug找到的问题的所在。原来在修改日期的时候，分别赋值了年、月、日。由于修改不是一次完成，期间就会出现非法日期，浏览器会修\n正这个非法日期。\n\n以今天为2018年1月31日，设置“2017-11-11”为例：\n\n\n\n我写了一个小片段，可以用来单步调试一下上述问题的过程。\n\n解决方案也很简单，只要保证年月日一次赋值进去就可以了，最好直接的方法就是在构造函数里指定要赋值的年月日 new Date(2017, 11, 11) 。\n\n就这样又消灭了一个bug，世界再次和平了。。。:smile_cat:\n\n\n参考内容#\n\n * new Date() set to 31 december 2014 says 1st december instead","routePath":"/2018/05/21/a-plus-one-day-problem-in-javascript/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":625}],"domain":"","frontmatter":{"layout":"post","title":"一个处理JavaScript日期的时候出现的问题","date":"2018-05-21 20:29:53","categories":["问题麻烦"],"tags":["javascript","日期时间"]},"version":""},{"id":57,"title":"制作《求生之路2》喷漆","content":"#\n\n最近比较迷《求生之路2》，不过现在的水平也只能打打普通难度。网上有许多个人的服务器，可以支持多于4人的游戏。游戏人多了就感觉比较有意思了。过程中看到好多人都会往\n墙上或地上画一些个性的图画（或者不可描述的图片），感觉比较有意思。查了查发现制作喷漆也很简单，于是打算动手制作一个。:yum:\n\n\n工具#\n\n已知喷漆的类型有几种：普通贴图喷漆、距离变换喷漆、动图喷漆。喷漆的原理其实只是一帧一帧的图片轮番显示而已。想做一个动图的喷漆。\n\n需要的工具：\n\n 1. vtfedit-主要用来编辑和生成喷漆文件\n 2. ScreenToGif-集屏幕录制和gif编辑于一身的工具\n\n\n制作#\n\n\n来源图片#\n\n喷漆选用的图片当然是最最可爱的日富美了:heart_eyes:，选用了《NEW GAME！！》op中的一段，“轻柔如羽毛”。。。\n\n\n\n这个gif使用ScreenToGif录制。为了缩小体积，修改了图片的大小，只截取了中间正方形的部分。还有删去了几帧，这样的感觉似乎有点鬼畜，不过在游戏中似乎无所\n谓。\n\n\n\n接下来继续使用ScreenToGif将gif的每一帧导成一张图片。这样整个gif就变成了相册集了。\n\n看着有点晃眼:confounded:，快点继续。。。\n\n\n制作喷漆#\n\n按帧导出图片之后，要用vtfedit工具制作喷漆。\n\n\n\n打开VTFEdit软件，选择File->Import...，按住Shitf或Ctrl选择导出图片的所有帧。选择后出现VTF Options对话框。\n\n\n\n导入选项其余的没有要修改的，需要注意调整Clamp大小，为了减少文件体积，这里选择64x64大小的。可以多制作几个选择不同大小测试一下，文件体积尽量保持在100\nkb左右吧。\n\n\n\n导入后点击Play就能播放，播放感觉速度会很快，但是游戏中的速度没有这么快。还有大小也没有看到的这么小，游戏中就感觉很大的样子了。\n\n最后通过File->Save...保存成vtf喷漆文件。\n\n\n导入喷漆#\n\n打开游戏，在主界面选择“选项”->“多人联机”，下面有个“导入喷漆图案...”的菜单。由于游戏对中文支持不够好，喷漆需要放在全英文路径下，文件名也是英文字符即可\n。\n\n导入喷漆后就可以在游戏中使用了。喷漆的快捷键默认是T。\n\n游戏中的效果大概是这样子，感觉还不错。\n\n","routePath":"/2017/09/23/make-left4dead2-spray-paint-from-new-game-op/","lang":"","toc":[{"text":"工具","id":"工具","depth":2,"charIndex":149},{"text":"制作","id":"制作","depth":2,"charIndex":289},{"text":"来源图片","id":"来源图片","depth":3,"charIndex":295},{"text":"制作喷漆","id":"制作喷漆","depth":3,"charIndex":537},{"text":"导入喷漆","id":"导入喷漆","depth":3,"charIndex":839}],"domain":"","frontmatter":{"layout":"post","title":"制作《求生之路2》喷漆","date":"2017-09-23 15:37:59","categories":["游戏人生"],"tags":["游戏","求生之路2","喷漆","newgame","日富美"]},"version":""},{"id":58,"title":"深搜&广搜一二三","content":"#\n\n搜索是一种求解的方法，通常来说就是将所有情况探索一遍，找出其中符合要求的情况作为最后的解。按照生成解的顺序有两种基本的求解顺序：深度优先搜索（Depth-fir\nst Search） 和 广度优先搜索（Breadth-first\nsearch）。关于这两种搜索方式的基本原理不做过多介绍了，下面只说明个人对这两种搜索方式的一些理解。\n\n\n深度优先搜索#\n\n深度优先搜索俗称dfs，核心实现方式是依附于递归。适用于需要求解出所有可能解的问题，在到达问题界限之前会一直递归下去。\n\n\n\n以LeetCode Q46 Permutations例子为例，该题目要求输出一组数字的全排列：\n\n\n\n需要保存的状态有：ans（存储所有的排列）、tmp（到达当前位置遍历过的数字）、nums（数字数组）、visited（数字是否遍历过，防止在一条路径中相同数字遍\n历多次），cnt（当前遍历了多少数字了）。\n\n依靠于递归的深搜大体结构是不会变化的。需要注意的点有：参数记录的状态、过滤掉不可能的状态、状态的保存和还原。\n\n\n广度优先搜索#\n\n广度优先搜索简称bfs，也是通常所说的层级遍历。bfs适用于那些最小或最短问题的求解。核心思想是通过队列或优先队列保存状态，优先选择看似最优的状态进行扩展，已达\n到最先扩展到目标节点的目的。\n\n\n\n模板提供的是一种求解最近、最短解的思路。下面以LeetCode Q102 Binary Tree Level Order\nTraversal为例。该题要求按层次输出树的节点，同一层次的节点放到一个List中。\n\n\n\nbfs主要思路是对下一个状态的选取和状态的遍历，在遍历树的时候，节点会按照层次以此添加到队列中，在处理完一层之后，下一层也自然而然的添加到了队列中。\n\n\n总结#\n\n深度优先搜索和广度优先搜索只是最基本的搜索方式，有句话说，通过搜索可以解决所有的问题。当然在一些解空间很大的问题上，搜索会耗费很多的时间来遍历所有的情况。\n\n为了减少搜索遍历的不必要的路径，出现了很多剪枝或者叫变种方式，通过一些手段尽可能的减少解空间。这些留到以后再慢慢去了解吧。\n\n终于，又水完了一篇博客，开心:joy:。。。","routePath":"/2017/09/11/breadth-first-search-and-depth-first-search-one-two-three/","lang":"","toc":[{"text":"深度优先搜索","id":"深度优先搜索","depth":2,"charIndex":171},{"text":"广度优先搜索","id":"广度优先搜索","depth":2,"charIndex":455},{"text":"总结","id":"总结","depth":2,"charIndex":748}],"domain":"","frontmatter":{"layout":"post","title":"深搜&广搜一二三","date":"2017-09-11 16:12:22","categories":["算法"],"tags":["深搜","广搜"]},"version":""},{"id":59,"title":"用Java实现C++::std中的upper_bound和lower_bound","content":"#\n\nCpp的Std标准库中包含了很多算法，以前写Cpp的时候受益于Std库，确实方便了不少，在Java语言下还是要慢慢适应Java语言的方式。\n\nJava没有迭代器指针这个概念，所以很多内容与C++有所不同。Java中有二分的实现，叫做java.util.Arrays.binarySearch()。使用二\n分的前提是数组必须有序（从小到大）。如果没有排序，那么方法无法确定返回哪个值。对于有序的数组，如果数组中包含多个相同的目标值，方法也无法保证找到的是哪一个。若找\n到了目标值，方法会返回目标值所在的下标；如果没有找到目标值，则方法会返回一个可以插入该值的位置，以负数表示 -(插入点 - 1) 。\n\nC++中也有相应的二分查找函数 std::binary_search 不过该函数返回一个 bool 型表示有没有找到目标值。相对于二分查找，还是更倾向于使用\nstd::lower_bound 和 std::upper_boudn 函数。\n\n\nlower_bound#\n\nlower_bound是找到第一个大于等于value的位置，比如 [1, 2, 3, 3, 3, 4, 7, 8] 查找 3 会返回下标为2的位置，查找 6\n会返回下标为6的位置。如果未找到则返回数组的长度（C++中会返回end()迭代器的位置）。\n\n首先来看std中的一个实现：\n\n\n\n我们照葫芦画瓢，写一个Java的代码：\n\n\n\n由于不确定迭代器是不是随机访问迭代器，C++实现比较保守的使用了 开始位置 和 区间长度\n作为二分的指标。不过Java弱化了迭代器的概念，所以可以将数组的版本精简如下：\n\n\n\n这样我们就得到了一个相对简单的 lower_bound 版本了。\n\n\nupper_bound#\n\nupper_bound 会去寻找大于value的位置，比如 [1, 2, 3, 3, 3, 4, 7, 8] 查找 3 会返回下标为5的位置，查找 6\n会返回下标为6的位置。\n\nstd一种实现如下：\n\n\n\n根据这个实现，我们可以改成以下代码：\n\n\n\n简化版本如下：\n\n\n\n可以发现，这两个函数只有 if 判断那一句不同。\n\n\n总结#\n\nlower_bound 和 upper_bound 的实现借助了 二分查找\n的思想，二分查找很重要的一点就是对_二分区间的舍弃_。举个例子，lower_bound是找到第一个大于等于value的值，那么对于小于等于mid的值要果断舍弃，\n大于mid的值由于可能包含value，需要保守一点。\n\n这两个函数的实现到这里就结束了，而关于二分里的区间舍弃保留问题，有空学习一下，再水一篇吧。\n\n\n参考内容#\n\n * std::upper_bound - cppreference.com\n * std::lower_bound - cppreference.com\n * std::binary_search - cppreference.com","routePath":"/2017/09/08/upper-bound-and-lower-bound-in-java/","lang":"","toc":[{"text":"lower_bound","id":"lower_bound","depth":2,"charIndex":424},{"text":"upper_bound","id":"upper_bound","depth":2,"charIndex":728},{"text":"总结","id":"总结","depth":2,"charIndex":905},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1105}],"domain":"","frontmatter":{"layout":"post","title":"用Java实现C++::std中的upper_bound和lower_bound","date":"2017-09-08 16:30:18","categories":["算法"],"tags":["c/c++","java","upper_bound","lower_bound","算法","二分"]},"version":""},{"id":60,"title":"背景《球球大作战》实现要点","content":"#\n\n很早以前有个游戏叫 agar\n，就是类似大球吃小球的游戏。最近国内在手游上也出现了类似的游戏，比较好的有《球球大作战》和《疯狂贪吃蛇》。对于这两款游戏，不是很感冒，不过还是想把其中的一些内容\n提取出来，做成一个博客背景动画。\n\n从想法到实现花费了大约一天半的时间，具体实现细节可以参考代码，这里只记录一下一些实现难点。\n\n\n游戏引擎#\n\n实现没有用什么游戏引擎，也是自己手写了一个简单的“引擎”，有一个不断通过调用 window.requestAnimationFrame()\n实现自身死循环的函数，在函数内部依次调用“绘画对象”的 update 和 draw 方法，来让对象更新自身和绘制自身。\n\n简化代码如下：\n\n\n\n\n对象管理#\n\n需要被管理的对象放置在一个array里（不知道JavaScript对这类数据结构叫什么），每个对象（Object）都有自己的数据和函数，类似于下面的样子：\n\n\n\nobj 中可以存储对象的私有数值，比如小球的位置（坐标）、小球的大小（半径）、小球的速度、小球的加速度等等。update\n每一帧会被调用一次，可以更新小球的状态。draw 每一帧会被调用一次，之前Canvas画布会被提前清空，这个时候，小球需要重新绘制自己的样式。 isDead\n用于判断当前对象是否还有用，没用的对象会在下个周期被从Array中清理出去。\n\n附一段清理的代码，其实就是从Array中删除元素的代码，我才发现我上个版本的清理代码中有个函数写错了:sweat:。（我把 splice 写成了\nsplit，幸亏上个背景的对象不用被清理。:yum:）\n\n\n\n\n小球#\n\n小球是动画里角色的基本样式，一切行为和绘制都围绕着圆形球来进行。我将小球根据功能划分为三类：球球、食物和刺球。球球 通过吃食物和其它小点的球球来增大自身，食物\n就是被球球吃的，刺球 是作为限制球球无限增长的角色存在的。\n\n小球最基本的定义为：\n\n\n\n不同类型的小球只是其中的一些属性不同，比如，食物和刺球不移动，那么它们的vx和vy都为0（实际上，就没执行这两类的update函数）。\n\n\n\n小球的绘制其实就是在(x, y)坐标的位置画一个radius半径的圆，并填充颜色。\n\n\n碰撞检测#\n\n说到碰撞检测，这里不得不说一下物理上面的知识，小球们的碰撞被分为两种情况：\n\n\n(球球 vs 刺球)#\n\n这类使用的是“碰”策略，两个物体碰到一起就会触发操作。主要判断的思想是两个物体圆心的距离 小于等于 两物体半径之和，这里用公式就是 $dis(o_1, o_2)\n<= r_1 + r_2$。\n\n\n\n\n\n首先保证球球和刺球都是存活的，然后计算球球和刺球圆心的距离，如果距离小于两个小球的半径之和，然后就可以清理掉这两个小球了。\n\n\n(球球 vs 球球) or (球球 vs 食物)#\n\n这类使用的是“包含”策略，当半径大的物体完全包含半径小的物体的时候触发操作。主要判断思想是两个物体圆心的距离 和 小圆半径之和 小于等于\n大圆半径，使用公式描述一下 $dis(o_1, o_2) + r_2 <= r_1$，其中， $r_1>r_2$。\n\n\n\n\n\n首先判断球球是否在保护期，在保护期的球球直接跳过。判断半径的大小，根据半径大小应用上面的公式。\n\n\n刺球绘制#\n\n刺球的绘制单独拿出来说一下，相比球球来说，刺球外面多了一层刺的形状。\n\n\n\n说起刺的形状，就像起伏的山峰一样，说到起伏的山峰，就想到了sin，恩恩。这里把sin的值量化一下，用线连起来就成了山峰的形状了。\n\n\n\n之后怎么将这个“变化”应用到曲面上。我们可以通过 $x=r·cos(a)$ 和 $y=r·sin(a)$\n算出当前角度a在圆周上的点的坐标，但是如何将“变化”应用到坐标上。这里直接想象不太好想象，我们可以理解成半径随着sin的变化而变化，于是，新的半径为\n$r_a=r+b·sin(a)$ ，其中b为一个调整系数常量，绘制坐标公式也为 $x=(r+b·sin(a))·cos(a)$ 和\n$y=(r+b·sin(a))·sin(a)$。\n\n\n\n\n\n\n绘制网格背景#\n\n这个没啥好说的，就是划线，一定间隔划线。话说，如果间隔足够小，那么画的线就变成了面，这就是“线动成面”的原理。\n\n\n\n\n其它#\n\n除了上面说到的那些，还有其它一些细节。比如，给球球设置了一个保护期，主要避免球球碰到刺球分裂的时候，又被自己吃掉了。:dog:这里定义200帧以内为保护期，保护\n期内会禁止碰撞检测，只进行位置更新。比如，刺球对比它小的球球没有效果，可以说是弱者的保护伞呐:umbrella:。还比如，保护期内还给球球画了一个贴心的保护罩罩\n，用的画弧线实现的。哎，字写起来太累，这里就不叙述了。\n\n希望看官们喜欢这次的背景，下次更新还不知道要到啥时候，有空可以移步“秀一秀”看看过去的那些背景。其实最近已经构想了5-6个背景，不过太懒了再加上心情很容易不好，\n有空的时候会一一实现的，感觉还是蛮有意思的。那么最快下月再见了。\n\n祝你的八月天天快乐。:facepunch:","routePath":"/2017/08/03/ball-battle-on-my-blog-background/","lang":"","toc":[{"text":"游戏引擎","id":"游戏引擎","depth":2,"charIndex":164},{"text":"对象管理","id":"对象管理","depth":2,"charIndex":314},{"text":"小球","id":"小球","depth":2,"charIndex":687},{"text":"碰撞检测","id":"碰撞检测","depth":2,"charIndex":932},{"text":"(球球 vs 刺球)","id":"球球-vs-刺球","depth":3,"charIndex":979},{"text":"(球球 vs 球球) or (球球 vs 食物)","id":"球球-vs-球球-or-球球-vs-食物","depth":3,"charIndex":1157},{"text":"刺球绘制","id":"刺球绘制","depth":2,"charIndex":1366},{"text":"绘制网格背景","id":"绘制网格背景","depth":2,"charIndex":1704},{"text":"其它","id":"其它","depth":2,"charIndex":1773}],"domain":"","frontmatter":{"layout":"post","title":"背景《球球大作战》实现要点","date":"2017-08-03 22:48:39","categories":["果然还是前端"],"tags":["canvas","animation","球球大作战"]},"version":""},{"id":61,"title":"从零开始捣鼓一个Electron应用——文件读取","content":"#\n\n今天要实现的一个内容是，选择一个目录，读取目录中的文件，然后把扩展名为 .md 文件的文件名和文件大小列举出来，最后展示在表格中。\n\n\n本篇技术栈和主要技能#\n\n * Vue组件的编写（主要是template，不涉及多个组件传递）\n * 通过electron调用系统原生组件（打开文件对话框）\n * fs和path操作文件（获取文件信息）\n\n\n直接贴代码吧#\n\n下面代码是单个页面的代码，要使用还要在路由文件 route/index.js 中加入路由信息，并在导航栏上添加入口。其它的地方不需要过多的修改。\n\n\n\n\n果然还是要稍微说明一下#\n\n\n打开文件对话框#\n\n通过electron可以调用原生的系统组件，这里需要展示打开文件对话框。require('electron').remote.dialog\n可以引用electron中操作dialog的部分，然后通过dialog.showOpenDialog()函数显示打开文件对话框。在回调函数中可以获取到选择的内容\n。\n\n另外注意的是，electron分为主进程和渲染进程，我们的这些代码是需要执行在渲染进程中的，因此，需要通过remote接口获取主进程的dialog对象。\n\n\nfs列举文件夹内容#\n\nnode提供的fs包可以操作文件和文件夹，fs.readdir(filepath, function(err,\nfile){})给出一个目录filepath，可以在回调函数中获取到文件信息。\n\nfs.statSync()\n可以获取文件的状态信息，这是一个同步方法，有返回值。通过返回的stat对象就可以判断当前文件是不是个文件isFile()，当然如果不是文件就直接忽略过去。sta\nt中的具体内容可以打个log查看一下。\n\n异步方法需要在回调函数里获取函数返回的内容，同步方法直接从函数返回值获取。\n\n\npath文件名路径操作#\n\npath.extname() 获取文件的扩展名，包含点号。\n\npath.join() 可以将两个目录连接起来，连接的方式可以参考命令CD的方式。\n\n\nstyle scoped#\n\n","routePath":"/2017/06/20/start-from-the-very-beginning-for-electron-with-reading-file-state/","lang":"","toc":[{"text":"本篇技术栈和主要技能","id":"本篇技术栈和主要技能","depth":2,"charIndex":70},{"text":"直接贴代码吧","id":"直接贴代码吧","depth":2,"charIndex":174},{"text":"果然还是要稍微说明一下","id":"果然还是要稍微说明一下","depth":2,"charIndex":260},{"text":"打开文件对话框","id":"打开文件对话框","depth":3,"charIndex":275},{"text":"fs列举文件夹内容","id":"fs列举文件夹内容","depth":3,"charIndex":518},{"text":"path文件名路径操作","id":"path文件名路径操作","depth":3,"charIndex":783},{"text":"style scoped","id":"style-scoped","depth":3,"charIndex":872},{"text":"总结一下","id":"总结一下","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"从零开始捣鼓一个Electron应用——文件读取","date":"2017-06-20 23:08:09","categories":["体验Electron"],"tags":["electron","vue","fs","path"]},"version":""},{"id":62,"title":"从零开始捣鼓一个Electron应用——界面组件","content":"#\n\n上一篇捣鼓了一个Electron-vue的脚手架，把Vue的全家桶搭建了一下，也很给面子的跑了起来。接下来就是如何一步一步完成我心中的那个“她”了。\n\n首先先巴拉巴拉自己的技能：\n\n 1. Vue用过，了解Vue的MVVM思想，但是Vue2及其全家桶确实第一次用\n 2. 能写原生JavaScript程序，但是不明白什么是ES5或是ES6，反正就是看心情写了\n 3. React了解一点，但是没有写过，所以Vue2中类似于React的思想也是。。。:joy:\n 4. 总之，不要放弃治疗，从0开始异世界之旅吧。。。\n\n每一篇文章都把自己的思（x）考（度）过程尽量表述出来，在文章开始的时候也会将本篇用到的东西稍微列举一下的。\n\n\n本篇技术栈和主要技能#\n\n本篇先把以下内容整合到一起，然后做一个简单的欢迎页面，之后需要什么再继续补充。\n\n * :outbox_tray:Vue全家桶：vue2 + vuex + vue-router + webpack\n * :rabbit2:网络请求：axios（脚手架里自带，感觉上不会用到网络请求的）\n * :balloon:页面UI：Element-UI（本篇重点就是把它招募进来）、vue-awesome（这不是文章汇总）\n\n\n组件安装#\n\n\n引用Element-UI#\n\nElement-UI的安装文档可以参考这里\n\n通过npm安装\n\n\n\n然后想要完整引入Element，在main.js加入以下几行\n\n\n\n随便测试一下应该就能用了。\n\n\n引入vue-awesome#\n\nvue-awesom 是对 Font Awesome 的一个封装，首先还是通过npm安装\n\n\n\n然后还是在main.js内全局引入\n\n\n\n测试一下肯定也能用。\n\n\n创建布局#\n\n下面开始实现一些功能，首先想在左面加入一个导航栏，用来选取功能，右面显示具体的功能，整个页面大概是这个样子的。\n\n\n\n左边导航栏固定宽度，右边浮动。布局页面 PageFrame.vue 定义导航栏和显示内容的位置\n\n\n\n原入口 App.vue 改为只渲染页面布局，即上面提到的内容。\n\n\n\n别忘了定义一下vue-route，在 route/index.js 下，至于什么是vue-route，照着写就可以了。大体意思是，/home\n载入原先的欢迎页，/sysinfo 输出一下系统信息，如果是其它的就跳转到 /home。这些配置信息可以配合 标签使用，用来转换 标签位置显示的内容。\n\n\n\n其它的页面css和布局稍微调整一下，整个布局就ok了。最后效果页。\n\n\n\n\n问题说明#\n\n\n图标与字体对其问题#\n\n调整一下图标大小，微调一下位置，参考\n\n\n\n\neslint问题#\n\neslint会检查代码格式，所以平时要注意把格式化弄的跟eslint一样，不然每次格式化都会出错。\n\n这里举个例子，通过配置 .eslintrc.js 可以控制检测的选项，比如下面的选项禁用了函数空格的检查，因为一直调不好\n\n\n\n\ntemplate只能有一个根元素#\n\nvue的模板的根元素只能有一个根元素\n\n> Component template should contain exactly one root element\n\n所以只能写\n\n\n\n而不能写成\n\n\n\n\n打包编译#\n\n打包编译可以运行命令\n\n\n\n只发现可以编译成exe文件，无法生成mac上的文件，后来发现在 electron-builder 的文档里发现了，编译只能生成本身平台的文件Multi\nPlatform Build\n\n> Don't expect that you can build app for all platforms on one platform.\n\n算了，其它平台到时候借个电脑编译一下吧。\n\n\n稍微总结一下#\n\n了解了主要的项目结构，初步使用了vue-router相关内容，对于vue组件的编写也有了一定的了解。\n\n不太了解的地方是store的内容，这部分还没有接触到。\n\n然后代码可以上传了。:new_moon:\n\n\n参考内容#\n\n * vue子组件template不能再写子组件了吗 - KingMario的回答 - SegmentFault","routePath":"/2017/06/19/start-from-the-very-beginning-for-electron-with-element-ui-and-icon/","lang":"","toc":[{"text":"本篇技术栈和主要技能","id":"本篇技术栈和主要技能","depth":2,"charIndex":317},{"text":"组件安装","id":"组件安装","depth":2,"charIndex":538},{"text":"引用Element-UI","id":"引用element-ui","depth":3,"charIndex":546},{"text":"引入vue-awesome","id":"引入vue-awesome","depth":3,"charIndex":645},{"text":"创建布局","id":"创建布局","depth":2,"charIndex":743},{"text":"问题说明","id":"问题说明","depth":2,"charIndex":1083},{"text":"图标与字体对其问题","id":"图标与字体对其问题","depth":3,"charIndex":1091},{"text":"eslint问题","id":"eslint问题","depth":3,"charIndex":1126},{"text":"template只能有一个根元素","id":"template只能有一个根元素","depth":3,"charIndex":1253},{"text":"打包编译","id":"打包编译","depth":2,"charIndex":1373},{"text":"稍微总结一下","id":"稍微总结一下","depth":2,"charIndex":1583},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1696}],"domain":"","frontmatter":{"layout":"post","title":"从零开始捣鼓一个Electron应用——界面组件","date":"2017-06-19 21:04:10","categories":["体验Electron"],"tags":["electron","vue","elementui","icon","vueawesome"]},"version":""},{"id":63,"title":"使用electron-vue搭建脚手架","content":"#\n\n是的，最近无聊，打算开个新坑，想用Electron做点东西。涉及前端的东西总是有好多选择，也就有好多组合。\n\n使用Electron，可以使用原生的js写，也可以用babel加点新特性什么。听说可以用React，但是被我否决了，没有基础熟悉起来太麻烦。考虑最近用了Vue，\n决定尝试一些Vue2什么的。\n\n查了一些资料，用SimulatedGREG/electron-vue可以作为初始的一个脚手架。\n\n根据文档一步一步做下来就好：\n\n\n\n没有 yarn 命令可以通过 npm install yarn -g 安装。\n\n首先找目录创建一个项目，出现的信息随便选了选，也不知道这些工具都是干啥的。。。\n\n\n\n最后的步骤使用 npm install 的时候报错了，安装和使用 yarn 就没出现报错的问题。之后运行 yarn 和 yarn run dev 出来如下界面：\n\n\n\n感觉还不错，也支持修改自动加载啥的。。。本来还想试试sass，结果不太懂，还是放弃吧，就这样开坑挺好的:joy:。。。\n\n\n参考内容#\n\n * SimulatedGREG/electron-vue","routePath":"/2017/06/17/get-start-with-vue-and-electron/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":450}],"domain":"","frontmatter":{"layout":"post","title":"使用electron-vue搭建脚手架","date":"2017-06-17 23:51:25","categories":["体验Electron"],"tags":["electron","vue"]},"version":""},{"id":64,"title":"如何以并发方式在同一个流上执行多种操作","content":"#\n\n最近看了《Java8实战》，了解了Java8 Stream的一些内容。在Java 8中，流的一个局限性在于，只能遍历一次，再次遍历的时候会出现异常：\n\n> java.lang.IllegalStateException: stream has already been operated upon or\n> closed\n\n对于这种情况，《Java8实战》附录C给出了一种实现方式，通过 Spliterator 结合 BlockingQueues 和 Futures 来实现这个功能。\n\n\n主要思想#\n\n首先创建一个StreamForker类对当前需要被Fork的Stream进行包装，向StreamForker类中添加的操作由索引来标识，之后可以通过索引来取到该\n操作的结果。\n\n\n\nStreamForker会遍历每个操作，并创建相应的副本，并行的在复制流上执行这些操作，并将最终的结果整合到一个Map中。 Results\n结果定义如下，可以用来获取执行操作的结果。\n\n\n\n下面，说明一下各个部分的实现。\n\n\n复制流#\n\n当我们向StreamForker中添加了N个操作之后，就需要将Stream复制N份，复制N份的操作由 ForkingStreamConsumer 完成。\n\n\n\n这个类实现了Consumer接口和Reuslts接口，并持有queues和actions两个引用。\n\n在这里，每当ForkingStreamConsumer接受流中的一个元素，它就会将该元素添加到所有队列，finish()方法会将最后一个哨兵元素添加到所有队列。\n\nResults接口的get()方法会根据键值取到相应的Future来获取结果，解析并返回。\n\n\n应用操作#\n\nForkingStreamConsumer负责分发元素，还需要一个去处理BlockingQueue里的元素。这里使用 Spliterator\n来完成这个而操作，通过 StreamSupport.stream() 和 Spliterator 的实现可以创建一个新的流。\n\n\n\nSpliterator接口有四个方法需要实现。\n\n 1. tryAdvance() 定义如何顺序遍历每个元素，如果还有需要遍历的元素，返回 true，否则返回\n    false；它从BlockingQueue中取得原始流的元素，这些元素由ForkingStreamConsumer添加，然后依次处理这些元素。直到发现哨\n    兵元素，表示队列中没有需要处理的元素了。\n 2. trySplit() 会将当前元素划分出一部分，返回一个新的Spliterator，同时这两个Spliterator会并行执行。如果无法划分则返回\n    null。\n 3. estimateSize() 用于估算还有多少个元素需要遍历。在这里没有进行估算。\n 4. characteristice() 表示该Spliterator有哪些特性，用于可以更好控制和优化Spliterator的使用。\n\n通过实现的BlockingQueueSpliterator的延迟绑定能力，处理流中的各个元素。\n\n\n框架#\n\n上面两部分都已经实现，下面需要实现一个框架，可以包装Stream，为Stream添加fork操作，并获取操作结果。\n\n\n\nStreamForker的构造方法接收一个流，表示需要被fork的流。通过 fork() 方法可以增加标识和操作。\n\ngetResults() 方法返回 Results 接口的实现，可以通过标识获取操作结果。通过 build()\n构建一个ForkingStreamConsumer，将原始流中的元素挨个分发，最后finish()表示操作结束。\n\nbuild()\n方法用于构建ForkingStreamConsumer，主要创建一个Map，Map的键就是之前的各个操作的标识，值是各个操作的结果，用Futrue来表示。每个F\nuture都是通过 getOperationResult() 创建的。\n\ngetOperationResult() 方法会创建一个新的\nBlockingQueue，并将其添加到队列的列表。这个BlockingQueue用于存储分发的原始流中的元素，然后将队列绑定到BlockingQueueSpl\niterator上用来创建一个新的流，最后创建一个Future来执行需要在这个流上应用的操作。\n\n\n使用#\n\n到此整个StreamForker就完成了，这里我们应用一下，同时求一个整数流的最大值、最小值和平均值。\n\n\n\n使用StreamForker，可以复制一个整数流，并在每个流上应用不同的操作。同时内部实现是异步的，\ngetResults()方法会立即返回，只有当需要取用结果的时候才会尝试等待操作执行完成。\n\n上面代码的输出如下：\n\n> Max Value: 10 Min Value: 1 Avg Value: 5.5\n\n\n参考内容#\n\n * 《Java8实战》附录C\n * ava8里面的java.util.Spliterator接口有什么用？ - SegmentFault","routePath":"/2017/06/07/java8-stream-forker-consumer-framework/","lang":"","toc":[{"text":"主要思想","id":"主要思想","depth":2,"charIndex":247},{"text":"复制流","id":"复制流","depth":2,"charIndex":458},{"text":"应用操作","id":"应用操作","depth":2,"charIndex":725},{"text":"框架","id":"框架","depth":2,"charIndex":1309},{"text":"使用","id":"使用","depth":2,"charIndex":1836},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2052}],"domain":"","frontmatter":{"layout":"post","title":"如何以并发方式在同一个流上执行多种操作","date":"2017-06-07 15:00:58","categories":["读书笔记"],"tags":["java","java8","stream","流","futures","spliterator"]},"version":""},{"id":65,"title":"为网页添加一个网格粒子动画的背景","content":"#\n\n好些日子之前，发现某乎的背景特别漂亮，在某些机缘巧合之下，又在好多地方发现了类似这种“网格粒子”的背景。一种“抄袭之魂”油然而生，对着一篇文章，按照自己的想法实\n现了一下。本来打算顺势改进一下“引擎”，但是整个做下来发现这个“引擎”改进的方向有点偏，导致好多地方很难看懂了。下面将大体的思路说明一下，具体细节可以参考代码或\n者【参考文献】中的文章。\n\n\n粒子运动#\n\n参考物理学的运动，这里每个粒子的运动是独立的，相互之间没有作用力的干扰。在初始化的时候需要给粒子设置初始位置、初始速度、初始速度方向，根据这几个值，就能计算出下\n一步粒子运动的行为。\n\n首先定义一些配置变量：\n\n\n\n然后根据这些变量，可以计算出粒子当前的状态信息：\n\n\n\n更新操作 update ，需要计算出下一帧粒子的位置。如果粒子到达边界，将粒子的该方向上的加速度反向，最后根据加速度更新位置。\n\n\n\n绘制操作 draw， 根据状态信息绘制粒子。\n\n\n\n然后补充上模板代码，粒子基本的运动操作就完成了。\n\n\n划线连接#\n\n上面粒子配置中提到了一个变量 minDistance\n，如果两个粒子之间的距离小于该值，就在这两个粒子之间绘制一条连线。但是单纯绘制连线不太美观，最好根据距离，距离越近连线的颜色越深。\n\n\n\ndistance 的计算使用了亮点之间的距离公式。把这段代码放到 draw 函数内，这样基本上就完成了。\n\n还需要考虑一点，如果窗口大小改变，那么超出边界的粒子可能再也回不来了。这里为监听了 resize\n事件，在resize的时候，如果有粒子超出了窗口范围，那么就将该粒子重新放置到边界位置。\n\n\n\n大概需要注意的地方就这么多了，我把自己实现的代码放到jsfiddle上，可以参考一下。\n\n\n网页背景#\n\n接下来就是要把这个canvas设置为背景的时候了，需要注意一下几点：\n\n 1. Canvas代码加载需要一定的时间，所以最好把定义Canvas的CSS背景颜色和网页背景颜色设为一致\n 2. 要将Canvas充满背景，需要将Canvas的position设为fixed，Canvas的大小也要与窗口大小innerHeight和innerWidt\n    h保持一致\n 3. 监听window的resize事件，做到Canvas大小跟随窗口大小\n\n控制Canvas的CSS，使用fixed控制位置；网页背景与Canvas背景保持一致。\n\n\n\n监听窗口的resize事件，然后修改Canvas大小。\n\n\n\n花了一下午的时间。至此，就为博客换上了一个Canvas背景:tada:。\n\n\n参考内容#\n\n * canvas动画之二 -- 创建动态粒子网格动画 - Sweet oDream","routePath":"/2017/05/29/make-a-animation-of-grid-particle-in-canvas/","lang":"","toc":[{"text":"粒子运动","id":"粒子运动","depth":2,"charIndex":179},{"text":"划线连接","id":"划线连接","depth":2,"charIndex":442},{"text":"网页背景","id":"网页背景","depth":2,"charIndex":742},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1088}],"domain":"","frontmatter":{"layout":"post","title":"为网页添加一个网格粒子动画的背景","date":"2017-05-29 18:26:21","categories":["果然还是前端"],"tags":["canvas","粒子","前端","javascript"]},"version":""},{"id":66,"title":"TSCTF2017线下赛心得体会","content":"#\n\n5月14日举行了TSCTF线下决赛。凭着线上初赛第4的名次，感谢北邮“天枢”战队给了这次机会，有幸能参加这次线下决赛。第一次参加这次攻防性质的线下赛，不免有些不\n知所措，比赛的时候也是走一步看一步。\n\n首先说明一下这次线下赛的比赛规则。这次线下赛共有16支队伍参加，其中校内队有6支初赛队和2支大一新生队，校外队邀请了6支高校队伍参加。比赛共有5道题目，2道We\nb，2道Pwn和1道逆向。其中逆向题由赞助方“深思数盾”提供，逆向题在比赛前2天放出，比赛时提交flag可以多获得3000分初始分。另外4道题都是攻防形式给出，\n各队可以给自己的题目打补丁防御其它队伍的攻击，flag每个5分钟更换一次，每轮被攻击后减20分，每轮check程序检测服务异常减40分。大致规则就是这样。\n\n这次比赛感觉有很大的运气成分在里面，比赛结束后居然拿到了第2的名次，比赛结束后的榜单如下：\n\n\n\n队伍 Nu1L 真的很强，不仅做出了逆向，而且全程无懈可击。\n\n由于自己队伍里没有PWN的选手，比赛之前就打算放弃逆向和PWN。给自己队伍定的目标也是不要太难看，能进前10就可以了。所以之前对于提前放出来的逆向题目也没有太关\n注，感觉挺对不起主办方，毕竟人家给题目放了那么多水。\n\n比赛当天，上午公布1道Web题和2道Pwn题，下午公布最后一道Web题。比赛开始后，先去服务器上将自己的代码备份一下，并开始Review自己Web。第一道Web\n题是主办方用thinkphp自己编写的博客系统，目标是防止获取admin权限从而拿到flag。zoolsher刚上来就发现了一个后台未校验权限的漏洞，导致任何登\n陆用户都可以进入后台。看到这个漏洞后，zoolsher抓紧写自动化脚本，提交其它队的flag，我和另一个队友就手动注册用户记录cookie，并手动抓取几个fla\ng提交一下。上午的时间就是一边使用脚本抓取flag，一边查看其它队伍怎么修补的漏洞，试着改进抓取脚本。有的队伍返回了一个假的flag，被检查程序check\ndown了；有的队伍发现新注册用户就立即删除，于是我们改进每次都新建用户直接登陆抓取；还有些队伍修补了漏洞，这样子就没办法了。\n\n上午3个小时很快就过去了，中午主办方发了盒饭，很好吃。\n\n下午大部分队伍修补了漏洞，这个漏洞价值下降，考虑应该使用新的漏洞了。下午一开始就放出了另一道Web题，是一个cms系统 Drupal，版本是\n7.54。搜索了几个漏洞，感觉都利用不上，考虑了一下暂时放弃了。这时候主办方提到了上传问题，查看了一下可以上传头像放置在\npublic/uploads/images/ 文件夹内。没有校验上传文件的类型，上传文件保存的格式为\n.<上传文件扩展名>.html，接下来就是查找利用位置。找了一圈，在个人主页发现了问题，个人主页渲染使用的模板名是数据库里的值，而数据库里的值可以通过前端表单修\n改，虽然前端使用列表框限定选定的值，但是后台却没有对这个值进行过滤，这就有了利用的机会。\n\n先在自己的服务器上实验一下，thinkphp的模板支持执行php代码，于是构造了一个上传文件\n\n\n\n渲染的模板不能有其它扩展名，于是这个上传文件不能有扩展名，需要上传的文件存为 avatar ，这样上传后的文件就变成了 ..html，正好可以进行渲染。\n\n总体的步骤如下：\n\n 1. 注册用户\n 2. 登陆，修改上传修改个人头像\n 3. 获取当前用户ID和上传头像的文件名\n 4. 修改个人主页的模板为上传的头像位置 ../../../../../public/uploads/images/<头像名>，不带.html\n 5. 根据用户ID访问个人主页，拿到flag\n 6. 将flag上传\n 7. 将模板修改为 default ，防止在数据库里太明显（太坏了）\n\n一切都测试好之后才开始正式使用，除了第一的 Nu1L ，真是打的其它队一个措手不及。靠着这个漏洞又赚了一波分数。\n\n下午5个小时就研究了一下这个漏洞。\n\n比赛总体下来，我们的Pwn次次被打，而且还down过几次，打了也没办法，down只好乖乖把备份传上去整好。真是别人去你家偷东西你还不能还手，门搞坏了也要默默弄好\n让别人下次接着偷:imp:。下午还发现了一个内存马，杀掉除root以外的apache进程就可以了，sudo -u www-data kill -9\n<进程号>，不过杀了一次后他们没有攻第二次，看来他们的洞利用起来有些麻烦，估计是手动的。\n\n整个比赛下来收获很多，一方面见识了一下强队的风采，另一方面也加深了对CTF的了解。真的感谢 Nu1L 队没有与我们争 Web1\n的分数，不然总分肯定会下降不少:joy:。最后感谢TSCTF2017主办方“天枢”战队和赞助方“深思数盾”。","routePath":"/2017/05/20/tsctf-2017-offline-final-contest/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"TSCTF2017线下赛心得体会","date":"2017-05-20 23:38:26","categories":["读书笔记"],"tags":["tsctf","ctf","决赛","新建文件夹"]},"version":""},{"id":67,"title":"TSCTF2017线上初赛WriteUp","content":"\nCongratulations!\n\nYou got the flag. Interesting regex, right?.\n\nTSCTF{h4pp9_enj0y_re93x_T0_3x3c__!!!}","routePath":"/2017/05/15/tsctf-2017-online-contest-write-up/","lang":"","toc":[{"text":"【MISC】签到","id":"misc签到","depth":2,"charIndex":-1},{"text":"【MISC】logo","id":"misclogo","depth":2,"charIndex":-1},{"text":"【MISC】zipcrc","id":"misczipcrc","depth":2,"charIndex":-1},{"text":"【MISC】至尊宝","id":"misc至尊宝","depth":2,"charIndex":-1},{"text":"【MISC】easyCrypto","id":"misceasycrypto","depth":2,"charIndex":-1},{"text":"【MISC】神秘的文件","id":"misc神秘的文件","depth":2,"charIndex":-1},{"text":"【MISC】四维码","id":"misc四维码","depth":2,"charIndex":-1},{"text":"【WEB】Web","id":"webweb","depth":2,"charIndex":-1},{"text":"【WEB】Simple Shop1","id":"websimple-shop1","depth":2,"charIndex":-1},{"text":"【WEB】Simple Shop2","id":"websimple-shop2","depth":2,"charIndex":-1},{"text":"【Coding】小明的二进制","id":"coding小明的二进制","depth":2,"charIndex":-1},{"text":"【Coding】泽哥的算术","id":"coding泽哥的算术","depth":2,"charIndex":-1},{"text":"【Coding】Las Vegas","id":"codinglas-vegas","depth":2,"charIndex":-1},{"text":"【Coding】修路","id":"coding修路","depth":2,"charIndex":-1},{"text":"【REVERSE&APK】checkin","id":"reverseapkcheckin","depth":2,"charIndex":-1},{"text":"【REVERSE&APK】take it easy","id":"reverseapktake-it-easy","depth":2,"charIndex":-1},{"text":"【REVERSE&APK】baby_android","id":"reverseapkbaby_android","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"TSCTF2017线上初赛WriteUp","date":"2017-05-15 11:10:58","categories":["读书笔记"],"tags":["tsctf","ctf","比赛","writeup","结题报告","新建文件夹"]},"version":""},{"id":68,"title":"数字电路与Minecraft中的红石电路","content":"#\n\nMinecraft中有很多吸引人的地方，其中一个就是红石电路系统。有牛人就用游戏的红石电路制作了8位计算器、数字显示器等等。\n\n前几天看到了LeetCode上面的一道题目，对，就是那道用数字电路解法的题目。看完之后心血来潮，想着用Minecraft的红石电路弄一遍，一定会非常 COOL\n~。:cool:\n\n\n温习功课#\n\n好吧，数字电路的内容大多数已经忘记，所以先温习一下吧，对应在Minecraft中的表现形式也一并展示出来。\n\n\n与或非门#\n\n先从基本的与或非门开始。这三种逻辑电路的真值表如下：\n\nA B     真 真   真 假   假 真   假 假\nA+B 或   真     真     真     假\nAB 与    真     假     假     假\n~A 非    假     假     真     真\n\n非门（即“反相器”）的输入与输出相反。输入为1的时候输出为0，输入为0的时候输出为1。在Mincraft中可以使用红石火把的阻断特性来制作。红石火把默认输出信号\n，当有输入信号（如拉杆）的时候，红石火把会熄灭。由此与非门的特性一致。\n\n\n\n或门的任意一个输入为1，输出就会是1。或门有两个输入端，一个输出端。根据红石火把的特性，任意一个输入端为1的时候，输出端都为0，这正好与或门的输出相反。这更像一\n个或非门，于是，在最后再加上一个非门就变成我们需要的或门了。\n\n\n\n与门只有当两个输入都为1的时候，输出才会是1。根据或门的思路，从逻辑公式推演$AB=\\overline{\\overline{AB}}=\\overline{\\ov\nerline{A}+\\overline{B}}$，可能看推演公式看不出什么，但是看电路就会明白了。\n\n\n\n\n触发器#\n\n触发器是记忆电路相关的内容。上面提到的门电路的输出只与当前的输入有关，但有时候电路还需要“过去的输入”相关，也就是有记忆功能。完成这个功能的电路有锁存器和触发器\n。在现实生活中的电子学中，锁存器指对输入信号的某个状态产生反应的电路；触发器指对输入信号的变化产生反应的电路。\n\n最基本的是RS触发器，RS触发器有三种模式：置0、置1和保持。\n\n\n\n一般常用的是精简的版本。\n\n\n\nRS触发器存在禁止条件，R和S不能同时为1。这给使用者带来的不便。简单变化就是D触发器。关于D触发器有好多种实现方法，这里从记忆电路 - Minecraft\nWiki上找到了一个D寄存器简化的版本。\n\n\n\n图例在这里红石图例。根据图可以构造一个简单的D寄存器。D触发器在CP=1的作用下将D端的输入数据送给触发器，当CP=0时Q(n+1)=Q(n)不变，故常用作锁存\n器，因此D触发器又称为D锁存器。\n\n\n\n请无视入镜的史莱姆同志。。。\n\n需要的内容大概就这些了，下面开始开工。\n\n\n开工#\n\n了解了一些基础内容之后，需要制作我们的三进制加法计算器了。根据LeetCode Q137 Single Number II的数电AC方法中推导的公式：\n\n$F_1=X\\overline{Z}+YZ$ $F_2=Y\\overline{Z}+\\overline{X}\\overline{Y}Z$\n\n分析一下，需要两个寄存器存储高位和低位，还需要一个按钮触发+1操作，最后需要一个显示的地方。这里只制作一个简单的 半加器\n，变换的顺序为00->01->10->00。不考虑进位的情况。\n\n制作的步骤是，先放置输入端，然后再放置两个D触发器，最后将与或非门填充进去。最后的效果就是这个样子。\n\n\n\n没有电路精简，真是不忍直视呀。在制作的时候遇到了一些问题：\n\n 1. 电路重叠的时候，下层的红石火把很可能影响上层的电路；\n 2. 由于电路传输有时间间隔，很容易造成信号跳动，两个D触发器变动不一致的话很容易互相影响，出现结果不一致的情况。\n\n对于第二个问题，没有找到一个好的解决方法，之好将两个触发器输出的延迟调高一些。从10->00的过程中出现的11的情况，最后的效果还是挺满意的吧。:joy:\n\n\n\n就这样吧，一天又过去了。。。\n\n\n参考内容#\n\n * 红石电路 - Minecraft Wiki\n * 用minecraft实现几种基本的触发器_红石电路吧_百度贴吧\n * 红石电路--从入门到精通 全图文解说 （不定期更新）_minecraft吧_百度贴吧","routePath":"/2017/05/05/digital-circuits-and-redstone-circuits-in-minecraft/","lang":"","toc":[{"text":"温习功课","id":"温习功课","depth":2,"charIndex":157},{"text":"与或非门","id":"与或非门","depth":3,"charIndex":220},{"text":"触发器","id":"触发器","depth":3,"charIndex":740},{"text":"开工","id":"开工","depth":2,"charIndex":1177},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1697}],"domain":"","frontmatter":{"layout":"post","title":"数字电路与Minecraft中的红石电路","date":"2017-05-05 14:56:19","categories":["游戏人生"],"tags":["minecraft","数字电路","红石电路"]},"version":""},{"id":69,"title":"如何在Java中正确的终止一个线程","content":"#\n\n\n含有死循环的线程是无法知道自己该什么时候结束的#\n\n一个工作线程需要不断接受外部的消息，这样的线程内部通常有一个死循环 while(true){}\n。因为死循环的存在，该线程自己无法知道何时才能停止循环，只能通过外部线程通知该线程的结束。\n\n要结束一个线程，Thread里有一个 stop()\n方法可以粗暴的杀死一个线程。这样做会出现一些问题，被结束的线程会被立即停止，没有时间处理一些善后工作。在多线程环境下，就可能会出现数据不一致的问题，这是非常危险\n的。因此，stop() 方法被置为_弃用_方法。\n\n那么如何才能更好的结束一个线程？\n\n\n这里有两种方法可以让外部线程结束一个线程#\n\n我们需要给线程处理善后工作的机会，一般来说就是给线程一个信号，希望线程能尽快完善工作，然后跳出死循环。\n\n\n设置标记变量#\n\n在线程工作之余，检查标记变量，如果标记变量被改变，则自行中断退出。\n\n\n\n这里增加一个volatile标注的变量isStop来记录是否需要结束线程，run()中的死循环也由isStop变量操控。通过调用stopMe()方法改变变量的值\n，使死循环可以自行退出。\n\n\n捕获线程中断#\n\n关于线程中断有Thread中有几个方法：\n\n\n\n通过Thread.interrupt()方法可以设置一个线程的中断位，线程通过检查中断位来自行进行中断操作。\n\n\n\n需要注意的是一些阻塞方法像sleep()等会清除中断标志，所以在catch的时候需要重新设置一下中断标志。\n\n\n太忙的线程无法及时听到撤退的号角#\n\n如果线程阻塞在一个事件上，那么给线程发送关闭消息，线程也无法及时的收到，只能等到事件出现，线程退出阻塞状态的时候才能接着进行下一步操作。\n\n对于这种情况，起初也没有好的方法，于是就假想了一下：可以在通知线程关闭的时候，发送一个_假_的事件，让线程强行退出阻塞状态。但是这种使用假事件的方式很容易造成系\n统“混乱”，不是一个很好的方法。\n\n如果一个线程阻塞在Socket通信上，可以在另一个线程上调用这个Socket的close()方法，这样会使其抛出SocketException而退出。官方文档没\n有提到这种方法，可以用来做个参考。\n\n一个比较好的思路就是，改阻塞为非阻塞，这样线程就有足够的机会捕获到关闭消息。比如用NIO包中的Channel来管理Socket。\n\n以ZMQ为例，通过ZMQ.Poller轮询避免阻塞的发生。以下代码是官方的示例：\n\n\n\n总的来说，尽量通知线程自己去结束自己的任务，由此可以尽量避免一些意外情况的发生。\n\n\n参考内容#\n\n * multithreading - How to properly stop the Thread in Java? - Stack Overflow\n * Multiple socket poller in Java\n * How can I interrupt a ServerSocket accept() method?","routePath":"/2017/04/28/how-to-properly-stop-a-thread-in-java/","lang":"","toc":[{"text":"含有死循环的线程是无法知道自己该什么时候结束的","id":"含有死循环的线程是无法知道自己该什么时候结束的","depth":2,"charIndex":3},{"text":"这里有两种方法可以让外部线程结束一个线程","id":"这里有两种方法可以让外部线程结束一个线程","depth":2,"charIndex":276},{"text":"设置标记变量","id":"设置标记变量","depth":2,"charIndex":353},{"text":"捕获线程中断","id":"捕获线程中断","depth":3,"charIndex":495},{"text":"太忙的线程无法及时听到撤退的号角","id":"太忙的线程无法及时听到撤退的号角","depth":2,"charIndex":642},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1083}],"domain":"","frontmatter":{"layout":"post","title":"如何在Java中正确的终止一个线程","date":"2017-04-28 20:55:14","categories":["编程语言"],"tags":["java","thread","线程"]},"version":""},{"id":70,"title":"LeetCode Q137 Single Number II的数电AC方法","content":"#\n\n最近突然在LeetCode上刷起了题目，Q137题和好久之前做过的数组中只出现过一次的元素类似。一个数组中有一些整数，这些数要不出现3次，要不只出现1次，并且出\n现1次的数字只有一个，找出那个出现一次的数字。\n\n\n朴素的解法#\n\n根据之前的思路，可以弄一个大小32的数组，将数字对应的二进制位累计到对应的数组中，对数组模3后，剩下的数字就是只出现一次的数字。\n\n\n\n这个思路很好理解，也顺利解决了问题，但是在看其他人的解法时发现了一种奇特的解法：\n\n\n\n完全无法理解:scream:。。。经过舍友的指点，原来灵感来自 数字电路\n的范畴。本科期间也学过一些数字电路的知识，现在大部分已经还给老师了，根据记忆稍微弄一弄吧。\n\n\n模型抽象——三进制加法#\n\n分析问题，原问题可以抽象成一个三进制的加法。有三个状态，保证累加到3个数字后可以抵消掉变为0，于是可以得到如下的状态转移图：\n\n\n\n这个状态的图的状态不需要化简，现在为其分配状态值。共有三个状态，需要2位表示。\n\n> A -- 00 B -- 01 C -- 10\n\n根据状态转移图，画出状态转移表。\n\n\n\n按位拆分状态转移表，通过卡诺图，化简表达式。\n\n这个卡诺图是按照高位画出的：\n\n\n\n同理，低位的同样画出：\n\n\n\n将相邻的“1”用红圈圈出，写出表达式：$F_1$表示高位， $F_2$表示低位。\n\n$F_1=X\\overline{Z}+YZ$ $F_2=Y\\overline{Z}+\\overline{X}\\overline{Y}Z$\n\n不容易，一步一百度，终于搞出了这个式子了。\n\n\n程序编写#\n\n根据上面得到的两个表达式，可以写出以下的程序：\n\n高位用变量a表示表达式中的X，低位用变量b表示表达式中的Y，输入Z就是数组中的数字了。\n\n\n\n提交测试一下，AC了。。。又解决了一个题目，可喜可贺:stuck_out_tongue:。。。","routePath":"/2017/04/27/single-number-ii-solved-using-circult-design-and-digital-logic/","lang":"","toc":[{"text":"朴素的解法","id":"朴素的解法","depth":2,"charIndex":109},{"text":"模型抽象——三进制加法","id":"模型抽象三进制加法","depth":2,"charIndex":314},{"text":"程序编写","id":"程序编写","depth":2,"charIndex":675}],"domain":"","frontmatter":{"layout":"post","title":"LeetCode Q137 Single Number II的数电AC方法","date":"2017-04-27 16:38:25","categories":["算法"],"tags":["面试","算法","数字电路"]},"version":""},{"id":71,"title":"博客添加渐变效果出现的fixed问题","content":"博客添加渐变效果出现的fixed问题#\n\n最近特别喜欢某些博客的渐变加载效果，于是就照着制作了一个，感觉还可以。\n\n\n渐变效果#\n\n首先分析一下本博客模板的页面结构，主要分为三行。\n\n> #header 标题栏 #layout 正文内容 #footer 底部信息\n\n主要思路是当页面加载完毕后，根据延迟给相应的位置加上 loaded class属性。\n\n\n\n然后在css中声明之前的样式为 透明度0,向上偏移20px，加载完成 loaded 的样式为 透明度1,偏移还原。\n\n\n\n刷新一下就可以看到效果了。\n\n\nfixed问题#\n\n之后在调试post页面的时候，发现右侧 文章目录 位置没有出现在最右面，而是出现在了 #layout 的里面。\n\n在调试了一段时间后发现是 transform css属性的问题，在控制台中去掉该属性后文章目录的行为表现的很正常。查询博文发现这个问题很正常，主要是因为\ntransform 属性的动画行为会影响 fixed 的定位，使其不再基于 viewport 定位。\n\n在尝试了几个方法后，都没有很好的解决这个问题:disappointed:。只好出此下策，将 文章目录 整个弄到与 #header,#layout,#footer\n同级，然后在模板里加入判断条件只有是 post 页面才渲染目录部分。也算解决了这个问题了:tada:。\n\n\n参考内容#\n\n * Transform 属性会导致子元素的 fixed 属性失效 | 潜行者m","routePath":"/2017/04/20/un-fixing-fixed-elements-with-css-transforms/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":586}],"domain":"","frontmatter":{"layout":"post","title":"博客添加渐变效果出现的fixed问题","date":"2017-04-20 23:18:11","categories":["果然还是前端"],"tags":["css","fixed","transforms"]},"version":""},{"id":72,"title":"使用Docker构建PHP+MySQL开发测试环境","content":"#\n\n> 最近强行弄了一份工作，为一个基于ThinkPHP框架的网站添加一点需求功能。于是想着用Docker弄一个开发测试的环境。在配置过程中，遇到了很多的问题，靠着\n> 搜索才一步一步的解决了。\n\n\n基础镜像的选用#\n\nDocker中大多数镜像都是基于Ubuntu基础镜像进行了修改构建，但是如果我们也从Ubuntu开始构建，那么工作量可想而知。因此选取一个合适的基础镜像可以加快\n配置速度，也能减少我们配置的工作量。\n\n根据需要，选取了PHP和MySQL两个镜像作为本次开发环境配置的基础镜像。\n\n\n\n另外说明一下，php的镜像有好多版本，具体版本可以参考DockerHub上面的说明。这里选用的版本是PHP7.0运行在apache上的版本。\n\n\n启动一个MySQL容器#\n\nMySQL作为公共的基础服务，这里配置的MySQL不仅可以供PHP内部使用，也可以在外部连接查询里面的数据。\n\n\n\n以守护进程-d的模式启动一个名为--name\nmysql的容器，将d:/DockerData/mysql映射到/var/lib/mysql目录上提供数据存储，配置环境变量MYSQL_ROOT_PASSWOR\nD=123456设置root密码为123456，映射端口3306。可以根据实际需要修改命令行的一些参数。\n\n\n启动一个PHP容器#\n\nPHP容器需要指定/var/www/html目录的位置，为了能使用数据库，还需要链接当上面的MySQL容器。\n\n\n\n--link将上面的mysql容器作为db组件链接到该容器中，由于ThinkPHP的特性，这里在/var/www和/var/www/html分别挂载了目录。这里\n在外部使用81端口。\n\n\n配置PHP容器组件#\n\n默认的PHP容器里还缺少一些PHP插件，需要手动进行安装。\n\n\n进入PHP容器#\n\n在PHP容器中执行bash命令，就可以在里面输入命令行了。由于PHP容器的主进程是Apache，所以不能通过docker attach的方式附加到容器上。\n\n\n\n以下命令都要在容器的bash里执行。\n\n编辑文件的时候发现没有vim，只好安装一个\n\n\n\n\n配置ThinkPHP的URL重写#\n\n配置ThinkPHP的URL重写分两步，开启重写扩展，修改配置文件。\n\n\n\n\n安装PHP的PDO、GD等组件#\n\n普通情况下，可以通过apt安装PHP的PDO插件，但是由于PHP镜像中没有make和gcc等编译器。其实，官方在容器的 \\usr\\local\\bin\n目录下提供了一些命令，用来编译启用PHP的组件。\n\n\n\n直接运行./docker-php-ext-install可以看到命令能安装的组件。\n\n安装pdo_mysql组件\n\n\n\n安装gd图形库组件，gd图像库依赖比较多的内容，其实也就是执行的命令稍微麻烦些。先要安装一些依赖库，然后编译安装gd组件。\n\n\n\n\n查看MySQL数据库地址#\n\n在容器中访问127.0.0.1:3306发现找不到MySQL数据库，数据库的地址发生了改变。可以通过环境变量查看MySQL的地址。\n\n\n\n在容器中执行env命令，发现数据库在172.17.0.2:3306，成功访问到数据库。\n\n因为之前已经把数据库的端口映射到宿主机的3306端口上，所以在宿主机连接数据库的时候，可以使用127.0.0.1:3306地址。\n\n\n重启容器#\n\n配置完成后记得重启容器。在宿主机执行命令：\n\n\n\n\n其它#\n\n第一次，也算在容器内部手动配置了一下容器。以后有机会，可以尝试使用Dockerfile构建需要的镜像了。\n\n\n参考内容#\n\n * docker官方alpine/php镜像下安装php扩展 - TinyJian's Blog\n * freetype - PHP Fatal error: Call to undefined function imagettftext() - Stack\n   Overflow","routePath":"/2017/03/21/use-docker-to-build-php-and-mysql-development-environment/","lang":"","toc":[{"text":"基础镜像的选用","id":"基础镜像的选用","depth":2,"charIndex":100},{"text":"启动一个MySQL容器","id":"启动一个mysql容器","depth":2,"charIndex":325},{"text":"启动一个PHP容器","id":"启动一个php容器","depth":2,"charIndex":556},{"text":"配置PHP容器组件","id":"配置php容器组件","depth":2,"charIndex":720},{"text":"进入PHP容器","id":"进入php容器","depth":3,"charIndex":764},{"text":"配置ThinkPHP的URL重写","id":"配置thinkphp的url重写","depth":3,"charIndex":901},{"text":"安装PHP的PDO、GD等组件","id":"安装php的pdogd等组件","depth":3,"charIndex":959},{"text":"查看MySQL数据库地址","id":"查看mysql数据库地址","depth":3,"charIndex":1206},{"text":"重启容器","id":"重启容器","depth":3,"charIndex":1402},{"text":"其它","id":"其它","depth":2,"charIndex":1435},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1495}],"domain":"","frontmatter":{"layout":"post","title":"使用Docker构建PHP+MySQL开发测试环境","date":"2017-03-21 11:18:52","categories":["Docker"],"tags":["docker","php","mysql","开发测试"]},"version":""},{"id":73,"title":"人人都懂的Docker简明教程","content":"#\n\n很早之前就听过 Docker ，前几天写一个程序的时候想要用 mongo ，于是就想不如从 Docker 里弄一个吧，于是就这样跌跌撞撞的走上了 使用\nDocker之路。\n\n本文不对Docker做深入的了解，只是根据实际使用中遇到的情况，所谓遇到什么问题解决什么问题。\n\n另，本文为Windows下使用Docker，如果你使用其它操作系统请谷歌其它文章。\n\n\n什么是Docker#\n\n一般一个事务，都要按照“是什么”、“为什么”、“怎么用”的角度来说明，但是至于 Docker是什么这个问题\n，我的理解Docker就是一个很大的软件仓库，可以从里面下载别人做好的软件来使用。\n\n但是，Docker是一个生态，不可能几句话说清楚，而且Docker生态里大部分内容都是平常用不到的。\n\n\n教练，我想用Docker#\n\n如何使用Docker？4步走。下载Docker安装，下载镜像，从镜像构建容器，关闭容器及再次运行容器。这里有两个名词 镜像 和\n容器，这里先不做解释。根据顺序先从下载Docker开始。\n\n\n下载Docker#\n\n打开Docker的官网TODO，这是我们遇到的第一个难题，应该如何下载Docker软件？\n\n由于Docker的运行需要借助Linux的内核，所以Windows不得不通过虚拟机来虚拟Linux的内核。根据虚拟机来分有两个派别 Hyper-V派 和\nVirtualBox派。下面这个表格帮助你选择需要安装的Docker版本。\n\n#            HYPER-V                VIRTUALBOX\nDocker代表软件   Docker for Windows     Docker Toolbox\n试用版本         Windows8以上，Hyper-V支持   Virtualbox软件支持\n其它软件         VS Android Emulator    Genymotion\n\n鱼和熊掌不能兼得，在Windows中不能同时使用Hyper-V和Virtualbox，强行使用会出现“绿屏”错误。如果不能割舍基于Virtualbox的模拟器（\n如Genymotion Android模拟器），可以通过启动菜单切换是否在系统中启用Hyper-V虚拟化功能。\n\n\n下载镜像#\n\n选定好了Docker的版本，就需要使用Docker了。先从Docker最基本的镜像开始。\n\n镜像 是Docker里“软件”传播的一种媒介，通过镜像可以将构建的环境封装起来然后在另一台电脑上部署。\n\nDocker有一个专门的镜像应用市场叫Docker Hub，在其中可以浏览Docker查找其它人构建的镜像，并将其下载下来使用。Docker下载镜像有几种方式：\n\ndocker pull#\n\ndocker pull 是docker的一个子命令，只需向命令提供组织名/镜像名，docker就会自动将镜像下载到本地。如，下载mysql的镜像。\n\n首先从Docker Hub上查找mysql镜像的名称，然后执行docker\npull命令，等待一段时候后mysql镜像就会下载到docker的环境中，等待的时间取决于你的网速。\n\n\n\n通过 docker image 可以查看当前已经下载过的镜像。\n\n\n\ndocker镜像管理 GUI#\n\n照顾一些不会使用命令行的人士，docker也有一些GUI管理工具，官方提供的是 Kitematic。\n\n\n\n使用Kitematic需要注册一个Docker Hub账号，由此可以浏览Docker Hub上的镜像，下载并运行这些镜像。\n\n镜像到容器#\n\n容器是由镜像构建而成的运行环境。如果把镜像比作光盘，容器就是光盘里媒体运行的一系列环境。接下来，要运行我们的第一个容器。从镜像执行容器需要的命令参数可以从Doc\nker Hub相应镜像的页面说明里查到，这里以mysql为例：\n\n\n\n这个命令表示通过mysql镜像生成一个Docker容器。-d 表示以守护进程的方式执行； --name\n指定该容器的名字，供下次继续使用，如果没有指定名字，docker会自动生成一个； -p 表示映射端口，将容器内的3306映射到宿主机的3306端口上；-v\n表示硬盘存储映射，将容器内的_/var/lib/mysql_目录映射到_d:/DockerData/mysql_； -e 主要为容器的运行提供一些环境变量。\n\n运行中的容器可以使用 docker ps 查看，docker ps -a 可以查看所有创建过的容器。\n\n\n\n如此，就创建了一个运行了mysql的容器，并且可以通过本机的3306连接到这个容器。\n\n\n\n这里使用了 docker run 的命令，不同的镜像有不同的启动方式，可以使用 docker help 或 Docker官方文档 来了解 docker run\n详细的使用说明。\n\n\n再次运行容器#\n\n每次执行 docker run\n都会生成一个新容器，新生成的容器与原本运行的容器完全独立。如果需要之前运行的某个容器，通过容器的NAMES可以操作容器的启动和关闭。这里用到的两个命令是\ndocker start 和 docker stop 。\n\n要操作容器需要知道被操作容器的名字，这个名字在创建容器的时候通过 --name 参数指定，如果忘记了也可以通过 docker ps -a\n查看所有容器，从中找出要操作的容器。\n\n比如要启动和关闭上面创建的mysql容器，只需要执行 docker start mysql 和 docker stop mysql 即可。\n\n\n其它一些废话#\n\nDocker在镜像仓库的协助下变得非常简单易用，通过下载其他人制作的镜像，可以快速创建和使用我们需要的容器。镜像仓库中的镜像有的时候可能不满足我们的需求，这时候\n可以通过自定义方式来创建容器，然后将其编译成镜像供他人使用。\n\n推荐一本书《第一本Docker书》，看过前面部分的感受就是通过例子讲解Docker的一些部分。如果将Docker的一些概念理清楚了，那么Docker就算是入门了\n。","routePath":"/2017/02/15/universal-docker-introductory-tutorial/","lang":"","toc":[{"text":"什么是Docker","id":"什么是docker","depth":2,"charIndex":182},{"text":"教练，我想用Docker","id":"教练我想用docker","depth":2,"charIndex":344},{"text":"下载Docker","id":"下载docker","depth":3,"charIndex":454},{"text":"下载镜像","id":"下载镜像","depth":3,"charIndex":963},{"text":"docker pull","id":"docker-pull","depth":4,"charIndex":1151},{"text":"docker镜像管理 GUI","id":"docker镜像管理-gui","depth":4,"charIndex":1367},{"text":"镜像到容器","id":"镜像到容器","depth":4,"charIndex":1501},{"text":"再次运行容器","id":"再次运行容器","depth":3,"charIndex":2026},{"text":"其它一些废话","id":"其它一些废话","depth":2,"charIndex":2319}],"domain":"","frontmatter":{"layout":"post","title":"人人都懂的Docker简明教程","date":"2017-02-15 16:06:26","categories":["Docker"],"tags":["docker","教程"]},"version":""},{"id":74,"title":"通过启动项启用关闭Hyper-V功能","content":"#\n\n俗话说，鱼和熊掌不能兼得。最近在考虑使用Docker for Windows的问题。Docker for\nWindows使用了Hyper-V的虚拟化技术进行支持，Hyper-V与VirtualBox不能同时使用（同时启动虚拟机会出现“绿屏”）。考虑到Virtualb\nox在其它方面可能还会用到。一篇文章上可以通过修改 启动菜单 启动和关闭Hyper-V的特性。\n\n\n复制菜单项#\n\n通过管理员权限启动命令提示符。复制当前的启动菜单：\n\n\n\n那一串字符就是新菜单项的标识符，然后为新菜单项关闭hyperv的特性\n\n\n\n{7c8aaa03-b86b-11e6-9c55-c095c1c59faa} 需要与第一条命令中显示的相对应。\n\n\n使用菜单项#\n\n从 Windows 8 开始，一般电脑都启用了 快速启动\n的特性，这样虽然加快了启动速度，但却无法方便的选择启动菜单。而且在快速启动模式下，Windows没有真正关机，通过重启可以让Windows真正关机并从新启动。如\n何使用上面新建的菜单项？\n\n大体步骤是：正常进入系统后，重启选择“No Hyper-V”启动菜单，进入未启用Hyper-V模式。\n\n在选择重启计算机之前先长按Shift，然后再点击重启菜单\n\n\n\n等待系统进入蓝色屏幕的启动菜单。选择“使用其他操作系统”，接下来选择上面创建的“No Hyper-V”启动菜单。\n\n\n\n\n\n等待系统重启进入系统之后，Hyper-V就被关闭，可以使用Virtualbox了。比如Genymotion模拟器，虚拟机里的操作系统等。\n\n\n参考内容#\n\n * Switch easily between VirtualBox and Hyper-V with a BCDEdit boot Entry in\n   Windows 8.1 - Scott Hanselman","routePath":"/2017/02/12/switch-hyperv-on-and-off-with-a-bcdedit-boot-entry/","lang":"","toc":[{"text":"复制菜单项","id":"复制菜单项","depth":2,"charIndex":186},{"text":"使用菜单项","id":"使用菜单项","depth":2,"charIndex":319},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":668}],"domain":"","frontmatter":{"layout":"post","title":"通过启动项启用关闭Hyper-V功能","date":"2017-02-12 15:02:21","categories":["高效生活"],"tags":["windows","hyper-v","bcdedit"]},"version":""},{"id":75,"title":"修正双系统Windows和Ubuntu时间不同步","content":"#\n\n每次使用Ubuntu的时候，回到Windows之后时间总会慢8个小时。原因是Ubuntu认为CMOS时间是格林威治标准时间，而Windows认为CMOS时间是当\n地时间，如果当地在+8区，时间相应的就会差8个小时。\n\n之前看过一些解决方法。一种是在Ubuntu下修改配置文件，让系统使用本地时间。另一种是修改Windows的注册表，让系统使用标准时间。不知为什么这两种方法的都没\n有成功。\n\n最近查找这个问题的时候发现，在Ubuntu 16.04之后加入了 timedatectl 命令可以修改系统的时区。方法是设置Ubuntu使用当前时区。\n\n\n\ntimedatectl 命令还有其它用途就不一一列举了，主要是解决了双系统时间不同步的问题。\n\n\n参考内容#\n\n * Time - ArchWiki\n * How to Fix Time Differences in Ubuntu 16.04 & Windows 10 Dual Boot","routePath":"/2017/01/29/fix-time-differences-between-ubuntu-and-windows/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":326}],"domain":"","frontmatter":{"layout":"post","title":"修正双系统Windows和Ubuntu时间不同步","date":"2017-01-29 17:43:42","categories":["问题麻烦"],"tags":["windows","ubuntu","timezone"]},"version":""},{"id":76,"title":"用CSS制作一个带有动画的菜单开关标识","content":"#\n\n> 先祝大家鸡年大吉吧。看过NEXT模板主题的博客，很喜欢它目录放在侧边栏的样子，于是寻思着也给博客弄一个侧边栏目录。其中用到了如何用CSS和JavaScrip\n> t实现一个带动画的菜单图标。\n\n\n静态菜单图标#\n\n常见的菜单图标由三条黑线组成：\n\n\n\n\n\n3条黑线并排在 menu-icon-wrapper 里，通过 margin 设置间隔，形成菜单图标。\n\n\n动画菜单图标#\n\n动态菜单图标是在静态菜单图标的基础上通过控制变形形成的。\n\n首先添加HTML\n\n\n\n然后添加基本菜单样式的CSS代码\n\n\n\n接下来控制三个 横线 使其变为关闭的样式。横线的位置需要根据显示的样式进行微调。\n\n\n\n还要一个效果，鼠标移到菜单上的时候，图标需要变为向左的箭头样式\n\n\n\n最后添加JavaScript代码控制菜单样式\n\n\n\n预览一下效果。\n\n\n参考内容#\n\n * How TO - Menu Icon","routePath":"/2017/01/28/howto-css-menu-icon-with-open-and-close-tranistion/","lang":"","toc":[{"text":"静态菜单图标","id":"静态菜单图标","depth":2,"charIndex":102},{"text":"动画菜单图标","id":"动画菜单图标","depth":2,"charIndex":185},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":371}],"domain":"","frontmatter":{"layout":"post","title":"用CSS制作一个带有动画的菜单开关标识","date":"2017-01-28 14:13:35","categories":["果然还是前端"],"tags":["css","menu","icon","javascript"]},"version":""},{"id":77,"title":"2017年博客主题更换","content":"#\n\n放弃了自己制作主题，转而使用修改他人的主题。在主题选择上总是比较纠结：一方面对自己前端水平的无奈，另一方面又想有个性。这次选择了 maupassant\n作为样板主题，打算进行一些修改，尽最大努力保留上一个版本主题的内容。\n\n\n评论#\n\n这次的主题兼容 多说\n评论，但是有点无奈的是主题修改了文章字符串，这就导致以前的评论无法转移过来，尝试过要修改评论字符串，但是由于改动的地方还是比较多，所以以前的评论啥的还是放弃吧。\n\n考虑要不要转到 disqus 评论。之后再探讨这个问题吧。\n\n补充：\n\n决定迁移到 disqus 了，找到一个 duoshuo 转 disqus 的工具duoshuo-migrate-to-disqus，尝试了一下。\n\n\n看一看 秀一秀#\n\n看一看 用于记录自己看过的一些动漫，秀一秀 记录博客用过的主题banner。\n\n看一看 可以很好的移植过来，但是由于现主题没有进度条样式，所以这部分还需要单独处理。\n\n秀一秀 问题有两个：首先是在新页面如何进行显示，然后就是今后博客主题应该如何进行展示。\n\n当前这两个板块存在比较多的问题，需要考虑如何更好的融入当前主题。\n\n\n画廊#\n\n画廊是在原文章基础上增加显示图片的地方，起初想法是将一个主题的图片整合起来并写点说明性的内容。但实际看来应用的场景并不是很多，暂时先考虑保留下来。\n\n\n样式#\n\n主页文章预览样式，去除了网页样式只保留了文字，当时看到\n\n文章正文中 标题样式 与 主标题 样式有点冲，需要协调一下。\n\n\n文章附件#\n\n原主题中对文章做了很多的扩展。总结性描述，文章目录，参考文献，这些都是需要展示的内容。\n\n总结性描述：\n\n总结性描述是提取yaml的description部分显示，在文章前面加一个div然后填入description的内容。\n\n文章目录：\n\n发现现主题已经包含了文章目录，但是想要显示的话需要单独在md的yaml中启用。看到判断后那就在所有的文章中启用，但是没有目录显得很难看，于是判断有目录才显示。\n\n\n\n重新整合了一下侧边栏，将目录移到新的侧边栏里。\n\n参考文献：\n\n在文章末尾根据yaml声明的参考文献内容绘制ul进行显示。\n\n\nFooter Header#\n\n现主题页面底部内容只有版权信息，比较少，打算再增加一些内容。头部考虑添加banner和加载进度条。\n\n\n背景#\n\n现主题背景为白色纯背景，可以考虑一下加个背景图片？\n\n\n舍弃#\n\n原主题为了好玩加了一个类似于intellij官网的Shell窗口，但是意义不大，现主题决定舍弃掉了。","routePath":"/2017/01/21/note-for-2017-blog-theme-change/","lang":"","toc":[{"text":"评论","id":"评论","depth":2,"charIndex":115},{"text":"看一看 秀一秀","id":"看一看-秀一秀","depth":2,"charIndex":324},{"text":"画廊","id":"画廊","depth":2,"charIndex":498},{"text":"样式","id":"样式","depth":2,"charIndex":579},{"text":"文章附件","id":"文章附件","depth":2,"charIndex":646},{"text":"Footer Header","id":"footer-header","depth":2,"charIndex":921},{"text":"背景","id":"背景","depth":2,"charIndex":989},{"text":"舍弃","id":"舍弃","depth":2,"charIndex":1022}],"domain":"","frontmatter":{"layout":"post","title":"2017年博客主题更换","date":"2017-01-21 23:46:22","categories":["网站"],"tags":["模板","主题"]},"version":""},{"id":78,"title":"Ubuntu中命令行修改屏幕分辨率","content":"#\n\n前几天安装了Ubuntu Kylin 16.10，然后按照Ubuntu 14.04~15.10 Linux\n3D桌面完全教程，显卡驱动安装方法，compiz特效介绍，常见问题解答配置了桌面特效，感觉还不错。但是重启的之后发现屏幕分辨率不太对了，而且最大只有\n640x480 分辨率。只有笔记本屏幕的分辨率有问题，连接外接显示器的分辨率还很正常。\n\n不想重装系统了，无奈通过其它手段来修复这个问题吧。\n\n首先在桌面环境下用 xrandr 查看当前支持的分辨率。\n\n\n\n不知为什么只支持两种分辨率了，要添加一种新的分辨率，需要知道分辨率的各项参数，使用 cvt 可以获取一个分辨率的参数。假设是 1920x1080 的。\n\n\n\n然后添加一个新的显示模式。\n\n\n\n将新建的分辨率模式添加到显示器上，显示器的名字可以通过之前的 xrandr 命令找到。\n\n\n\n应用新的显示模式\n\n\n\n这样显示器的分辨率可以改成需要的了。\n\n每次启动都要修改分辨率很麻烦，可以将上面的命令加到 ~/.profile 文件中，这样登陆就可以自动修改分辨率了。\n\n\n\n还有一个问题，未登录之前的分辨率还是不正常的，不知道有什么方法可以彻底解决这个问题。","routePath":"/2016/12/21/modify-screen-resolution-on-ubuntu-desktop/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"Ubuntu中命令行修改屏幕分辨率","date":"2016-12-21 20:09:12","categories":["问题麻烦"],"tags":["ubuntu","分辨率","问题"]},"version":""},{"id":79,"title":"Maven 初尝试踩坑记录","content":"#\n\n之前有个项目使用的 Ant 构建出来的，当时为了节省时间，就在里面填填补补，导致现在感觉项目比较凌乱。于是花了大约2周的时间将 Ant 重构成了\nMaven，由于第一次使用，好多地方也不是很明白，没有达到100%还原。\n\n这里只简单记录一下耗时比较长的坑，一些简单的内容可以通过谷歌直接解决了。\n\n\nMaven 划分模块#\n\n一个典型的 Maven 项目包含 父模块 与 子模块\n，父模块主要用于整合项目，声明一些基本的变量数据集，统筹各个子模块之间的关系。每个子模块最好只包含一个单独的功能。\n\n关于模块的打包方式有 pom 、 jar 、 war 等，父模块只能为 pom ，子模块根据需要可以声明为不同的打包格式。\n\n在这个项目分成的结构示意如下：\n\n\n\napp-parent 是父模块， app-conf 放置一些单独的配置文件， app-a 和 app-b 是项目的一个jar包， app-dist\n用于将项目中的内容组合成符合要求的目录格式。\n\n\nMaven assembly#\n\nMaven 是一种 约定 型构建语言，即使很少的配置，只要位置放置正确，也能生成符合要求的jar包。但是，现实情况下往往需要生成复杂的目录结构，Maven\n中含有很多的打包插件可以解决这个问题，这里使用的是 maven-assembly-plugin 打包插件。它会根据xml声明的配置来组织打包结构。\n\n主要的结构如下：\n\n\n\ndependencySets 处理模块依赖的jar如何存放， moduleSets 处理单独的模块如何存放， fileSets\n处理自定义文件如何存放。每个标签下面都可以指定模块名称和输出目录。\n\n举个例子：\n\n 1. 将模块 app-a 依赖 放入 /lib 目录下\n 2. 将模块 app-b 放在根目录下\n 3. 将 app-conf 放在 /conf 目录下\n\n\n\nassembly 还有很多配置，暂时用到的只有这么多。\n\n\n可运行 jar 打包#\n\n可运行的 jar 包在文件内会包含 MANIFEST.MF 文件，在 ant 构建的时候，这个文件是自己书写并提供的。通过 maven-jar-plugin\n插件可以指定 mainClass 并自动将依赖写入 MANIFEST.MF 文件。\n\n\n\n但是，这里存在一个小问题，如果我们使用的jar包在maven库中找不到，你可能会通过本地引入的方式应用它（Scope 为 System）。\n\n\n\n这样虽然可以编译通过，但Maven却不将其作为标准 依赖 ，通过assembly和MANIFEST.MF都无法对其进行处理。\n\n一个比较好的解决方案是创建一个项目专有的 私有仓库 。在父模块下创建一个文件夹 repo 作为项目的私有仓库。\n\n\n\n复制jar包到私有仓库，使用maven命令\n\n\n\n例如：\n\n\n\n执行完成后就可以在 repo 文件夹下看到新加入的jar包。\n\n在项目中引用私有仓库的jar包，首先要添加私有仓库的地址。如果包含子模块，不建议将仓库地址放在父模块的 pom.xml 文件内。\n\n\n\n之后像其它 Maven 依赖一样引用就可以了。\n\n\n\n\n参考内容#\n\n * Maven: add a dependency to a jar by relative path - StackOverflow","routePath":"/2016/11/22/maven-pratice-in-my-project/","lang":"","toc":[{"text":"Maven 划分模块","id":"maven-划分模块","depth":2,"charIndex":152},{"text":"Maven assembly","id":"maven-assembly","depth":2,"charIndex":432},{"text":"可运行 jar 打包","id":"可运行-jar-打包","depth":2,"charIndex":831},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1324}],"domain":"","frontmatter":{"layout":"post","title":"Maven 初尝试踩坑记录","date":"2016-11-22 13:53:34","categories":["问题麻烦"],"tags":["maven","java","模块化"]},"version":""},{"id":80,"title":"Ubuntu 下合并分区数据","content":"#\n\n好久没写博客了，最近也不知道在忙些什么，而且期间还生了场大病，好在感觉节奏在慢慢回来，可能吧。\n\n之前系统 Ubuntu 分区根据不同的挂载点，分了不同的分区。随着系统的升级，现在越来越觉得 /boot 分区有点力不从心，稍微安装几个内核就满了，于是考虑将\n/boot 分区合并到 / 的分区里。\n\n首先查看一下当前分区及挂载点情况：\n\n\n\n可以看到 /boot 分区位于 /dev/sda6 下，而 / 位于 /dev/sda7 下。一个基本的思路是将 /boot 的内容拷贝到 /\n里，然后修改挂载文件不再自动挂载 /dev/sda6 分区。\n\n由于系统开机自动挂载的缘故，所以无法通过根目录直接访问到 /dev/sda7 里的 /boot 目录，需要自己挂载，才能访问到。\n\n\n\n现在 /dev/sda7 被挂载到 /mnt/root 目录下，接下来将 /boot 的内容拷贝到 /mnt/root/boot\n目录下，如果没有该目录，记得新建一个目录，并修改权限。\n\n最后，修改系统挂载文件 /etc/fstab ，注释掉 /boot 挂载点的那一行，这里是\nUUID=c71b9df3-a15a-4fc9-bd31-b4d6d2a44e54 /boot ext4 defaults 0 2。\n\n\n\n做完以上工作后，就可以重启了，至于能不能成功，就看造化了。很幸运，没有出现什么问题。:smile:\n\n至于转移后剩下的分区，就只有先放在那里了，以后可能也用不到了……","routePath":"/2016/11/15/move-parition-data-to-another-parition/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"Ubuntu 下合并分区数据","date":"2016-11-15 23:35:47","categories":["问题麻烦"],"tags":["ubuntu","linux","分区"]},"version":""},{"id":81,"title":"在atom的界面上添加署名标识","content":"#\n\n用了一段时间的Atom编辑器了，感觉很不错。Atom通过CSS控制显示的样式，所以一些效果可以通过修改内置的CSS样式来实现。\n\n打开 File->Stylesheet... 就可以看到编辑器内置的样式，当然默认里面什么都没有填写。\n\n想要在右上角显示一个签名，或者一句话也可以。由于无法使用JS创建新的div，所以考虑了一下使用了body的 :before 伪类来充当显示的容器。\n\n样式如下：\n\n\n\n保存之后就可以看到效果了。\n\n\n\n:joy: 感觉完全没啥用，高兴就好。。。等以后有更好的姿势可以再弄的好看一点 :shit: 。。。","routePath":"/2016/04/12/atom-a-easy-hacking-attempt-to-add-a-signature/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"在atom的界面上添加署名标识","date":"2016-04-12 20:15:10","categories":["JustForFun"],"tags":["atom","css"]},"version":""},{"id":82,"title":"使用Canvas画一棵生长的树","content":"","routePath":"/2016/04/11/canvas-draw-a-growing-tree/","lang":"","toc":[{"text":"静态的树","id":"静态的树","depth":2,"charIndex":-1},{"text":"动态的树","id":"动态的树","depth":2,"charIndex":-1},{"text":"数据结构","id":"数据结构","depth":3,"charIndex":-1},{"text":"树干生长","id":"树干生长","depth":3,"charIndex":-1},{"text":"树干花朵绘制","id":"树干花朵绘制","depth":3,"charIndex":-1},{"text":"代码和效果","id":"代码和效果","depth":3,"charIndex":-1},{"text":"总结","id":"总结","depth":2,"charIndex":-1},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"使用Canvas画一棵生长的树","date":"2016-04-11 19:43:09","categories":["果然还是前端"],"tags":["javascript","canvas","html"]},"version":""},{"id":83,"title":"Java调用外部程序获取的返回信息乱码","content":"#\n\n之前用Java写的常驻进程服务，最近发现有个地方出现了乱码。出现乱码的位置是，程序调用了一个外部程序，通过管道读取外部程序的返回信息，然后加工这些返回信息。\n\n\n\n排查了一下。手动调用外部程序没问题，Java编码没问题，文件权限等等都没问题。最后发现手动执行Java服务的时候不会出现乱码，而通过启动脚本启动的时候，就出现了\n乱码。\n\n百度了之后了解到通过外部程序调用启动脚本的时候，运行环境发生了改变，Shell环境已经不是用户环境了，这时候字符集的设置可能就变得不确定，可能变成了GB2312\n或ISO8859-1。\n\n解决方法： 执行 echo $LANG ，获得当前环境的字符集，比如是 en_US.UTF-8 。之后在启动脚本中重新定义一下字符集就可以了：\n\n\n\n\n参考内容#\n\n * crontab执行shell脚本日志中出现乱码","routePath":"/2016/04/06/java-execute-program-return-messages-garbled/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":340}],"domain":"","frontmatter":{"layout":"post","title":"Java调用外部程序获取的返回信息乱码","date":"2016-04-06 19:05:56","categories":["问题麻烦"],"tags":["java","shell","乱码"],"reference":[{"url":"http://laoxu.blog.51cto.com/4120547/1212593","title":"crontab执行shell脚本日志中出现乱码"}]},"version":""},{"id":84,"title":"MI3换屏幕小记","content":"#\n\n毕业的时候不小心将米3的屏幕压碎了，就这样放在家里放了半年。现在突然心血来潮，给米3换个屏幕吧。后壳也摔得不行了，也需要换一换后壳。\n\n\n准备#\n\nX宝上有很多屏幕总成，也不确定哪种好点，于是就随便挑选了价位在130左右的屏幕总成。对于我这样的新手来说，选择屏幕总成省去了很多麻烦。随屏幕赠送拆机工具确实省心\n的不少，不过还是有自己的工具的。\n\n然后在屏幕送来这几天，稍微研究研究了拆机的方法。还算比较友好吧，各方面模块集成的都比较好。\n\n换屏主要工作是将原手机的部件转移到新手机上，比较麻烦的部分在于排线的转移，大部分排线是粘连在总成上的，需要弄下来。一般都是用镊子进行操作，这里 注意\n一下，镊子的用法有两种，一种是镊子尖向外挑，另一种是镊子尾向外撬，一般视频上都推荐用第二种，在弄排线的时候特别注意不要让镊子尖扎到排线里，以免弄断排线的电路。\n\n细心、大胆、不烦躁，换屏幕不难。由于换的时候没有拍照，所以就从网上找了一些照片来用。推荐看拆机视频慢慢来弄。\n\n\n后盖拆卸#\n\n后盖用卡扣卡住，在卡托里由两颗螺丝固定。\n\n拆掉这两颗螺丝之后，用翘片沿着后壳边缘撬一圈就可以下来。\n\n\n电池外壳拆卸#\n\n拆开后盖之后就可以看到里面了。\n\n我们需要将铁盖和电池拆下来，可以看到顶部有8颗螺丝，底部有3颗螺丝。这两种螺丝的长度是不同的，拆下来的时候注意分开存放。\n\n底部的盖很容易就弄下来了，主要还是说一下顶部的盖。顶部的后盖与电池排线连在一起，不能直接拿下来。这里稍微注意一下就额可以了。\n\n撬开顶部后盖之后将电池排线拆下。\n\n电池部分需要拽着“尾巴”拉出来，电池里面使用了双面胶固定，年代久远双面胶可能贴的很死，实在拉不出来可以在顶部找个工具撬一撬。当时废了九牛二虎之力，多弄了几次才下\n来。\n\n这样就把电池连带上下后壳拆下来了。\n\n\n拆主板#\n\n下面轮到主板了，主板上有两颗螺丝固定，记住位置：一颗在摄像头旁边，另一颗这震动器的上面\n\n在将主板拿下来之前，先将外面的排线拿下来：上面是触摸排线，下面是显示排线和尾插排线。还有在右下角有天线，也要拿下来。\n\n拿主板小心注意背面的排线：按键排线。将排线全部拔下主板很容易就拿下来了。\n\n到这里，拆解工作已经完成，下面就是将屏幕旧部件移到新屏幕的过程了，这一部分比较繁琐，建议找个视频反复观看，还是需要注意镊子的用法，不要扎到排线里。\n\n\n换屏幕#\n\n这里只说一下我在换屏的过程中遇到的注意点。\n\n 1. 镊子的用法，重要的事情\n 2. 排线背面有双面不干胶，如果没有连同一起撬下来也不必强求，排线一般不会在新屏幕里滑动的\n 3. 不太懂的地方看懂了再下手，盲目下手会有损害\n\n特别注意尾插排线右下角的部分（USB充电口的里面）。这里的排线下面带有一个铁板，记得将铁板一同撬下，如果从左向右撬排线，到这里很容易忽视掉下面的铁板而弄坏排线。\n如果镊子伸不进缝隙中，可以使用小刀帮助一下。当时在这里卡了一晚上，最后还是借助小刀解决了。\n\n其它的地方都比较简单，照着视频一步一步换过来就行了。\n\n\n装回#\n\n排线搬运完毕后就可以装回主板电池了，记得拆下来的顺序逆着回去就可以了。注意不要用错了螺丝，不然会挤爆屏幕。\n\n换屏就这样结束了，又同时换了个后壳，感觉米3就像新的一样，但是已经回不到过去使用它的时候了。\n\n\n参考内容#\n\n * 『技巧教程』涨知识咯 小米3 完美拆机换屏教程","routePath":"/2016/03/13/change-the-maintenance-for-mi3/","lang":"","toc":[{"text":"准备","id":"准备","depth":2,"charIndex":71},{"text":"后盖拆卸","id":"后盖拆卸","depth":2,"charIndex":435},{"text":"电池外壳拆卸","id":"电池外壳拆卸","depth":2,"charIndex":495},{"text":"拆主板","id":"拆主板","depth":2,"charIndex":770},{"text":"换屏幕","id":"换屏幕","depth":2,"charIndex":995},{"text":"装回","id":"装回","depth":2,"charIndex":1271},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1380}],"domain":"","frontmatter":{"layout":"post","title":"MI3换屏幕小记","date":"2016-03-13 15:28:02","categories":["搞机日常"],"tags":["mi3","屏幕","拆机"]},"version":""},{"id":85,"title":"三月读书书单","content":"#\n\n> 三月读书的书单。\n\n一转眼二月就过去了，假期一个月的时间只在前半月读了点，后半月完全不知道每天在忙什么。\n\n二月完成情况：\n\n * :ballot_box_with_check: Github 入门与实践\n * :black_square_button: 深入浅出 Nodejs\n * :ballot_box_with_check: Java Effective 中文版\n * :black_medium_square: 我的青春恋爱物语喜剧果然有问题 1\n * :black_medium_square: 自制编程语言\n * :black_medium_square: 家用游戏机简史\n * :black_medium_square: Android 安全攻防权威指南\n\n二月未完成的书单顺延到三月份，并补上一些新的书：\n\n * :black_square_button: 深入浅出 Nodejs\n * :black_medium_square: Java 编程思想\n * :black_medium_square: 我的青春恋爱物语喜剧果然有问题 1\n * :black_medium_square: 自制编程语言\n * :black_medium_square: 家用游戏机简史\n * :black_medium_square: Android 安全攻防权威指南\n * :black_medium_square: 游戏开发的数学和物理\n\n继续加油吧:muscle:。","routePath":"/2016/03/01/mar-reading-book-list/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"三月读书书单","date":"2016-03-01 15:39:46","categories":["读书笔记"],"tags":["书单","笔记"]},"version":""},{"id":86,"title":"让Hexo支持emoji表情","content":"#\n\n写博客的时候发现有些内容不能很好的通过文字表达出来，这时候就需要表情的支持了。所以就研究了一下怎么在博客中加入emoji表情。\n\n网上有很多支持emoji的插件，但是都需要在浏览器端进行处理，考虑到使用的JS库已经够多了，所以尽量还是让Hexo提前渲染为好。\n\n\n调研#\n\n大多数有关Hexo和emoji提到的是hexo-tag-emojis插件，但是这个插件没有对Hexo\n3.0提供支持，而且它使用的是{%raw%}{%%}{%endraw%}标签选项，这样写起来太麻烦，如果能像Github那样用::就好了。\n\n之后发现可以通过修改Hexo默认的Markdown渲染器来实现渲染emoji。\n\n\n修改渲染器#\n\nHexo默认的markdown渲染插件是hexo-renderer-marked，也就是marked渲染器的Hexo版本，这个渲染器不支持插件扩展。在PR中也提\n到了要支持emoji，但是却迟迟没有marge进来。然后就是另外一个markdown渲染器hexo-renderer-markdown-it，这个渲染器支持插件\n配置可以使用markdown-it-emoji插件来支持emoji。我们要将原来的markdown渲染器换成这个。\n\n首先在博客目录下卸载原渲染器，安装新的渲染器：\n\n\n\n之后下载markdown-it-emoji插件：\n\n\n\n> 2017-08-01更新： 还需要为博客安装twemoji依赖 yarn add twemoji\n\n编辑Hexo的配置文件_config.yml来配置markdown渲染器，更多配置选项可以参考文档Advanced Configuration：\n\n\n\n这时候启动Hexo服务就生效了。输入:smile: :smirk: :relieved:，会渲染成 😄 😏 😌。\n\n\n使用图片表情#\n\nUnicode字符表情有点看不清楚，考虑能不能换成图片样式的emoji表情？markdown-it-emoji文档中提到可以修改输出函数来改变输出样式。但是它是\n以附属插件加载的，无法通过配置文件修改，只好修改源代码了。\n\n首先下载twemoji，用twemoji将unicode表情转换成图片：\n\n\n\n接下来再修改markdown-it-emoji模块里的/node_modules/markdown-it-emoji/index.js文件：\n\n\n\n重新启动Hexo就可以看到表情变成图片了:smile:。\n\nemoji图片表情就是这个样子了，还是希望marked渲染器能支持类Github的emoji渲染。\n\n> 2018-05-23更新： 每次修改感觉有点麻烦，于是把 markdown-it-emoji 的代码逻辑提取出来，结合 twemoji\n> 从新写了一个插件。名字叫 mie-wrap-twemoji，不会起名字，所以就不要吐槽名字了。\n\n引入插件，先把之前的插件卸载，然后安装新的插件\n\n\n\n在_config.yml中配置去掉 markdown-it-emoji 条目，改为 mie-wrap-twemoji 条目。\n\n\n\n配置解析出的emoji图片的样式，使其作为一个文字大小展示。\n\n\n\n\n参考内容#\n\n * 让Hexo支持emoji表情\n * markdown-it demo","routePath":"/2016/02/29/hexo-support-emoji/","lang":"","toc":[{"text":"调研","id":"调研","depth":2,"charIndex":134},{"text":"修改渲染器","id":"修改渲染器","depth":2,"charIndex":303},{"text":"使用图片表情","id":"使用图片表情","depth":2,"charIndex":777},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1342}],"domain":"","frontmatter":{"layout":"post","title":"让Hexo支持emoji表情","date":"2016-02-29 16:28:28","categories":["网站"],"tags":["emoji","hexo","markdown","twemoji"]},"version":""},{"id":87,"title":"使用Python+Mongodb+NodeJS实现一个票数记录网站","content":"#\n\n之前刷微博的时候看过一个网站买下 Steam 所有游戏要花多少钱？，发现它的实现使用的是 Python后台 加 NodeJS展示 。前几天 天二\n发来了一个投票网站，在研究了一番之后找到了刷票的方法。再加上想用NodeJS干点事情，于是在这些乱七八糟的事情的驱动下，这个网站的想法就这样诞生的。NodeJS\n和Mongodb都是现学现卖的，至少能达到预期的效果了。\n\n\n数据源网站分析#\n\n由于活动要到5月份才结束，为了不必要的麻烦，就不打算暴露网址了。也请自行脑补一些图片吧。\n\n最初投票网站是分享到朋友圈的，通过分享的链接访问投票选手网页，点击“投票”就为该选手投上一票，多次投票只能算一票。\n\n为了调试方便，将链接提取到电脑浏览器上，却提示\n需要在微信中打开，最初想到是不是判断的UserAgent，于是找了一个Android微信浏览器的UserAgent试了一下，发现不行。这就纠结了，然后天二告诉说\n用iPhone的UserAgent是可以的，这...无语了...\n\n\n\n打开网页之后，需要研究投票逻辑。简单看了JS代码之后，发现投票按钮根本啥事情也没有做，那票是怎么投上去的？经过一系列的猜想和实验之后，发现了一个惊天的结论：网页\n通过Cookie判断是否多次投票，而投票只需访问一下网页就可以了...就可以了...就可以了...\n\n天二说，好想去创业呀...\n\n\nPython抓取数据#\n\n也好也好，网站简单程序也就简单了。一段投票+抓取数据的代码就这样诞生了：\n\n\n\n网页源代码抓取到了，需要分析源代码的数据。这里主要抓取网页里的排行榜，排行榜在一个 table\n中显示，而整个网页只有一个table。使用Python的HTMLParser库解析网页源代码。下面给出一个大致框架：\n\n\n\n然后就是定时任务了，不想使用无限循环，就参考使用crontab来执行定时任务。执行并在最后一行输入以下命令：\n\n\n\n这句话的意思是 每隔20分钟执行一次后面的命令，其它写法可以查阅相关资料。貌似后台数据端准备完毕了。\n\n\nMongodb数据库构建#\n\n选择Mongodb的原因有两个：一是不想用MySql了，二是没用过Mongodb。首先果然还是从安装搭配环境开始吧。\n\nWindows下安装，首先到https://www.mongodb.org/downloads来下载安装包，安装之后找到安装目录，运行命令 mongod\n--dbpath \"数据库路径\" --logpath \"日志路径\\MongoDB.log\" --install --serviceName\n\"MongoDB\"，这样会以服务模式运行Mongodb数据库。\n\nLinux下安装，也需要到https://www.mongodb.org/downloads来下载安装包，解压到\\usr\\local\\mongodb目录下，创建\n配置文件mongodb.conf，配置开机启动。\n\nmongodb.conf\n\n\n\n配置开机启动\n\n\n\nPython可以使用pymongo来连接Mongodb数据库，Windows下可以下载模块安装包，Linux下用pip安装：\n\n\n\nNodeJS需要mongodb和monk模块连接Mongodb数据库，使用npm安装：\n\n\n\n这里简单介绍了Mongodb的安装和连接方式。\n\n\nNodeJS展示#\n\n有了数据和数据库，就需要一个展示页面了。框架选定了Express，第一次用说一下了解的地方。\n\n安装 需要安装node和npm，一般发行版的软件库中都包含吧，手动安装去找摆渡吧。\n\n框架 如果有个IDE那就再好不过了，也可以手动下载Express。具体怎么安装还是看个人喜好吧。\n\n路由\n第一次接触这种需要手动书写路由规则的方式。Express的路由规则分为两部分，app.js和routes目录下的文件。首先在app.js中指定哪个目录由哪个路由\n解析，然后在routes下配置相应的路由文件。\n\n数据库\n数据库最好是维持一个连接，而不是每有一个请求到来就建立一个连接。实现的方式是在app.js中建立连接，然后在routes中引用这个数据库连接。这里贴出一个app\n.js的代码，可以参考这段代码的注释。在路由中通过req.db就可以取到数据库引用了。\n\n\n\n启动 开发环境和部署环境的运行是不同的，部署环境下需要能在后台运行。可以在网站目录下运行 PORT=3000 nohup npm start &\n命令，PORT通过环境变量来修改启动端口，nohop配合&实现后台执行。\n\n其它 诸如如何书写页面，如何传参渲染，这些问题可以参考Express框架里的默认页面。\n\n\n服务器和域名#\n\n服务器使用阿里云的服务器，将以上内容部署上去之后打算绑上一个域名，参考 土豪 那篇文章，打算就使用Nginx做转发。\n\n安装Nginx，打开配置文件vim /etc/nginx/nginx.conf，添加一段内容：\n\n\n\n注意域名和端口。然后重启Nginx service nginx restart。\n\n很顺利，不过遇到了一个问题，域名需要备案。算了，还是乖乖用IP访问吧。\n\n\n总结#\n\n这次实现过程用了一天多的时间，其实主要的时间都用在研究图表插件的展示问题，这里没有提到这部分内容。\n\n整个实现的功能就是，Python每隔20分钟抓取一次数据存储到Mongodb数据库中，Express读取Mongodb展示出来。\n\n至此这部分内容可以告一段落了。\n\n\n参考内容#\n\n * CentOS6.4 安装MongoDB\n * THE DEAD-SIMPLE STEP-BY-STEP GUIDE FOR FRONT-END DEVELOPERS TO GETTING UP AND\n   RUNNING WITH NODE.JS, EXPRESS, JADE, AND MONGODB\n * 买下 Steam 所有游戏要花多少钱？","routePath":"/2016/02/29/a-vote-logger-with-python-mongodb-and-nodejs/","lang":"","toc":[{"text":"数据源网站分析","id":"数据源网站分析","depth":2,"charIndex":187},{"text":"Python抓取数据","id":"python抓取数据","depth":2,"charIndex":591},{"text":"Mongodb数据库构建","id":"mongodb数据库构建","depth":2,"charIndex":865},{"text":"NodeJS展示","id":"nodejs展示","depth":2,"charIndex":1392},{"text":"服务器和域名","id":"服务器和域名","depth":2,"charIndex":1942},{"text":"总结","id":"总结","depth":2,"charIndex":2142},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2282}],"domain":"","frontmatter":{"layout":"post","title":"使用Python+Mongodb+NodeJS实现一个票数记录网站","date":"2016-02-29 10:15:37","categories":["实践"],"tags":["nodejs","mongodb","python"]},"version":""},{"id":88,"title":"体验Electron之Hello World","content":"Hello World!\n\nWe are using node , Chrome , and Electron .","routePath":"/2016/02/19/electron-hello-world/","lang":"","toc":[{"text":"electron-quick-start","id":"electron-quick-start","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"体验Electron之Hello World","date":"2016-02-19 22:33:00","categories":["体验Electron"],"tags":["electron","nodejs"]},"version":""},{"id":89,"title":"体验Electron之起步","content":"#\n\n很喜欢用Atom编辑器，于是很好奇Atom是怎样实现的，然后就发现了Electron项目。\n\n\nElectron#\n\n> Electron框架的前身是 Atom Shell，可以让你写使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序。它是基于io.js\n> 和 Chromium 开源项目，并用于在 Atom 编辑器中。Electron 是开源的，由 GitHub\n> 维护，有一个活跃的社区。最重要的是，Electron 应用服务构建和运行在 Mac，Windows 和 Linux。\n\nElectron 托管在 Github 上，通过起步先感受一下 Electron 的魅力。\n\n\n起步#\n\n要体验 Electron，需要安装 NodeJS 和 Git 环境。这里就不再阐述。\n\n运行以下命令就可以看到Electron的简易界面了。\n\n\n\n\n\n可以看到带有菜单栏和开发者工具的界面。从开发者工具也能大体了解显示页面的结构。\n\n\n打包和发布#\n\n打包需要使用 asar 工具。首先安装asar套件。\n\n\n\n打包资源文件\n\n\n\n这样会得到 app.asar 资源文件，避免将源代码暴漏给用户。要想运行资源文件，还需要框架的支持。从 Electron\n的发布页面下载对应的Electron版本，这里以 electron-v0.36.7-darwin-x64.zip 为例。\n\n将文件解压缩，用打包好的 app.asar 放到 Electron 的资源文件夹下 electron/resources/ ，这样运行 Electron\n会自动读取并执行资源包内的内容。\n\n\n总结#\n\n本文从简单的环境搭建上通过官方提供的示例体验了 Electron\n，并没有过多的涉及应用编写方面的内容。接下来我会随着自己学习的深入，一步一步的构建一个自己的跨平台应用程序。也希望能一同进步，来感受生活中的一些独特魅力。","routePath":"/2016/02/18/electron-get-started/","lang":"","toc":[{"text":"Electron","id":"electron","depth":2,"charIndex":50},{"text":"起步","id":"起步","depth":2,"charIndex":308},{"text":"打包和发布","id":"打包和发布","depth":2,"charIndex":431},{"text":"总结","id":"总结","depth":2,"charIndex":698}],"domain":"","frontmatter":{"layout":"post","title":"体验Electron之起步","date":"2016-02-18 21:08:17","categories":["体验Electron"],"tags":["electron","nodejs","编译","打包","atom"]},"version":""},{"id":90,"title":"17 行代码实现的简易 Javascript 字符串模板","content":"#\n\n前几天在写博客模板的时候需要用 js 将 JSON 生成网页，当时很纠结怎样优雅的实现数据的填充，因为不太想用 +\n连接数据和HTML代码。正当纠结的时候在微博上发现了这个JavaScript字符串模板，遂拿来用了用。至于其中的各方面原理，还需要等JS水平上来之后再慢慢分析吧\n。当前先照葫芦画瓢。\n\n下面是整个实现的代码，具体讲解请参考【参考文献】中的原文博客。\n\n\n\n使用方式，将代码挂在字符串的原型链下\n\n\n\n调用方式\n\n\n\n感谢博主提供的黑科技，有了这么方便的功能。\n\n\n参考内容#\n\n * 17 行代码实现的简易 Javascript 字符串模板（SegmentFault）\n * 17 行代码实现的简易 Javascript 字符串模板（博客）","routePath":"/2016/02/16/seventeen-line-to-complete-a-javascript-string-render-template/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":242}],"domain":"","frontmatter":{"layout":"post","title":"17 行代码实现的简易 Javascript 字符串模板","date":"2016-02-16 20:39:01","categories":["高效生活"],"tags":["模板","javascript"]},"version":""},{"id":91,"title":"【更新中】Java Socket通信实现笔记","content":"#\n\n用Java好长时间了，但是网络编程和并发编程方面一直都没有好好实践一下，对其中的方方面面还需要好好体会一下。还是打算自己动手，在实践中遇到问题并加以解决。最近研\n究直播方面的内容，决定从连接直播服务器入手来学习Socket相关的一些知识。\n\n\nJava Socket#\n\n\n心跳包#","routePath":"/2016/02/10/java-danmuji/","lang":"","toc":[{"text":"Java Socket","id":"java-socket","depth":2,"charIndex":124},{"text":"心跳包","id":"心跳包","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"【更新中】Java Socket通信实现笔记","date":"2016-02-10 21:18:23","categories":["编程语言"],"tags":["java","socket"]},"version":""},{"id":92,"title":"Steam控制台命令","content":"#\n\n今天在Steam上玩游戏的时候，发现游戏被锁区了，于是想看一看游戏许可证所在的分区，然后就发现Steam可以使用控制台命令。\n\n\n开启控制台模式#\n\n要启动控制台模式，需要给Steam添加启动参数。在Steam快捷方式上右键，属性。然后添加-console参数。\n\n\n\n启动Steam就可以看到CONSOLE选项卡了。\n\n\n\n\n使用控制台#\n\n切换到Console选项卡，输入命令就可以使用了，会有命令提示。\n\n使用 user_info 查看一下账号信息\n\n\n\n可以从回显信息中看到Steam账号的SteamID等一些基本信息。还有 licenses_print\n命令也可以尝试一下，可以查看游戏许可证的许可区域、付款来源等。\n\n发现 IPCountry 被识别成\nUS（美国）了，于是锁区的游戏就无法启动了。遇到这个问题需要关闭VPN，然后退出Steam一段时间，再进入Steam就可以了。重启Steam是无效的，需要关闭S\nteam客户端一段时间。\n\n\n控制台命令#\n\n官方没有找到帮助文档，只好找了一个第三方的命令和启动参数，权当一个参考吧。\n\n启动参数\n\n\n\n控制台命令\n\n","routePath":"/2016/02/09/steam-console-command/","lang":"","toc":[{"text":"开启控制台模式","id":"开启控制台模式","depth":2,"charIndex":67},{"text":"使用控制台","id":"使用控制台","depth":2,"charIndex":166},{"text":"控制台命令","id":"控制台命令","depth":2,"charIndex":431}],"domain":"","frontmatter":{"layout":"post","title":"Steam控制台命令","date":"2016-02-09 20:54:41","categories":["游戏人生"],"tags":["steam","控制台","命令"]},"version":""},{"id":93,"title":"二月读书书单","content":"#\n\n> 二月读书的书单。\n\n新的一年，开始读书吧。二月正好是寒假，带来了好多书不知道能看几本。\n\n * Github 入门与实践\n * 深入浅出 Nodejs\n * Java Effective 中文版\n * 我的青春恋爱物语喜剧果然有问题 1\n * 自制编程语言\n * 家用游戏机简史\n * Android 安全攻防权威指南","routePath":"/2016/02/05/feb-reading-book-list/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"二月读书书单","date":"2016-02-05 20:46:11","categories":["读书笔记"],"tags":["书单","笔记"]},"version":""},{"id":94,"title":"假期准备游戏吧！","content":"#\n\n假期也不知道该干些啥。。。每天睡到很晚起来看看书浑浑噩噩的就到下午了，然后上上网就过去了。。。前几天在翻电视的时候无意中发现电视与电视盒连接居然用的是HDMI线\n，突然想到能否将电脑和电视连接起来。\n\n于是乎，一个游戏机模型就这样在我脑海中诞生了。\n\n\n\n看看手头的装备：\n\n * 笔记本一台\n * 宽屏电视\n * 小米游戏手柄\n * 各种游戏\n\n不错不错，都满足了。。。今天中午调试了一下，发现了以下问题：\n\n * 需要将电视作为双显示器的主显示器\n * 小米手柄的兼容性很差，用了x360ce适配一下，感觉还凑合吧，就是需要将包括Steam在内的所有游戏都要设置一遍\n * Steam大屏幕模式效果灰常不错，赞\n * 没有网，没有网，没有网，离线游戏吧\n\nOK！万事俱备，只有一个问题急需解决。怎么解释即 用着电脑 又 占着电视 这个问题？","routePath":"/2016/02/04/holiday-game-play-prepare/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"假期准备游戏吧！","date":"2016-02-04 20:57:47","categories":["游戏人生"],"tags":["游戏","假期","手柄","steam"]},"version":""},{"id":95,"title":"CentOS下安装和配置饥荒联机版服务器","content":"#\n\n最近没啥好游戏玩了，所以就被同学拉着学习打饥荒。。。一起联机的话感觉太慢，正好有台限制的阿里云VPS，就拿来搭个饥荒服务器吧。\n\n\n前期准备#\n\n服务器是1GB内存，应该可以供应得起十几个人的联机。\n\n首先要想搭建服务器需要生成一个服务器key。打开饥荒联机版游戏，登录游戏后按 ~ （数字1左边的键）打开控制台输入\n\n\n\n之后就可以在 C:\\Users\\Sumy\\Documents\\Klei\\DoNotStarveTogether\n目录下下生成server_token.txt文件，之后需要将此文件放到服务器上。\n\n\n服务器安装#\n\n要想安装游戏服务器，需要先安装SteamCMD工具，可以参考SteamCMD的步骤来安装。这里简单说明一下。\n\n\n安装SteamCMD#\n\n安装依赖（针对 CentOS 64位）\n\n\n\n添加用户并切换到steam用户\n\n\n\n创建steam文件夹\n\n\n\n下载steamcmd\n\n\n\n解压\n\n\n\n\n下载饥荒服务器#\n\n解压完成后就可以使用了，下面通过steamcmd下载饥荒的服务器。\n\n运行steamcmd（请在steam用户下操作）\n\n\n\n第一次运行需要初始化和更新，当出现 Steam> 提示符的时候就可以输入命令了。\n\n下载饥荒服务器\n\n\n\n回显\n\n\n\n这一步可能比较慢，耐心等待一下，网络中断的话就重新下载一次。这里的343050是饥荒游戏的ID，如果要下载其它游戏，只需改成其它游戏的ID即可。\n\n\n服务器配置#\n\n和Windows的目录类似，游戏会被下载到 /home/steam/Steam/steamapps/commom ，可以去此目录找到SteamCMD下载的游戏。\n\n进入饥荒游戏的bin目录，运行\n\n\n\n这时候可能会显示\n\n\n\n在CentOS下没有这个链接库，可以用其它的库代替一下\n\n\n\n另外也可以使用 ldd ./dontstarve_dedicated_server_nullrenderer 来查看程序缺少的动态链接库。\n\n这时候再运行就不报错了，如果还报错就将报错信息谷歌一下。接下来就会出现以下信息\n\n\n\n提示缺少server\ntoken，准备工作的时候已经生成了server_token.txt，我们需要将其放到服务器上，不能直接打开然后粘贴到控制台里，最好通过传输工具。\n\n可以考虑使用scp命令上传\n\n\n\n在/home/steam/.klei/DoNotStarveTogether/目录下找到上传的server_token.txt就可以了，还可以在此目录下找到服务\n器的配置文件settings.ini，参考以下模板将配置文件修改一下，由于饥荒不支持Unicode字符，所以做好不要使用中文。\n\n\n\n之后运行服务器就会生成一个默认的世界了。\n\n这时候去http://my.jacklul.com/dstservers看一看服务器列表上有没有你的服务器就行了。\n\n\nMOD安装#\n\nmod可以为服务器生存增加便利性和可玩性。加入mod的服务器无法通过直连方式（c_connect命令）连接了，需要通过在线列表搜索进入。\n\n首先，需要先从创意工坊里下载mod，修改dedicated_server_mods_setup.lua文件可以让服务器每次启动的时候自动加载和更新mod，该文件\n位于/home/steam/Steam/steamapps/common/Don't Starve Together Dedicated Server/mods\n文件夹。向下面这样添加，数字为创意工坊中mod的编号。\n\n\n\n下载mod之后服务器不会自动加载，需要继续配置要加载的mod，这里有两种方法。\n\n第一种方法修改modsettings.lua文件强制加载mod，这个文件在mods文件夹下可以找到。使用这种方法加载的mod会以默认配置启动，而且无法修改配置，\n无法在多服务端下隔离配置。\n\n\n\n第二种方法修改modoverrides.lua文件返回mod信息进行加载。该文件在/home/.klei/DoNotStarveTogether文件夹下。这种方\n法可以隔离不同服务端的配置，而且可以根据需要修改mod的配置。推荐以这种方式加载mod。\n\n\n\n\n脚本命令#\n\n可以创建一个启动脚本来启动，如果运行之后缺少screen命令，可以通过yum进行安装。\n\n\n\n运行脚本之后可以使用快捷键 Ctrl + A, D (按住Ctrl然后依次按A和D)切换到后台，要将其切换到前台，可以输入screen -r DST命令。\n\n如果是管理员的话可以在客户端使用控制台（~键，在1的左边）执行命令，附一些服务器常用的命令：\n\n> TheNet:Kick(userid) 踢出玩家 TheNet:Ban(userid) 禁止玩家 c_save() 立即保存\n> c_reset(true|false) true保存并重新加载世界，false不保存直接重新加载当前世界 c_regenerateworld()\n> 重新生成世界 c_shutdown(true|false) true保存并关闭当前世界，false不保存直接关闭当前世界\n> TheNet:SetAllowIncomingConnections(true|false) true允许他人加入，false阻止任何人加入\n> c_rollback(count) 回档\n\n\n参考内容#\n\n * SteamCMD\n * Guides/Don’t Starve Together Dedicated Servers\n * Install and Configure Don’t Starve Together Server on Ubuntu 14.04\n * 生存类游戏 Don't Starve Together（饥荒联机版）Linux 专用服务器的搭建\n * 饥荒联机版服务端MOD及更多设置","routePath":"/2016/01/24/install-and-configure-dont-starve-together-server-on-centos/","lang":"","toc":[{"text":"前期准备","id":"前期准备","depth":2,"charIndex":68},{"text":"服务器安装","id":"服务器安装","depth":2,"charIndex":263},{"text":"安装SteamCMD","id":"安装steamcmd","depth":3,"charIndex":328},{"text":"下载饥荒服务器","id":"下载饥荒服务器","depth":3,"charIndex":418},{"text":"服务器配置","id":"服务器配置","depth":2,"charIndex":625},{"text":"MOD安装","id":"mod安装","depth":2,"charIndex":1224},{"text":"脚本命令","id":"脚本命令","depth":2,"charIndex":1764},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2246}],"domain":"","frontmatter":{"layout":"post","title":"CentOS下安装和配置饥荒联机版服务器","date":"2016-01-24 16:57:14","categories":["游戏人生"],"tags":["游戏","饥荒","服务器","centos"]},"version":""},{"id":96,"title":"2016博客模板改进","content":"#\n\n将近年底了，也需要将博客的主题修改一番了。之前一直驾驭不了首页的大横幅，主要是大横幅因为宽度问题总是显示不全。也为了调整这个导致主题的一些模块出现了问题，正好趁\n着这个时候统一修正一下。\n\n\n顶部加载条#\n\n这个在上上个博客主题上曾经使用过，后来主题重写的时候没有带过来。偶然间在逛其它博客的时候发现了这个，于是心中燃起了希望，来弄一弄吧。\n加载条使用的是PACE这个js库。下载并在模板里引用js和css就可以了，灰常简单。\n\n\n\n默认theme提供了不同的加载条样式，也可以用css自定义自己的样式。\n\n\n菜单栏#\n\n每页统一起来，将菜单栏统一到了顶部。在Semantic中可以使用可视化API来模拟这种效果。\n\n这里就不做过多介绍了，具体可以参考一些例子和API文档。\n\n菜单栏放到页面中间行为表现正常，但是放到顶部就会出现一些问题，浮动的菜单栏提前加载出来了。找了一个临时解决方案，在页面最上方加上一个高度为1px的div。\n\n\n命令提示符#\n\n之前在Intellij官网看到右下角的shell窗口，感觉非常神奇，就想着给博客也弄一个，于是就找到了JQueryTerminal这个js插件。\n\n使用非常简单，下载并引入提供的js和css文件即可。提供一个div，调用$('#term_demo').terminal()命令就可以得到一个div命令行窗口，\n具体操作可以查看官网的api文档。\n\n安装之后也没有添加什么特别的效果，就一直扔在那里了，只能当做一个javascript命令解析器。最近想起来就给它增加了一些功能，比如清屏、帮助文档、回到顶部。之\n后有什么想法再慢慢给它加吧。\n\n如何优雅的展示这个窗口还是一个问题，现在暂时先把它扔在右下角了，但是看起来有点太碍眼了。。。怎么弄才好呢，怎么弄才好呢，怎么弄才好呢。。。\n\n\n首页倒计时#\n\n首页banner的位置本来预留出来放一些纪念性的图片，遇到什么大事件可以更换一下，给博客增加些喜气成分。不过总是处理不好尺寸问题，也就渐渐失去了信心了（不会前端\n硬上的后果，/(ㄒoㄒ)/~），最近在慕课网上看到了一个Canvas倒计时时钟的动画，于是拿来用一下吧。想象一下动画做的好的话首页效果还是挺赞的吧，吧？。。。\n脑洞 和 JS 缺一不可。。。\n\n等着吧，倒计时完成之前我会把动画做好的！\n\n\n分页和月份#\n\n一直没好好研究研究Hexo的配置文件_config.yml，然后就用着默认的，然后博客就出现了一些不和谐的地方，然后该修改修改配置文件了。\n\n分页问题。当时修改了首页的分页，但是分页也影响到 归档 、 标签\n等部分的显示，参考Hexo分页设置问题里面提到的，发现可以单独设置每种类别的分页，于是将归档和标签等分页的数值设置的非常大来间接避免分页的问题。\n\n归档按月份进行了分类，使用了Hexo内置的函数生成归档目录，可以在调用函数的时候配置显示的格式，这里显示了年月<%-\nlist_archives({format:\"YYYY年M月\"})\n%>，比以前好多了。还顺便抄了一个list样式，感觉自己萌萌哒~（有个表情就好了，感觉很有必要给博客加个表情啥的。。。）。。。\n\n\n响应式布局#\n\n由于博客使用了 Semantic UI 框架，虽然框架在某些特效方面很方便，但是对导航栏的响应式上却没有 Bootstrap\n那么方便。对于宽屏来说还是希望导航栏能展现尽可能多的项目，而移动端只需要显示主要的内容，其余内容提供二级菜单选项。宽屏使用浮动顶部菜单栏，而移动端在这方面很难处\n理。多次尝试之后，决定放弃顶部浮动效果，改为固定在页面顶端。\n\n另一部分响应式是页面底部，主要还是处理一下背景图片与文字的关系。经过这次调整，博客页面的整体布局已经统一起来。\n\n\n下一步？#\n\n从开始打算写一个博客模板到现在，经历了一段时间了。自己对设计也没有啥感觉，主要还是看其它模板的样式，喜欢的地方就借鉴过来。所以到现在，模板很多地方就会出现不太和\n谐的地方。\n\n下一步打算继续优化博客的模板，主要两个方向：一个是想精简框架，将不需要的模块去除。另一个是尝试用模块化方式书写博客的css，主要是为了方便的改变博客的风格（主题\n色）。当然也需要继续优化一些细节，毕竟不是专业的也不知能画出啥样子的瓢。。。","routePath":"/2016/01/21/note-for-2016-theme-improvement/","lang":"","toc":[{"text":"顶部加载条","id":"顶部加载条","depth":2,"charIndex":98},{"text":"菜单栏","id":"菜单栏","depth":2,"charIndex":257},{"text":"命令提示符","id":"命令提示符","depth":2,"charIndex":421},{"text":"首页倒计时","id":"首页倒计时","depth":2,"charIndex":772},{"text":"分页和月份","id":"分页和月份","depth":2,"charIndex":981},{"text":"响应式布局","id":"响应式布局","depth":2,"charIndex":1326},{"text":"下一步？","id":"下一步","depth":2,"charIndex":1568}],"domain":"","frontmatter":{"layout":"post","title":"2016博客模板改进","date":"2016-01-21 21:54:42","categories":["网站"],"tags":["模板","主题"]},"version":""},{"id":97,"title":"注解进阶：解析注解","content":"注解进阶：解析注解#\n\n上篇介绍了注解的基本知识和自定义注解，这篇文章来介绍如何在运行时解析注解。通过反射可以获得一些注解的信息，根据这些信息就可以进行一些操作。\n\n\n注解定义#\n\n要在运行时获得注解的信息，需要将注解的保留策略设置为RUNTIME。首先写一个测试用例。\n\n\n\n定义一个Info注解，适用于任何变量、类、方法，保留策略为运行时。\n\n然后需要一个被注解标注的类：\n\n\n\n定义了一个类，并用注解为类和类中的成员标注了信息。\n\n\n解析注解#\n\n上面已经定义好了注解和使用注解的类，下面尝试获取注解的信息。\n\n\n\n运行结果：\n\n\n\n这样就通过基本的反射方法获取了注解信息。注解API非常强大，被广泛应用于各种Java框架，如Spring，Hibernate，JUnit等。\n\n\n参考内容#\n\n * Java注解教程：自定义注解示例，利用反射进行解析","routePath":"/2016/01/19/advanced-annotation-runtime-resolution/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":342}],"domain":"","frontmatter":{"layout":"post","title":"注解进阶：解析注解","date":"2016-01-19 19:47:34","categories":["编程语言"],"tags":["java","annotation","注解"]},"version":""},{"id":98,"title":"Java注解及自定义注解入门","content":"Java注解及自定义注解入门#\n\n在编写Java代码中，我们可以经常可以看到注解的身影，常用的注解如@Override\n@Deprecated都不会太陌生。但是注解内部是如何工作的，这部分内容需要进一步去探究。\n\n\n注解#\n\n注解可以理解为注释和解释，是一种对方法、变量等地方的一种标注形式。我们可以理解为通过使用注解为代码附带了额外的信息。\n\n> Annotation是一种应用于类、方法、参数、变量、构造器及包声明中的特殊修饰符。它是一种由JSR-175标准选择用来描述元数据的一种工具。\n\n\n内建注解#\n\nJava提供了三种内建注解：\n\n 1. @Override\n    当我们想要复写父类中的方法时，我们需要使用该注解去告知编译器我们想要复写这个方法。这样一来当父类中的方法移除或者发生更改时编译器将提示错误信息。\n 2. @Deprecated 当我们希望编译器知道某一方法不建议使用时，我们应该使用这个注解。Java在 javadoc\n    中推荐使用该注解，我们应该提供为什么该方法不推荐使用以及替代的方法。\n 3. @SuppressWarnings 这个仅仅是告诉编译器忽略特定的警告信息，例如在泛型中使用原生数据类型。它的保留策略是SOURCE并且被编译器丢弃。\n\n\n元注解#\n\n元注解用来注解其它注解，标明注解的一些属性。有四种类型的元注解：\n\n 1. @Documented\n    指明拥有这个注解的元素可以被javadoc此类的工具文档化。这种类型应该用于注解那些影响客户使用带注释的元素声明的类型。如果一种声明使用Document\n    ed进行注解，这种类型的注解被作为被标注的程序成员的公共API。\n 2. @Target\n    指明该类型的注解可以注解的程序元素的范围。该元注解的取值可以为TYPE,METHOD,CONSTRUCTOR,FIELD等。如果Target元注解没有出\n    现，那么定义的注解可以应用于程序的任何元素。\n 3. @Inherited\n    指明该注解类型被自动继承。如果用户在当前类中查询这个元注解类型并且当前类的声明中不包含这个元注解类型，那么也将自动查询当前类的父类是否存在Inherit\n    ed元注解，这个动作将被重复执行知道这个标注类型被找到，或者是查询到顶层的父类。\n 4. @Retention 指明了该Annotation被保留的时间长短。RetentionPolicy取值为SOURCE,CLASS,RUNTIME。\n\n\n自定义注解#\n\n要创建自定义注解，需要注意以下问题：\n\n * 注解方法不能带有参数；\n * 注解方法返回值类型限定为：基本类型、String、Enums、Annotation或者是这些类型的数组；\n * 注解方法可以有默认值；\n * 注解本身能够包含元注解，元注解被用来注解其它注解。\n\n这里参照一个自定义注解的例子：\n\n\n\n在定义完注解之后，就可以在代码中使用自定义注解了。下面的例子包含了内置注解和自定义注解。\n\n\n\n这里使用注解的方式只是让方法带上了数据，而这些数据具体有什么用，带上数据的方法需要怎么处理还需要另外的代码逻辑来实现。\n\n\n参考内容#\n\n * Java注解教程及自定义注解\n * Java中的注解是如何工作的？","routePath":"/2016/01/17/java-define-and-use-annotation/","lang":"","toc":[{"text":"内建注解","id":"内建注解","depth":2,"charIndex":248},{"text":"元注解","id":"元注解","depth":2,"charIndex":545},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1333}],"domain":"","frontmatter":{"layout":"post","title":"Java注解及自定义注解入门","date":"2016-01-17 22:52:12","categories":["编程语言"],"tags":["java","注解","annotation"]},"version":""},{"id":99,"title":"【占坑】最大流算法","content":"#\n\n考试呀，没时间写了。。。","routePath":"/2016/01/15/max-flow-algorithm/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"【占坑】最大流算法","date":"2016-01-15 23:49:16","categories":["算法"],"tags":["最大流"]},"version":""},{"id":100,"title":"【占坑】xposed研究","content":"#\n\n没写东西呀没写东西。。。\n\n\n参考内容#\n\n * 深入理解Android（三）：Xposed详解\n * Android 系统上的 Xposed 框架中都有哪些值得推荐的模块？\n * Introspy-Android","routePath":"/2016/01/14/use-xposed-to-monitoring-function-invoke/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":17}],"domain":"","frontmatter":{"layout":"post","title":"【占坑】xposed研究","date":"2016-01-14 20:02:10","categories":["技术"],"tags":["android","xposed"]},"version":""},{"id":101,"title":"由一个小例子引出的Java异常处理机制","content":"由一个小例子引出的Java异常处理机制#\n\n大家对java异常处理可能再熟悉不过了，java很大一部分就是在与异常打交道，try...catch...finally再熟悉不过了。但是之前遇到了一个例子发现\n，原来异常处理并不是如我们想象那样如线性那么简单。\n\n\n引例#\n\n想过没有，如果在catch之后，throw与return的逻辑是怎样的？\n\n\n\n输出结果是\n\n\n\n从这里可以看出throw没有终止return的执行，但是return却把throw抛出的异常给去掉了。如果把return去掉的话，异常就可以正常抛出了。\n\n再考虑一个复杂的例子\n\n\n\n这个有点复杂，输出结果是\n\n\n\n\nJava异常#\n\nJava中所有的异常都有一个共同的祖先Throwable，从这个祖先分出两个大分支Error和Exception。\n\n * Error：是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java\n   虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现\n   OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。\n * Exception：是程序本身可以处理的异常。Exception又分为RuntimeException和其它。\n   * RuntimeException是运行时异常，如NullPointerException(空指针异常)、IndexOutOfBoundsExcepti\n     on(下标越界异常)等。这些异常在编码阶段无法检查，只有在运行时才能发现。一般这类异常都是由于逻辑错误引起的，Java编译器不会检查它，所以说不需要用\n     try-catch对其进行捕获，编译器也能编译通过。\n   * 其它是那些非运行时异常，这些异常都是在编码阶段需要考虑到的，如果没有正确处理，编译不会通过。\n\n\nJava异常处理机制#\n\nJava异常处理机制为：抛出异常、捕获异常。当异常发生时，运行时系统会寻找异常的解决方案，若当前方法没有能力解决该异常，异常会被抛向上一级继续寻找，直到找到该异\n常的解决方案或者异常到达了Java虚拟机。此时Java虚拟机会终止程序的运行，并打印异常的堆栈信息。\n\n> 一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。\n\n\n抛出异常#\n\n当一个方法出现错误的时候就会抛出异常，产生异常通常有两种方式：手动生成异常对象，通过throw方法交付运行时系统；由运行时系统自动生成并交付异常。\n\n手动抛出 使用throw方法可以手动生成异常并抛出\n\n\n\n这里的exceptionname可以是自定义的异常类或系统已有的异常类。throw能抛出的必须是Throwable的对象或子类对象，不能抛出任意对象。\n\n向上抛出\n\n前面说到，当异常抛出时，运行时系统会寻找异常的解决方案。如果当前方法没有能力（或没有必要）解决该异常，则需要将该异常抛出到调用该方法的上一级。方法是在方法定义的\n时候声明该方法无法（没必要）处理而需要向上抛出的异常。\n\n\n\n多个异常之间使用逗号分隔，用throws关键字声明。\n\n\n捕获异常#\n\n在java中通过try-catch捕获异常，一般语法形式为：\n\n\n\ntry后可以与多个catch块并列，当异常抛出时，java会依次检查catch语句块的类型，若相符则交给该语句块处理。\n这里需要注意两个问题，一是依次，检查顺序是从上向下，若找到匹配的则不再继续向下检查，未找到匹配的则向上抛出；二是匹配，什么样子的算匹配？抛出异常的类型与要cat\nch的类型一致或是其子类时就算是匹配了。\n还需要注意catch语句的排序问题，尽量按照从子类到父类的顺序排放，否则父类类型会截获抛出的异常导致子类类型的catch永远无法参与处理。\n\n讲到了try-catch语句块，再说一下try-catch-finally语句块：\n\n\n\nfinally语句表示无论是否出现异常，都应当执行里面的内容。 在以下4种特殊情况下，finally块不会被执行：\n\n 1. 在finally语句块中发生了异常。\n 2. 在前面的代码中用了System.exit()退出程序。\n 3. 程序所在的线程死亡。\n 4. 关闭CPU。\n\n讲到这里我突然想到一个问题，如果try中出现了没有被catch的异常，finally还会被执行吗？ 考虑下面的例子\n\n\n\n输出结果\n\n\n\n可以发现finally语句块里的代码还是被执行了。结合引例中的例子，抛出异常不同于return直接终止后面语句，而是需要处理完“本层”的事务。发现异常-匹配ca\ntch处理异常-处理finally-抛出未处理的异常。\n\n\n总结#\n\ntry、catch、finally语句块的执行顺序：\n\n 1. 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；\n 2. 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给J\n    VM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；\n 3. 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，\n    并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语\n    句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；\n\n\n\n\n自定义异常类#\n\nJava包含了一些内置的异常类，可以用来表示内部出现的异常。除了使用Java内置的异常类，也可以自定义自己的异常类。\n自定义的异常类需要继承Exception或RuntimeException，然后在相应位置抛出自定义异常类的对象；可以在当前位置使用try-catch处理异常，\n或者不处理用throws关键字声明需要调用者处理；调用者需要根据声明处理异常。\n\n\n参考内容#\n\n * 深入理解java异常处理机制","routePath":"/2016/01/08/java-exception/","lang":"","toc":[{"text":"引例","id":"引例","depth":2,"charIndex":130},{"text":"Java异常","id":"java异常","depth":2,"charIndex":293},{"text":"Java异常处理机制","id":"java异常处理机制","depth":2,"charIndex":869},{"text":"抛出异常","id":"抛出异常","depth":3,"charIndex":1071},{"text":"捕获异常","id":"捕获异常","depth":3,"charIndex":1406},{"text":"总结","id":"总结","depth":2,"charIndex":2046},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2684}],"domain":"","frontmatter":{"layout":"post","title":"由一个小例子引出的Java异常处理机制","date":"2016-01-08 22:54:50","categories":["编程语言"],"tags":["java","异常","exception"]},"version":""},{"id":102,"title":"Unicode \\u202e 介绍","content":"#\n\n\\u202e是个有趣的Unicode字符，它的特性是可以反转其他字符的显示顺序。\n字符串你好，给每个字符前面加上这个字符得到\\u202e你\\u202e好就变成了好你。 利用这种特性可以反反垃圾过滤。\n\n怎么输入Unicode，暂时只找到一种方式，通过在线网页中转。 https://www.cs.tut.fi/~jkorpela/fui.html8\n首先在左侧输入Go to U+ 202e，然后在右侧E列就可以找到这个字符了。\n点击一下会添加到右边的输入框，当然是看不见的，这时候还可以在右边输入汉字，之后可以发现汉字被成功反转了。之后Ctrl+A复制粘贴到合适的地方即可。\n比如要输入你好世界，按以下次序输入 \\u202e界\\u202e世\\u202e好\\u202e你，然后就出来了了。\n\n\n参考内容#\n\n * 前端农民工 - 新浪微博","routePath":"/2016/01/06/unicode-u202e/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":349}],"domain":"","frontmatter":{"layout":"post","title":"Unicode \\u202e 介绍","date":"2016-01-06 23:39:47","categories":["姿势"],"tags":["unicode"]},"version":""},{"id":103,"title":"【新年占坑】自己制作Cinemagraph效果","content":"#\n\n最近比较忙，也不知道忙啥，只好写一些占坑贴来充数了。。。挖的坑一定要填。。。\n\nCinemagraph是一种图片效果，主要针对GIF图片，背景为全静态，只有小部分在动，看起来效果灰常不错。有自己做一个的冲动。\n\n\n参考内容#\n\n * Cinemagraph - Wikipedia","routePath":"/2016/01/04/amazing-cinemagraph/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":109}],"domain":"","frontmatter":{"layout":"post","title":"【新年占坑】自己制作Cinemagraph效果","date":"2016-01-04 23:23:21","categories":["艺术人生"],"tags":["photo","cinemagraph"]},"version":""},{"id":104,"title":"emoji在Github也在Twitter","content":"emoji在Github也在Twitter#\n\nGithub\n是全球最大的“同性”交友网站(￣ε(#￣)☆╰╮(￣▽￣///)，不对不对，是最大的代码分享网站。就gayhub来说(￣ε(#￣)☆╰╮(￣▽￣///)，就网页\n版的github来说，有很多丰富的功能（快捷键啦、命令行跳转啦）。这里介绍一下github的emoji功能。\n\n\n效果#\n\ngithub上的emoji可以用在几乎所有可以显示文字的地方。比如简介、README、提交说明、项目Wiki页等。具体能用在哪里大家可以自己尝试一下。\n\n\n使用#\n\n使用emoji很简单。由于不能插入图片，所以需要通过一些特殊符号来插入。 比如:blush:就会变成\n\n在提交信息的时候可以\n\n\n\n具体emoji和对应名可以参考http://www.emoji-cheat-sheet.com/。\n\n\n支持的网站#\n\n不仅仅是Github，还有一些地方支持这种emoji格式。\n\n> A one pager listing the different emoji emoticons supported on Campfire,\n> GitHub, Basecamp Next, Teambox,Plug.dj, Flowdock, Sprint.ly, GitLab, Kandan,\n> andbang, Trello, Hall, Qiita, Trello, Zendesk, Ruby-China, Grove,Idobata,\n> NodeBB Forums, Slack, Streamup, Quip, OrganisedMinds, and Hackpad.\n\n\ntwemoji#\n\n今天在闲逛的时候偶然发现了Twemoji，这是Twitter开源的完整的Emoji表情图片。开发者可以去Github上下载完整的表情库，并将其用到自己感觉高大上\n的地方。 效果展示 首先引入js库\n\n\n\n然后调用twemoji.parse( ... )函数来解析emoji。 如\n\n\n\n不仅可以来解析string也可以来解析DOM。\n\n\n\n具体怎么使用可以参考github上面的介绍。\n\n\n参考内容#\n\n * EMOJI CHEAT SHEET\n * arvida/emoji-cheat-sheet.com\n * 代码提交的时候可以插入表情了-GitHub表情的使用\n * twem❤ji","routePath":"/2016/01/02/use-emoji-in-github-and-emoji-cheat-sheet/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":919}],"domain":"","frontmatter":{"layout":"post","title":"emoji在Github也在Twitter","date":"2016-01-02 20:00:32","categories":["高效生活"],"tags":["emoji","github","twitter","twemoji"]},"version":""},{"id":105,"title":"2016新年快乐","content":"#\n\n> 2016新年快乐。\n\n不知不觉时间过得很快，2016年就这么来到了。首先要感谢2015一起走过的点点滴滴。\n\n一切仿佛如梦一般，感觉只是放了一个暑假。结果梦醒之后一切都变了。我不想知道你们都去了哪里，只是希望你们过得都好。\n\n为什么会这样呢？是在梦里过得太舒坦了，还是现实本来就是这么残酷。\n\n努力使自己变得漠然吧，曾经苦笑自己说：自己修复了自己的一个bug:-D。只是feature而已，用在了不恰当的地方了，于是就变成了bug。不仅困扰了我，也困扰了\n你。\n\n很多时候感叹为啥作业没写，为啥什么都没做，然后眼一闭一睁，一天就过去了，然后一周就过去了，就这样2015年过去了。想着2016年好好加油吧。哎，连我自己都不信这\n句话。\n\n为什么为什么为什么，恰恰就是有那么多为什么，每一个为什么的背后都在感叹一些不公平吧，不能说不能做也没有人为你解答。\n\n每次走过那里，看到那只猫，忽然觉得它好幸福，独居一房，居然还是三环以内，好多美女都会过去瞅上一眼呐，猫盆里的食物也不知道是哪位好心人的恩惠。\n\n想起离校的前一天晚上，大家躺在操场的草坪上，看着天空的星光，我还能记得哪个是猎户座，那是每次回家都能看到的星座。好想就这样下去呀。。。离校那天，同学一起去送我，\n之前大家拍了好多照片，我都没有要，回忆就让他成为回忆去吧，谁让我那么死要面子的？那天的我大概又哭了吧。\n\n牛奶咖啡又有新专辑了呢，每次看的时候都会对自己说，等以后有钱了一定要买。\n\n低落了有一个月了，但还是庆幸自己挺了过来。我一直在想难道之前我那么做一直都是错的吗？\n\n再见了2015，再见了曾经的小伙伴们，记得常联系我，不然真会把你们忘记的。\n\n2016，新的开始。没有计划，没有目标。Just For It。\n\n我很快乐吧，那么你们呢？\n\n\n\n新年剁手愉快。","routePath":"/2016/01/01/happy-new-year-2016/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"2016新年快乐","date":"2016-01-01 20:13:56","categories":["随笔"]},"version":""},{"id":106,"title":"单例模式及单例模式实践","content":"#\n\n单例模式应用广泛，而且是我最喜欢的模式。简单介绍一下单例模式吧。\n\n单例模式保证只有一个实例，每次取到的都是同一个实例。基本方法是将构造函数设为私有，并导出公有的静态成员。\n\n\n标准单例#\n\n\n懒汉式#\n\n懒汉式在类初始化时就实例化一个对象。\n\n\n\n\n饿汉式#\n\n饿汉式只有真正需要对象的时候才开始实例化对象。\n\n\n\n\n单例的线程安全#\n\n上面的两种写法对于普通情况下就挺好的，但是在复杂情况下，容易出现一些问题。下面考虑多线程情况下如何进行。\n\n\n懒汉式，线程安全#\n\n对于懒汉式，只要保证getInstance()方法是线程安全的即可。\n\n\n\n但是这样效率比较低，每次只能有一个线程取到对象。由于只需要在创建对象的时候保证同步，所以就引出了双重检验所的方式\n\n\n\n这样写虽然看起来很美妙，但是却不是线程安全的。原因在于instance = new\nSingleton();这个语句不是原子操作。大体上JVM在初始化对象的时候会进行以下操作：\n\n 1. 给 instance 分配内存\n 2. 调用 Singleton 的构造函数来初始化成员变量\n 3. 将 instance 对象指向分配的内存空间（执行完这步instance就为非null了）\n\n但是JVM的编译器可能存在指令重排序的问题。也就是说上面的顺序不能保证是1-2-3。如果顺序是1-3-2，在执行完3后，被其它线程抢占了，这是由于instanc\ne是非null（但没有初始化），第一次check返回false，所以线程二回直接返回instance，然后使用时可能就会出现错误。\n\n所以需要将instance变量声明成volatile即可。\n\n\n\n提到了volatile不得不再说明一下。我对这个关键字也不是很了解，也只能说个大概。 维基百科里写到\n\n> 当volatile用于一个作用域时，Java保证如下：\n> \n>  1. （适用于Java所有版本）读和写一个volatile变量有全局的排序。也就是说每个线程访问一个volatile作用域时会在继续执行之前读取它的当前值\n>     ，而不是（可能）使用一个缓存的值。(但是并不保证经常读写volatile作用域时读和写的相对顺序，也就是说通常这并不是有用的线程构建)。\n>  2. （适用于Java5及其之后的版本）volatile的读和写建立了一个happens-before关系，类似于申请和释放一个互斥锁。\n> \n> 使用volatile会比使用锁更快，但是在一些情况下它不能工作。volatile使用范围在Java5中得到了扩展，特别是双重检查锁定现在能够正确工作。\n\n用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。\n这里使用volatile的原因是：禁止指令重排序优化。JVM在编译的时候会尽量避免重排优化用volatile修饰的变量的读写指令，是读操作避免优化到写操作之前。\n这样保证了时间顺序的正确性。\n\n所以，对于关键字volatile的具体使用有待深入研究，这里也不过多讨论了。\n\n\n饿汉式，线程安全#\n\n饿汉式由于是静态变量形式，本来就是线程安全的。\n\n\n复杂单例#\n\n除了上面的通常写法，这里还有一些复杂的写法，主要是通过Java数据结构的特性来保证单例的正常实现。\n\n\n静态内部类#\n\n静态内部类的线程安全是通过JVM本身的机制来保证的。\n\n\n\n> 由于 SingletonHolder 是私有的，除了 getInstance()\n> 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n\n单元素枚举型单例#\n\n通常使用下面的方式声明\n\n\n\n这样直接可以通过EasySingleton.INSTANCE来访问实例。\n\n单元素枚举型单例不仅写法简单，而且这样有三个好处：\n\n 1. 线程安全\n 2. 不会因为序列化而产生新实例\n 3. 防止反射攻击\n\n可以说：单元素的枚举类型已经成为实现Singleton的最佳方法。\n\n\n参考内容#\n\n * 枚举类型的单例模式(java)\n * 如何正确地写出单例模式\n * java中volatile关键字的含义","routePath":"/2015/12/27/effective-java-for-singleton/","lang":"","toc":[{"text":"标准单例","id":"标准单例","depth":2,"charIndex":91},{"text":"懒汉式","id":"懒汉式","depth":3,"charIndex":99},{"text":"饿汉式","id":"饿汉式","depth":3,"charIndex":128},{"text":"单例的线程安全","id":"单例的线程安全","depth":2,"charIndex":162},{"text":"懒汉式，线程安全","id":"懒汉式线程安全","depth":3,"charIndex":227},{"text":"饿汉式，线程安全","id":"饿汉式线程安全","depth":3,"charIndex":1310},{"text":"复杂单例","id":"复杂单例","depth":2,"charIndex":1347},{"text":"静态内部类","id":"静态内部类","depth":3,"charIndex":1406},{"text":"单元素枚举型单例","id":"单元素枚举型单例","depth":3,"charIndex":1546},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1712}],"domain":"","frontmatter":{"layout":"post","title":"单例模式及单例模式实践","date":"2015-12-27 22:14:08","categories":["编程语言"],"tags":["java","设计模式","单例模式"]},"version":""},{"id":107,"title":"Markdown说明","content":"#\n\n最近也没有好好研究些东西，只好写这些小文章凑凑字数，就当做是一种复习吧。\n初识Markdown还是在刚刚使用Github的时候，当时候的感觉就是：哇塞，好神奇的东西。如同得到了一个锤子一般，总想把各个东西敲个遍。就这样使用Markdo\nwn开始了在Github上的博客之旅。 就简单说一下Markdown的语法标记吧。\n\n\n常用标记#\n\n\n标题#\n\n标题可以对应html的标签，只要在每行的前面加上#即可\n\n\n\n以此类推，共提供了六级标题。 另外也可以在标题下一行加三个以上的-或=来分别表示二级标题和一级标题\n\n\n\n\n列表#\n\n列表分为有序列表和无序列表，对应html中的和标签。 有序列表是在每一行前面加数字和点，顺序无所谓，Markdown引擎会自动排序。\n\n\n\n出来的效果如下：\n\n 1. 列表1\n 2. 列表2\n 3. 列表3\n 4. 列表4\n 5. 列表5\n\n无序列表是在每一行前面加+``-``*，可以混合使用。\n\n\n\n效果如下，我比较喜欢使用+。\n\n * 列表1\n\n * 列表2\n\n * 列表3\n\n * 列表4\n\n当然也可以给列表加子列表：\n\n\n\n * 1\n   * 1.1\n   * 1.2\n * 2\n\n\n格式#\n\n格式有三种，粗体、斜体、删除线。 PS: 博客使用了js插件会将斜体解析成着重号。\n\n\n\n\n引用#\n\n引用外部一段文字，可以使用\n\n\n\n> Hello World!\n> \n> > Hello World too!!!\n\n\n链接#\n\n可以给文字加上超链接，超链接有两种，一种普通，另一种引用\n\n\n\n点我没用 [点我][1] [1]:javascript:alert('你好');\n\n引用像不像参考文献。。。\n\n\n图片#\n\n在链接前面加上叹号就变成图片了。\n\n\n\n![favicon][2] [2]:/favicon.ico\n\n\n表格#\n\n表格这东西太麻烦了，先抄一个简单说一下\n\n\n\nTABLES          ARE             COOL\ncol 3 is        right-aligned   $1600\ncol 2 is        centered        $12\nzebra stripes   are neat        $1\n\n第二行的冒号表示对齐方式，没有冒号或冒号在左边是左对齐，左右都有冒号是居中对齐，右边有冒号是右对齐。\n\n\n分隔线#\n\n三个连续的下划线或者星号单独一行就是分割线了。\n\n\n\n---------分隔条开始----------\n\n--------------------------------------------------------------------------------\n\n--------------------------------------------------------------------------------\n\n---------分隔条结束----------\n\n\n常用工具#\n\n稍微介绍一下Markdown的工具吧。\n\n一般文本编辑器都可以用来写Markdown，但是有的不支持实时预览。我现在用vscode和atom支持实时预览。当然有的神级编辑器装插件就可以了。。。以后写熟悉\n了基本上用不到实时预览了。 另外可以使用在线的Markdown编辑器，这个一搜有好多。还是推荐一个Cmd Markdown吧。\n\n祝写作愉快。\n\n\n参考内容#\n\n * Markdown入门学习\n * markdown学习笔记","routePath":"/2015/12/26/markdown-language-tutor/","lang":"","toc":[{"text":"常用标记","id":"常用标记","depth":2,"charIndex":164},{"text":"标题","id":"标题","depth":3,"charIndex":172},{"text":"列表","id":"列表","depth":3,"charIndex":262},{"text":"格式","id":"格式","depth":3,"charIndex":514},{"text":"引用","id":"引用","depth":3,"charIndex":565},{"text":"链接","id":"链接","depth":3,"charIndex":630},{"text":"图片","id":"图片","depth":3,"charIndex":724},{"text":"表格","id":"表格","depth":2,"charIndex":782},{"text":"分隔线","id":"分隔线","depth":2,"charIndex":1010},{"text":"常用工具","id":"常用工具","depth":2,"charIndex":1260},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1443}],"domain":"","frontmatter":{"layout":"post","title":"Markdown说明","date":"2015-12-26 22:09:33","categories":["高效生活"],"tags":["markdown"]},"version":""},{"id":108,"title":"用安卓手机获得三星卡背及卡包","content":"#\n\n圣诞快乐。之前在浏览卡背收藏的时候就看到过三星的卡背，一直很好奇这个是怎么获得的。网上一搜原来是官方与三星合作推出的活动，有三星S6手机登录游戏就可以获得。而且\n貌似可以伪装手机型号进行欺骗。于是找了一个教程开始了卡包之旅。 卡包卡背我来了！\n\n\n卡包卡背我来了#\n\n根据教程的指示，核心思路是修改build.prop文件伪装手机型号。 首先将手机root，已经root了，跳过。\n然后用re文件管理器打开系统根目录找到/System下的build.prop文件。挂载成读写模式，先复制一份备份一下，修改这个文件，参考以下条目修改：\n\n\n\n主要是ro.product.model=SM-G9200这一条，主要不要写错了。 保存退出，重启手机。 然后。。。\n\n\n操作失误#\n\n原来觉得很简单，结果中间还是有个步骤操作失误了。因为为了修改这个文件修改了文件权限，而没有将其改回来。系统检查文件权限失败，开机就卡在启动画面了。\n难道要重刷手机？！！！不过似乎不用，根据经验判断，似乎可以通过recovery解决，谷歌之后果然可以。\n首先需要recovery支持adb模式。手机使用的是twrp的recovery，应该是支持的，具体可以重启到recovery里，然后adb试一试。\n\n\n\n检测到设备就是支持的，之后adb shell连上去，进入/System目录，将文件权限修改成644 chmod 644 build.prop，重启。\n\n\n\n\n来不容易去也难#\n\n系统成功进入，也很顺利取到了卡背，但是怎么修改回去呢？\n之前做了一个备份，将备份替换回来就可以了。但是不知为什么文件管理器却获取不到root权限了，只好重启再去recovery里进行操作。\n\n\n\n先将现在的build.prop改成build.prop.bak。接下来把build - 复制.prop改成build.prop即可。 但是，cmd里的adb\nshell终端居然无法输入中文，中文输入之后显示??。 再三思考之后，可以使用ls出来的文件名结果，然后直接传到mv命令里。 试了很多次，精简的命令如下：\n\n\n\n大体思路就是列出所有build开头的文件，然后以两个空格做分割，取第一份保存到file变量里。取到变量之后直接重命名即可。 算是曲线救国的一种方法。\n\n\n卡包卡背#\n\n经历了上面那么多，别忘了截图欣赏一下呀。\n\n\n\n\n\n\n参考内容#\n\n * 炉石传说如何用普通安卓手机领取三星卡背及S6卡包\n * build.prop文件权限导致的不能开机问题解决","routePath":"/2015/12/25/got-heartstone-samsung-card-back-and-card-pack-with-something-wrong/","lang":"","toc":[{"text":"卡包卡背我来了","id":"卡包卡背我来了","depth":2,"charIndex":126},{"text":"操作失误","id":"操作失误","depth":2,"charIndex":332},{"text":"来不容易去也难","id":"来不容易去也难","depth":2,"charIndex":621},{"text":"卡包卡背","id":"卡包卡背","depth":2,"charIndex":966},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1000}],"domain":"","frontmatter":{"layout":"post","title":"用安卓手机获得三星卡背及卡包","date":"2015-12-25 20:20:07","categories":["游戏人生"],"tags":["heartstone","卡背","卡包","recovery","adb","shell"]},"version":""},{"id":109,"title":"trove4j大数据环境下的Collections库","content":"#\n\n平安夜快乐。。。今天在写词分析的器的时候，发现了一个问题。由于要计算两个词之间的cos距离，需要保存向量，于是将数据结构设计成Map>。数据结构问题解决了，但是\n数据文本有2G多，程序加载数据到一半就GC了。\n刚开始还以为是数据太大的原因，之后去StackOverflow上稍微搜索了一下，有人提到了一种答案，感觉比较靠谱，尝试了一下果然可以。\n\n\ntrove4j#\n\n根据上面回答中提到的内容，按图索骥找到了这个库。trove4j支持原生类型，这与Java的Collections只能使用包装类型不同。原生类型比包装类型更节省空\n间。这在大数据环境下是很必要的。 例如，上面的Map>就可以写成\n\n\n\n基本的操作方法与Java原生Collections中的方法大体相同。 在使用中发现的一点不同就是迭代器的不同，trove4j为每种类型单独定义了迭代器。\n\n\n\n这样可以让迭代器更好的返回原生类型。\n\n\n为什么#\n\nJava默认的Collections为什么消耗内存，这就需要从Java的Class结构开始说起。 这里简单说一下Class各部分的内存占用大小（以32位为例）：\n\n * Obejct Header 包括一些简单的信息\n * Primitive Fields 原生类型占用，根据它们的大小分配\n * Reference Fields 引用类型占用，统一为4字节\n * Padding 占位符，用来补齐进行内存对其\n\nObject Header 普通的类需要8个字节，数组需要12个字节（8个字节的类+4个字节的数组长度）。 Primitive Fields 的占用如下表\n\nJAVA TYPE   BYTES REQUIRED\nboolean     1\nbyte        1\nchar        2\nshort       2\nint         4\nfloat       4\nlong        8\ndouble      8\n\n那么一个普通的Double类在32位上占用的空间为：\n\n> 8字节头部 8字节double 0字节对齐 总共占用16字节的长度。\n\n这里只是大体看了一下，具体计算方法还要继续研究。\n\n\n其它#\n\n在文章中还提到了一个叫Fastutil的库，似乎比trove4j更好，但是trove4j更轻量级，有空再看看。\n\n\n参考内容#\n\n * trove4j:大数据下的轻量Java Collections库\n * Fastutil vs. Trove4j\n * Memory usage of Java objects: general guide","routePath":"/2015/12/24/use-trove4j-collections/","lang":"","toc":[{"text":"trove4j","id":"trove4j","depth":2,"charIndex":177},{"text":"为什么","id":"为什么","depth":2,"charIndex":405},{"text":"其它","id":"其它","depth":2,"charIndex":930},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":993}],"domain":"","frontmatter":{"layout":"post","title":"trove4j大数据环境下的Collections库","date":"2015-12-24 22:08:04","categories":["编程语言"],"tags":["java","collections","库"]},"version":""},{"id":110,"title":"终物语","content":"#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","routePath":"/2015/12/23/some-screenshots-of-owarimonogatari/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"photo","title":"终物语","date":"2015-12-23 22:00:40","categories":["动漫"],"tags":["动漫","截图"]},"version":""},{"id":111,"title":"Java泛型二三事","content":"#\n\n泛型（Generic\nType）是Java中重要的一部分。在使用Java标准库中的内容的时候，经常会遇到泛型。这里将知道的泛型部分内容总结一下。以后遇到新的内容还会继续补充。\n\n\n什么是泛型#\n\n讨论一个内容的时候，首先会来说什么是什么。在官方的文档中说到\n\n> A generic type is a generic class or interface that is parameterized over\n> types.\n\n泛型又可以称作参数化类型，这是在Java SE新增添的特性。一对尖括号，中间包含类型信息。将类型独立成参数，在使用的时候才指定实际的类型。\n\n如果没有泛型会怎么样？我们考虑以下几种情况：\n\n 1. 你实现了一个存储整数类型（Integer）的列表，这时候你又需要存储字符串（String）的列表，两种列表逻辑行为完全一样，只是存储的类型不同。\n 2. 为了保证列表的通用性，你将列表的类型改为了Object，这样就不用为类型修改代码了。但是每次从列表中取对象的时候都需要强制转换，而且很很容易出错。\n\n有了泛型之后，可以将逻辑相同类型不同的代码独立出来，由编译器负责进行类型转换。\n\n\n泛型的声明#\n\n\n泛型方法（Generic Method）#\n\n泛型方法是在普通方法声明上加入了泛型。\n\n\n\n调用：\n\n\n\n输出：\n\n\n\nJava泛型方法的声明格式如下：\n\n\n\n泛型的声明，必须在方法的修饰符（public,static,final,abstract等）之后，返回值声明之前。可以声明多个泛型，用逗号隔开。泛型的声明要用<\n>包裹。\n\n泛型方法的使用有两种：\n\n类型推导 以声明键值对的例子来说，通常的写法会有一长串，不免有些痛苦。\n\n\n\n我们可以构造一个泛型方法作为静态工厂，来完成这一操作。\n\n\n\n编译器在编译代码的时候推导出了K, V分别对应的类型。当然，编译器的推导能力也是有限的，这里也就不过多讨论了。 指定类型\n\n\n泛型类（Generic Class）#\n\n泛型类和普通类的声明一样，只是在类名后面加上了类型表示。就像泛型方法，泛型类可以有一个或多个类型表示，用逗号进行分隔。\n\n\n\n输出：\n\n\n\n在泛型类上声明的类型，可以被用到类中任何表示类型的地方。\n泛型类只能通过以指定类型的方式进行使用。在之后的Java版本中，加入了类型推导功能，可以将后面的泛型类型省略，但是还是需要保留尖括号。\n\n\n\n\n泛型接口（Generic Interface）#\n\n泛型接口是在声明接口的时候指定，类在继承接口的时候需要补充泛型类型。\n\n\n\n然后定义一个类实现这个接口\n\n\n\n可以发现实现接口里的方法需要使用具体的类型。 泛型接口的一般格式：\n\n\n\n当然，我们可以实现泛型接口的时候不指名泛型类型，这样这个类就需要定义为泛型类。\n\n\n\n\n泛型标识与泛型通配符#\n\n理论上泛型标识可以使用任意的字母或字母序列，可以考虑以下的例子，但是不推荐这样使用\n\n\n\n但是Java内部有一套自己的规范，这样在阅读JDK代码的时候会更加明确泛型标识的含义。\n\n\n\n说到泛型标识符，再说一说泛型通配符。常用的泛型通配符有三种。\n\n**任意类型 - 可以理解为泛型中的 Object`，为什么这么说呢？因为任意类型的通配符可以接受任意类型的泛型。下面的例子表示出了这种关系\n\n\n\n类似于将后面的类型转换到前面的类型。但是只能用作接收，不能用来定义，下面的例子是错误的\n\n\n\n上限类型 - 表示泛型只能使用这个类或这个类的子类。举个例子\n\n\n\n在该方法中调用sayHello(\"xiaoming\");是正确的，但是调用sayHello(2333);就是错误的。 考虑一种更通用的情况\n\n\n\n这个例子指定了泛型类的具体类型的范围。在JDK中经常可以看到这样的使用方法。\n\n下限类型 - 同上限方法， 表示泛型只能使用这个类或这个类的父类。 这里就不再举例子了。\n\n\n泛型二三事#\n\n\n类型擦除#\n\n泛型只在编译时有效，编译成字节码的过程中会进行类型擦除的操作。当然并不是所有的泛型类型都被擦除，有些也会保留下来。 一个简单的类型擦除的例子：\n\n\n\n我们对其编译，然后再反编译，反编译引擎用的CFR：\n\n\n\n从上面的结果可以看出，泛型类上面的类型被去掉了，但是增加了一个类型强制转换。解释器默认认为里面的类型都会是String。这是因为在编译的时候会进行类型检查，如果\n发现使用的类型与泛型声明类型不符，编译是不会通过的。\n那能不能绕过这个检查呢？这个时候就需要使用反射来进行操作了。就上面的例子来说，ArrayList可以放入任意类型，所以使用反射只要保证类型强制转换不出问题，程序\n还是可以使用的。\n\n在Java文档中提到，类型擦除主要进行以下工作：\n\n * 将泛型中的所有类型参数更换成类型界限，或者无界的类型替换成Object。所以生成的字节码只包含普通类、接口和方法。\n * 为了确保类型安全，必要时插入强制类型转换\n * 生成桥接方法保持扩展泛型类型中的多态性\n\n\n可变参数#\n\n使用泛型方法可以使用可变参数：\n\n\n\n可以发现编译器很好的处理了这些，里面的具体原理还有待继续研究。\n\n\nnew T()?#\n\n你可能会很好奇，能不能在泛型方法（类）中创建泛型类型的实例呢？ 答案是不可以的\n\n\n\n不过可以使用反射来创建实例\n\n\n\n因为类型擦除的缘故，部分类型信息会丢失，我们在运行时不会获取到相应的类型，所以也就无法将该类型实例化成对象。\n\n\n泛型和数组#\n\n在Java中，直接创建泛型数组是非法的。泛型设计的初衷是为了简化程序员类型转换的操作，保证类型安全。数组是协变的，如果Sub为Super的子类型，那么数组Sub\n[]就是Super[]的子类型。这样做就很难保证存储上的安全。\n\n但在实际使用过程中，往往需要创建泛型数组：\n\n\n\n这个时候运行程序，会抛出异常\n\n\n\n在这种情况下，可以使用列表来代替数组\n\n\n\n但是，Java不是生来就有List的，如果遇到必须使用数组的情况该怎么办？\n\n在这里可以参考Java里聚合类型的实现，以一个简单的例子说明\n\n\n\n上面的例子和java.util.Stack还是有区别的，只是为了说明如何处理泛型数组问题。\n\n同样运行的时候会出错\n\n\n\n一种方法是在创建泛型数组的时候创建一个Object数组，然后转换成E数组。\n\n\n\n第二种方法将数组类型改为Object，在弹出元素的时候进行转换\n\n\n\n数组和泛型有着不同的规则和特性，一般来说不能很好的混用。如果混合起来的时候，请注意编译器的警告和错误，保证在类型问题上不要出现问题。\n\n\n参考内容#\n\n * Java总结篇系列：Java泛型\n * Java泛型详解\n * Java - Generics\n * 学习：Java泛型之二（泛型方法）\n * Lesson: Generics\n * Java泛型：泛型类、泛型接口和泛型方法\n * Java泛型中E、T、K、V等的含义\n * Java泛型与类型擦除\n * Restrictions on Generics","routePath":"/2015/12/15/java-generic-type-one-two-and-three/","lang":"","toc":[{"text":"什么是泛型","id":"什么是泛型","depth":2,"charIndex":92},{"text":"泛型的声明","id":"泛型的声明","depth":2,"charIndex":511},{"text":"泛型方法（Generic Method）","id":"泛型方法generic-method","depth":3,"charIndex":520},{"text":"泛型类（Generic Class）","id":"泛型类generic-class","depth":3,"charIndex":833},{"text":"泛型接口（Generic Interface）","id":"泛型接口generic-interface","depth":3,"charIndex":1025},{"text":"泛型标识与泛型通配符","id":"泛型标识与泛型通配符","depth":2,"charIndex":1187},{"text":"泛型二三事","id":"泛型二三事","depth":2,"charIndex":1639},{"text":"类型擦除","id":"类型擦除","depth":3,"charIndex":1648},{"text":"可变参数","id":"可变参数","depth":3,"charIndex":2094},{"text":"new T()?","id":"new-t","depth":3,"charIndex":2154},{"text":"泛型和数组","id":"泛型和数组","depth":3,"charIndex":2282},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2748}],"domain":"","frontmatter":{"layout":"post","title":"Java泛型二三事","date":"2015-12-15 23:01:14","categories":["编程语言"],"tags":["java","泛型"]},"version":""},{"id":112,"title":"SSH中配置public key认证","content":"#\n\n一般使用SSH登录远端主机的时候，都会使用用户名和密码的方式。为了使远端主机安全，密码会设置的很复杂，这样登录的时候也会有一定的麻烦。\n在远端主机使用public key的方式登录，可以免除输入密码。因为今天剁手买了个主机，还没有自己设置过免密码登录，所以就来记录一下大致过程。\n\n\n本地#\n\n先要在本地生成rsa公钥和私钥，这里我的shell使用的是Git for Windows里的终端。 如果已经有公钥了，可以跳过这一步，直接使用以前生成的公钥。\n\n\n\n一般一直按回车就可以了。\n\n之后可以在用户文件夹里的.ssh文件夹下找到公钥文件id_rsa.pub，打开该文件，记录下里面的内容。\n\n\n远端#\n\n通过普通SSH登录到远端主机，以root用户为例： 进入~/.ssh文件夹，如果没有该文件夹需要自行创建\n\n\n\n注意权限设置为700。\n\n进入后找到authorized_keys文件，如果没有也需要创建\n\n\n\n权限需要设置为600。 如果权限不这样设置，SSH服务是不会使用里面的内容的。\n\n将本地id_rsa.pub的内容添加到authorized_keys中，可以添加多个public key，注意一行一个。\n\n基本上这样就可以使用了。\n\n\n参考内容#\n\n * ssh key 免密码登录\n * 使用Public Key (OpenSSH) 不用密码登陆","routePath":"/2015/12/14/set-up-SSH-public-key-authentication/","lang":"","toc":[{"text":"本地","id":"本地","depth":2,"charIndex":144},{"text":"远端","id":"远端","depth":2,"charIndex":301},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":529}],"domain":"","frontmatter":{"layout":"post","title":"SSH中配置public key认证","date":"2015-12-14 22:42:25","categories":["高效生活"],"tags":["ssh","linux"]},"version":""},{"id":113,"title":"尝试Android Emulator Preview模拟器","content":"#\n\n很早就听说Android Studio发布了2.0preview版本，今天又看到连最新的模拟器也可以使用了。\n对于之前老的Android官方模拟器一直有一些意见，最大的问题是启动慢和运行卡（机子太烂也不能这样摔锅）。虽然可以使用HAXM技术加速，但是效果还是不太明显。曾\n一度使用Genymotion模拟器，最后就直接上真机了。 虽然有这些问题，但新版本发布了还是要来体验一番的。\n\n\n安装更新Android Studio 2.0 & Preview SDK Tools#\n\n要想体验最新版Android模拟器，需要在Android Studio下将Android SDK更新到Preview版本。 首先打开Android\nStudio，选择File -> Settings找到Updates，修改Automatically check updates for Android\nSDK到Preview Channel渠道。\n\n\n\n之后选择Help -> Check for Update...就可以检查更新。请自备梯子。 建议使用额外的SDK\nManager进行更新，这里会看到一条Preview下的SDK Tools选项。安装这个，其它的镜像可以随喜好安装。\n\n\n\n这样就更新完毕了。\n\n\n创建新的Android虚拟设备(AVD)#\n\n为了有更好的体验，还是建议重新创建一个AVD。 在Android Studio中打开AVD Manager：\n\n\n\n选择**Create Vietual Device...**开始创建新设备：\n\n\n\n选择一个分类和设备类型，这里选择Nexus 6P：\n\n\n\n选择一个系统镜像，这里选择Lollipop x86 Android 5.1 (with Google APIs)：\n\n\n\n这里可以按照自己的需要修改设置，特别提示一下高级选项Show Advanced Settings里可以设置CPU的核心Multi-Core CPU：\n\n\n\nFinish之后点击绿色的箭头就可以启动虚拟机了：\n\n\n\n之后可以看到虚拟机的初始化界面，然后虚拟机就启动了。\n\n\n\n\n虚拟机特性#\n\n这篇博客里提到了虚拟机的一些特性，这里来列举一下：\n\n 1. 性能提升，主要体现在CPU（CPU Performance）和ADB（Faster ADB）上。这个感觉不太直观。\n 2. 用户界面优化：\n    * 工具栏——提供了虚拟机最常用的操作，电源键、音量键、屏幕放置、截图、屏幕缩放、返回、主菜单、最近任务、设置。\n    * 窗口放大和缩放——提供便捷的方式缩放屏幕\n    * 拖拽——将APK拖进模拟器窗口就可以安装，这个比较赞。其它类型的文件测试不成功，后续可能会增加\n    * 拓展UI控制面板——可以在这里设置模拟器的各种环境参数，例如电话、短信、充电电池状态、GPS等\n\n相比较来说，虚拟机易用性确实提高了不少。\n\n\n虚拟机存在的问题#\n\n由于还在预览版阶段，模拟器还存在一些问题，例如未响应、各种参数无法使用等。一般来说还是要等稍微稳定一点才能用。\n\n>  * Emulating inbound phone call freezes emulator.\n>  * Screenshot feature crashes emulator in certain conditions\n>  * If an AVD has been opened in a previous version of the emulator, it may not\n>    boot in the new emulator, therefore create a new AVD.\n>  * OSX - screen doesn't go black when you sleep the device\n>  * Linux - segfault on exit in some conditions\n>  * \"-gpu mesa\" option not supported\n>  * \"-net*\" option not supported\n>  * \"-no-window\" option not supported\n>  * Remote desktop not supported\n>  * Emulated hardware \"recents\" key doesn't work in older system images\n>  * Multiple DNS servers not supported\n\n我在启动模拟器的时候会出现一些问题：\n\n\n\n但似乎等一段时间模拟器还是能启动起来，初步推断是模拟器有些错误需要报告，结果找不到可以在64位下报告的服务。\n\n\n安装CPU加速器(HAXM)#\n\n如果在意的话可以安装一下最新版的CPU加速器，这个在SDK Manager中选中Intel x86 Emulator Accelerator (HAXM\ninstaller)下载，之后可以在path\\to\\sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manage\nr下找到。\n\n\n参考内容#\n\n * Getting Started Guide for Android Emulator Preview\n * Android Studio 2.0 Preview: Android Emulator","routePath":"/2015/12/11/getting-start-for-android-emulator-preview/","lang":"","toc":[{"text":"安装更新Android Studio 2.0 & Preview SDK Tools","id":"安装更新android-studio-20--preview-sdk-tools","depth":2,"charIndex":195},{"text":"创建新的Android虚拟设备(AVD)","id":"创建新的android虚拟设备avd","depth":2,"charIndex":548},{"text":"虚拟机特性","id":"虚拟机特性","depth":2,"charIndex":899},{"text":"虚拟机存在的问题","id":"虚拟机存在的问题","depth":2,"charIndex":1228},{"text":"安装CPU加速器(HAXM)","id":"安装cpu加速器haxm","depth":2,"charIndex":1999},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2182}],"domain":"","frontmatter":{"layout":"post","title":"尝试Android Emulator Preview模拟器","date":"2015-12-11 20:38:32","categories":["工具"],"tags":["android","模拟器","androidstudio"]},"version":""},{"id":114,"title":"体验JQuery Terminal Emulator插件","content":"#\n\n自从看了JetBrains主页上那个命令行模拟器，就一直想弄一个玩玩。今天谷歌了一下，果然有这样的插件。\n\n\n\n暂时选定了使用这个http://terminal.jcubic.pl/： 主页上的标题也感觉非常高大上：\n\n\n\n这一周就开始搞这个吧:-D。\n\n\n下载引用#\n\n首先从官网下载需要压缩包文件，建议将以下文件引入到网页中：\n\n\n\n创建对应的显示区域\n\n\n\n让terminal显示到浮动在右下角，并有关闭按钮，需要CSS限定位置\n\n\n\n然后用js实现功能\n\n\n\n一个简单的右下角浮动shell就出现了。\n\n\n问题#\n\n在我的博客上部署的时候很奇怪发现，命令行的一行只有35个字符，无法充满整个命令行。一直找不到是啥原因。\n于是去博客上询问了一下作者，并附上了一个简单的DEMOhttp://jsfiddle.net/sumy/f7qdrp1y/。作者看了之后指出，要修改字体，需要将\n所有的terminal统一字体。 但是这样还是不行，最后发现是在计算单个字符的地方出现了点差错。\n\n作者计算单个字符的时候使用了.terminal\nspan里空格的宽度，但是这个类选中了一个莫名其妙的字体，导致空格无故变宽。通过修改css强制修改font-family就可以了。\n\n\n\n\n参考内容#\n\n * JQueryTerminal","routePath":"/2015/12/10/install-jquery-terminal-emulator-plugin-in-my-blog/","lang":"","toc":[{"text":"下载引用","id":"下载引用","depth":2,"charIndex":131},{"text":"问题","id":"问题","depth":2,"charIndex":259},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":541}],"domain":"","frontmatter":{"layout":"post","title":"体验JQuery Terminal Emulator插件","date":"2015-12-10 21:26:57","categories":["网站"],"tags":["jquery","插件","网站"]},"version":""},{"id":115,"title":"Nexus6P解锁bootloader然后刷recovery、root、xposed指导","content":"#\n\n经过漫长的等待，港版nexus 6p终于到手了，然后赶紧试了试。。。由于手机没有Root，无法恢复软件数据，所以先来折腾一番。\n参考的Root教程是机锋论坛的一个置顶帖，用的方法是刷修改版的内核。Root效果还是比较理想的。\n\n\n解锁Bootloader#\n\n要想刷修改版的内核，需要先解锁Bootloader。 首先去“设置”->“关于手机”点“版本号”7次，开启“开发者选项”。在“开发者选项”中勾选“OEM解锁”。\n需要的工具可以去论坛下载。 对于新手还是推荐使用Nexus Root Toolkit工具包，这里就不过多说明了。 如果不想使用工具包还可以使用Android\nSDK里的adb工具，需要下载最新的Android SDK环境。由于之前搞过Android开发，有SDK环境还是比较方便的。 运行：\n\n\n\n进入bootloader刷写模式。 然后运行：\n\n\n\n解锁bootloader。 以下需要注意的事情：\n\n 1. 解锁bootloader会回到出厂模式，注意备份数据\n 2. 一旦解锁bootloader，就不要再上锁了。看网上相关的介绍说重新上锁有几率成砖，而且需要返回原厂进行修理。虽然不知道为什么，但是为了省掉这个麻烦，还\n    是不要去尝试了。\n\n\n更新系统、刷入Recovery、Root#\n\n重启之后，需要更新系统。如果有梯子，可以架梯子从官方更新，否则就下载刷机包手动更新，可以继续参考置顶帖的手动更新说明。这里也不作过多说明。\n更新之后版本号变为MDB08L。 手机重启到bootloader\n\n\n\n下载修改的boot文件，刷入：\n\n\n\n下载并刷入第三方的recovery，这里使用帖子提供的twrp版本的recovery：\n\n\n\n在bootloader模式下按音量键下键两次，可以看到红色的recovery，这时候按电源键可以进入teamwin recovery。\n下载supersu文件，放到手机的目录下。\n在twrp主界面选择install，找到刚才放入的BETA-SuperSU-v2.52.zip文件，滑动三角开始刷入。 重启。 这样手机就已经root了。\n\n一些说明： 手机自动更新版本变为MDB08L，而帖子中提供的boot版本是MDB08M，可以刷入吗？我刷入了，没有问题。也在XDA论坛上找到了一些说明。\n\n\n\n\n安装Xposed#\n\n听说Xposed是个很强大的框架。 下载Xposed刷机包和apk安装包，使用recovery将刷机包刷入系统，安装完apk就可以使用了。\n\n由于看了一下简介，暂时对Xposed不太需要，就没有尝试安装。\n\n\n参考内容#\n\n * NEXUS 6P 解锁Bootloder、刷回原生、刷RECOVERY、ROOT、XPOSED教程 - 华为 Nexus 6P 安卓论坛 机锋论坛\n * [GUIDE] Unlock/Root/Flash for Nexus 6P | Huawei Nexus 6P","routePath":"/2015/12/07/guide-for-nexus-6p-unlock-root-flash-and-xposed/","lang":"","toc":[{"text":"解锁Bootloader","id":"解锁bootloader","depth":2,"charIndex":117},{"text":"更新系统、刷入Recovery、Root","id":"更新系统刷入recoveryroot","depth":2,"charIndex":542},{"text":"安装Xposed","id":"安装xposed","depth":2,"charIndex":987},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1103}],"domain":"","frontmatter":{"layout":"post","title":"Nexus6P解锁bootloader然后刷recovery、root、xposed指导","date":"2015-12-07 20:12:05","categories":["搞机日常"],"tags":["android","刷机","nexus","root"]},"version":""},{"id":116,"title":"[i9502]品尝，棒棒糖！","content":"#\n\n在等待六儿子的无聊过程中。。。偶然翻到了手头手机的刷机包，发现可以刷“棒棒糖”，于是就来尝试一下。过程比较曲折，但是还是基本上解决了。\n\n\n前言#\n\n在刷机精灵的ROM站点，看到可以刷的i9502 5.0的刷机包，于是就想试一试。\n之前使用的系统是适配的MIUI7单卡版，虽然MIUI的体验真心不错，但是这个合作开发版真的只是移植，没有根据机型做相应的开发。当然也不能奢求什么。\n为了避免不必要的麻烦还是做了点备份：\n\n * 联系人、短信、通话记录\n * 系统应用通过“钛备份”备份\n * 内存卡的数据全部拷贝出来\n\n用了2个小时完成了这些操作，后面证明这些操作还是值得的。\n\n\n开始 第一步#\n\n本着怎么方便怎么来的的原则，尝试刷机精灵的一键刷机。初步感觉还很顺利，自动root，自动recovery，自动复制，自动刷机，最后自动成砖了。\n不知道是ROM的原因还是ROM的原因，只好放弃一键刷机。\n\n\n救砖 第二步#\n\n自然而然的需要救砖，百度了一下，在安卓论坛上发现有官方5.0.1救砖五件套，我是现在才知道五件套是什么。漫长的下载过程，从百度云上用了1个多小时才下载完成。\n用Odin就把五件套刷进手机，手机成功开机，5.0的开机画面真不错，有种惊艳的感觉。\n\n\nroot 第三步#\n\n开机后发现好多联通内置应用呀，看着很不爽。。。root一下吧。。。找了一个recovery和SuperSU的root包，先用Odin将recovery刷进去，然\n后用recovery将SuperSU刷进手机。很自然而然的，又成砖了（开机黑屏，只有呼吸灯闪）。\n再次将第二步重做了一遍，期间也换了一些5.0的卡刷包，最后不知怎么就root成功了。\n\n在恢复应用和数据的过程中，发现了一个问题。这个包打电话居然没声音，而且对面也听不见。\n\n\n新道路 歪果仁的棒棒糖#\n\n考虑没有声音可能是基带的问题，于是尝试刷基带解决。共尝试了2个基带I9502ZNUJOF1和I9502ZNUJOC3，但是都不行。\n在一个XDA开发者论坛上发现了一个ROM包sasiskasROM_I9502_Lollipop_V1.2，感觉似乎可行，反正也就这样了就拿来尝试了一下。\n提供刷机包不是标准的zip刷机包，是TWRP备份方式提供的，需要先刷TWRP\nrecovery，好在下面的回帖里提供了twrp-2.8.1.0-i9500.tar，用Odin刷进去就可以了。\n\n进入TWRP，先备份一下，就会在SD卡中生成一个目录/TWRP/BACKUPS/XXXXXX，XXXXXX为随机生成的字符串，将提供的刷机包解压到XXXXXX下\n，重启进TWRP recovery选restore将备份回复一下。 这个备份需要配合I9502ZNUJOC3基带。\n\n重启后，打10086终于听到了声音（今天骚扰了好多次10086了），感觉应该可以用了。赶紧把数据恢复了上去。\n\n\n\n\n就这样吧#\n\n花了一天的时间，虽然麻烦了点，有种柳暗花明又一村的感觉，平常人刷机纯粹靠的是运气，有些问题不知怎么就好了。然后，搞一次就行了，不想多搞了，主要是手机用久了就有好\n多数据拖着。","routePath":"/2015/12/02/galaxy-s4-i9502-try-lollipop-5-0-1/","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":72},{"text":"开始 第一步","id":"开始-第一步","depth":2,"charIndex":292},{"text":"救砖 第二步","id":"救砖-第二步","depth":2,"charIndex":404},{"text":"root 第三步","id":"root-第三步","depth":2,"charIndex":537},{"text":"新道路 歪果仁的棒棒糖","id":"新道路-歪果仁的棒棒糖","depth":2,"charIndex":767},{"text":"就这样吧","id":"就这样吧","depth":2,"charIndex":1220}],"domain":"","frontmatter":{"layout":"post","title":"[i9502]品尝，棒棒糖！","date":"2015-12-02 20:03:41","categories":["搞机日常"],"tags":["android","刷机"]},"version":""},{"id":117,"title":"atom使用activate-power-mode","content":"#\n\n最近在好多地方都看到介绍这个插件activate-power-mode，光看图觉得一般般，但是用上之后真的很震撼呀。绝对的装B利器，啊哈哈哈。。。\n\nGITHUB：https://github.com/JoelBesada/activate-power-mode ATOM:\nhttps://atom.io/packages/activate-power-mode\n\n在atom里的插件搜索就能找到该插件，安装上之后使用Packages->activate-power-mode->Toggle或Alt+Ctrl+O启用，来感受\n一下吧。\n\n\n\n为啥没有vscode版本的，哈哈。。。根本停不下来了。。。","routePath":"/2015/12/01/ACTIVATE-POWER-MODE-ON/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"atom使用activate-power-mode","date":"2015-12-01 21:53:02","categories":["高效生活"],"tags":["atom","plugin"]},"version":""},{"id":118,"title":"使用PHP:proc_open()执行命令并获取输出","content":"#\n\n\n函数原型#\n\n(PHP 4 >= 4.3.0, PHP 5, PHP 7) proc_open — 执行一个命令，并且打开用来输入/输出的文件指针。\n\n\n\n具体介绍可以参考php.net上的文档。\n\n\n应用#\n\n参考php.net上面的例程，修改了一下写成一个小的php程序，用来测试php执行命令的情况，也可以用来测试服务器上php的环境变量问题。\n\n\n\n\n参考内容#\n\n * PHP: proc_open - Manual\n * Executing .jar file from PHP through cmd prompt and capturing output","routePath":"/2015/11/28/executing-command-from-php-and-capturing-output/","lang":"","toc":[{"text":"函数原型","id":"函数原型","depth":2,"charIndex":3},{"text":"应用","id":"应用","depth":2,"charIndex":104},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":183}],"domain":"","frontmatter":{"layout":"post","title":"使用PHP:proc_open()执行命令并获取输出","date":"2015-11-28 19:48:15","categories":["编程语言"],"tags":["php","shell"]},"version":""},{"id":119,"title":"SAXParser解析XML时抛出ArrayIndexOutOfBoundsException异常","content":"#\n\n今天在使用SAXParser解析XML时会抛出一个ArrayIndexOutOfBoundsException异常。只测试了在CDATA标签中，如果字符多余10\n33个就会出现异常。\n\n\n问题#\n\n写了一个小的样例重现这个问题：\n\nXML文件：\n\n\n\n几个测试类：\n\nDatabaseParserHandler.java\n\n\n\nXMLUtil.java\n\n\n\n运行之后抛出的异常：\n\n\n\n疑似是一个bug，暂时还没有找到解决方法。考虑换其它的XML解析引擎试一下。\n\n\n临时解决#\n\n对于javax.xml.parsers.SAXParser有多重实现方式，应当避免选中pull-parser-xx.jar包下的实现方式，在工程中可以删除该包。\n确定当前的实现方式可以参考stackoverflow.com/a/1804281/3215527上面的方法。\n\n由于工程需要使用DOM4j来解析，采取了一种折衷的方式。首先使用JDK默认的实现方式，将XML解析成org.w3c.dom.Document，然后使用org.d\nom4j.io.DOMReader将其转换成import org.dom4j.Document。\n\n这样做临时避免了上面的问题，但是不知道问题的原因还是有点不爽。","routePath":"/2015/11/27/a-problem-SAXParser-throw-ArrayIndexOutOfBoundsException/","lang":"","toc":[{"text":"问题","id":"问题","depth":2,"charIndex":96},{"text":"临时解决","id":"临时解决","depth":2,"charIndex":237}],"domain":"","frontmatter":{"layout":"post","title":"SAXParser解析XML时抛出ArrayIndexOutOfBoundsException异常","date":"2015-11-27 21:05:47","categories":["问题麻烦"],"tags":["java","xml"]},"version":""},{"id":120,"title":"linux下统计目录中的文件个数","content":"#\n\n在linux下使用以下命令可以简单的统计目录下文件的个数。\n\n\n命令#\n\n查看当前目录下文件的个数\n\n\n\n查看当前目录下文件的个数，包括子目录里的。\n\n\n\n查看某目录下文件夹（目录）的个数，包括子目录里的。\n\n\n\n\n解释#\n\n下面解释一下上面的命令：\n\nls可以列出当前目录下的文件，那么ls -l是以长格式的形式查看当前目录下所有可见文件的详细属性。\n\n\n\n-R参数可以递归列出子目录下的文件。\n\ngrep用来根据正则匹配文本，并将匹配到的文本行显示出来。\"^-\"用来匹配行开始的字符为-的那一行，\"^d\"用来匹配行开始字符为d的那一行。\n从上面可以看出，文件夹的开始会有字母d，而普通文件只是简单的-。顺便说一下，如果为连接文件，会显示l。\n\nwc命令用来统计字节数、字数、行数，并将统计结果显示输出。-l用来统计行数的。\n\n以上命令串起来，就是（递归）列出所有的目录和文件，找出其中的文件/文件夹的行，统计出行数就是对应的文件/文件夹的个数的。\n\n\n参考内容#\n\n * linux 统计当前目录下文件数","routePath":"/2015/11/25/count-the-number-of-files-in-the-directory/","lang":"","toc":[{"text":"命令","id":"命令","depth":2,"charIndex":34},{"text":"解释","id":"解释","depth":2,"charIndex":110},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":430}],"domain":"","frontmatter":{"layout":"post","title":"linux下统计目录中的文件个数","date":"2015-11-25 23:46:00","categories":["高效生活"],"tags":["linux","shell"]},"version":""},{"id":121,"title":"使用http_parser解析URL","content":"#\n\n解析URL是个烦心事，尤其是还要使用C语言来解析。写Java写习惯了，好多C的东西都不太会用了。最近的一次作业中需要用到URL的解析，查找了一番就找到了这个开源\n库。\n\nhttp-parser由nodejs项目组开源，具体简介可以去参考主页README。\n\n\nhttp-parser优点#\n\n * 无依赖性\n * 可以处理持久消息(keep-alive)\n * 支持解码chunk编码的消息\n * 支持Upgrade协议升级(如无例外就是WebSocket)\n * 可以防御缓冲区溢出攻击\n\n\n解析函数原型#\n\n库的主要功能是解析HTTP头的，而解析URL使用的则是库中的一个函数方法http_parser_parse_url()：\n\n\n\n需要说明的是is_connect参数，当传1时，http_parser_parse_url方法将进行严格检验，如果URL中没有port、schema将导致htt\np_parser_parse_url方法失败，返回非0值。一般给is_connect方法传0即可。\n\n调用函数之后会将解析的port、host、path、schema之类的结果存放到http_parser_url的结构体中：\n\n\n\n结构体未进行任何的内存拷贝，只记录了位置、长度信息等，效率上还是很不错的。目前支持SCHEMA、PORT、HOST、PATH、QUERY、USERINFO、FR\nAGMENT七种信息的提取。\n\n\n示例代码#\n\n被解析的URL至少需要包含UF_SCHEMA和UF_HOST，否则在解析的时候会发生错误。\n\n使用的是博客中的示例代码：\n\n\n\n这里从头文件中摘出了URL参数的定义，可以在代码中获取到相应的部分：\n\n\n\n\n参考内容#\n\n * 使用http_parser解析URL\n * http-parser使用简介","routePath":"/2015/11/24/use-http-parser-to-parse-url/","lang":"","toc":[{"text":"http-parser优点","id":"http-parser优点","depth":2,"charIndex":132},{"text":"解析函数原型","id":"解析函数原型","depth":2,"charIndex":249},{"text":"示例代码","id":"示例代码","depth":2,"charIndex":617},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":727}],"domain":"","frontmatter":{"layout":"post","title":"使用http_parser解析URL","date":"2015-11-24 23:18:46","categories":["编程语言"],"tags":["url","库","c/c++"]},"version":""},{"id":122,"title":"新手向的问题描述及提问实践SSCCE","content":"#\n\n> 这篇文章主要讲解新手向的问题提问及描述实践，从一篇英文翻译而来。\n\n\n什么是 SSCCE#\n\nSSCCE是 Short, Self Contained, Correct (Compilable), Example 的缩写。\n\n如果对代码有问题并且想要寻求帮助，准备一个简短、自成一体、准确的示例（SSCCE）是很有必要的。但是什么是SSCCE？\n\n实际上，从名字上就能看出。让我们看一下每一部分。准备给他人看的内容应该是：\n\n * 简短的 - 例子尽量短小，不要让审阅者无聊\n * 自成一体的 - 确保一切想要的东西都包括进去了\n * 准确的 - 复制，粘贴，（编译，）就能看到所指的内容\n * 示例 - 展现我们正要解决的问题\n\n\n简短的#\n\n这取决于讨论组或论坛上。就一个公共的论坛来说，大多数的阅览者大约只会阅读100行左右的代码，而有200-300行的代码就会产生抱怨情绪。\n\n\n精简的技巧#\n\n如果一个GUI界面有40个按钮，但是与问题毛关系也没有，还留着它们干啥。如果这些按钮全都与问题相关（移除按钮问题也就消失了），依次放回一两个按钮，如果问题出现了\n，只保留这一两个按钮即可。\n\n导致数组或表格出问题的可能有一百多条数据，但是同样的，如果能从两三条条目中看出问题，那么精简一下只保留这些条目。\n\n如果问题出现在GUI界面层，精简所有后端的逻辑（JavaScript或Java等）。另一方面，如果一个应用有一个界面，但是问题出现在逻辑上，可以把GUI界面精简\n到最小版本。\n\n如果在别人看来精简了大量的代码，那么你可能精简了你认为与问题不相干的代码，但在解决问题上却是有用的。\n\n\n问题解决了吗？#\n\n通过明确的指出问题出在哪里，你就向解决问题上迈出了重要的一步。这个过程突出显示一个问题的起源，而这个过程恰恰可以帮助解决问题。你可以更仔细的摘出这一部分，并在此\n过程中发现问题。\n\n即使你不能明确问题为什么发生，你仍然迈出了重要的一步：确定问题所涉及的代码（至少一部分）。\n\n如果代码已经精简成问题的简要例子，那么它就可以呈现给别人；如果还没有，将问题的代码放回来，继续精简其它部分，直到代码精简完毕。\n\n\n自成一体的#\n\n最重要的是确保给他人的代码可以“复制，粘贴，编译，然后运行”，就帮助了解问题来说这是行之有效的方法。\n\n这意味着当这些代码被复制、粘贴然后编译，他们自己就能运行并看到结果。这可以认为是问题的一个示例。\n\n如果你能做到这一点，那么极有可能得到帮助。\n\n\n怎样弄一个自成一体的例子#\n\n如果代码进行了文件I/O操作，把问题中与输入/输出无关的文件I/O操作用虚拟数据结构来代替。\n\n如果问题出在输入上，文本输入_就会_被用到，那么准备一个简短的例子，这个例子可以复制到实际的数据文件中。\n\n如果问题只发生在加载阶段，那么插入代码来模拟加载过程。如果一个布局问题只发生在特定情形下，找到切实可行的方法来_迫使_这些问题复现。\n\n显然，就发布到论坛上来说，有些东西是不能包含到例子里的，诸如“数据库”。但是更多时候你需要一点横向思维，想出一个方法来取代在展示问题上你认为“重要”的东西。\n\n横向思维的一个例子是“图像”。与代码问题相关的图像看起来可能很难被替换。但是有一个小技巧就是链接到网络上的图像，这个图像展示了相同的问题。如果可能的话，尽量使任\n何基于图像的Web网络在字节大小上“少”一点。\n\n\n正确性#\n\n如果我的例子是正确的，那我还需要在这里做什么？\n\n（笑）不，在这一方面不是什么“正确”的意思。在这篇文章中，正确性（或可编译性，尤其涉及到计算机源代码而言）意味着确保例子适合公认的标准或协议。\n\n为了实现这一目标，有必要来：\n\n * 行宽。示例中一行的宽度保持在62个字符以内。（但是不要删除所有的行缩进！）新闻阅读器通常在72个字符左右强制另起一行（为了确保稳定性字符可能会更少）。有时\n   候，换行符不会导致任何问题，但是更多时候会有问题，这意味着行与行要重新整合，来确保可以出现预期的结果。大多数代码编辑器都会在编辑区顶端显示行宽。\n * 如果有的话请使用命名习惯。大多数人愿意帮助那些在提示中使用大小写字母，或用来描述命名的代码，这样可以略读代码以快速的确定问题。如果按照读者的习惯，就可以帮\n   助他们更好的了解代码。\n * 确保示例是_正确的_。无论是示例可以编译清楚，或者能出现需要解决的确切错误信息。\n\n更多的提示：\n\n * 将所有的资源（CSS/JS/Java源代码、图像等）放到同一个文件夹，这样可以更容易管理，并且也很容易找到。\n * 从Java源代码中删除package语句。\n * 将Java的public类降级到默认级别。如果语言指定在每个源代码文件中只能有一个public类，那么就要降级所有其他的类到默认级别。这样可以让示例在不用\n   分成单独的文件就可以编译。\n * 验证器如果可行，可以来验证示例。\n * HTML验证器\n * CSS验证器\n\n\n示例#\n\n一定要确定发表的代码真的表现出了问题！\n\n已经在这个例子上纠结了一小时，或者有一天了吧。可能看起来像是永远。那么现在，就是一个很好的时间用来休息一会儿，后退一步，海阔天空。\n\n重整电脑也是如此。 别忘了在必要的时候重启电脑。\n\n现在打开出现问题的网页或程序。当初的问题还在那儿吗？\n\n也许99%会是这样解决的（或者少使用较不可靠的操作系统）。\n\n现在，如果问题依然存在，那就发表你的示例吧。\n\n\n示例 - 加分点#\n\n我们希望给这些人一美元，那些询问一个网页或样式表、一些JavaScript代码或者一个Java\nApplet小程序但没有给出链接的人。我们并不需要提供和维护这个文档，做这些还不如去沙滩享受阳光浴、体验异域风情、喝着异国风味的鸡尾酒。\n\n为什么人们会错过这样的机会？很少有东西能像链接那样诱人。对于一个经验丰富的论坛版主，有一个链接会像一个写有“喝掉我”这样模糊的讯息的瓶子那样诱人，也可以比作异国\n风味的鸡尾酒。\n\n三个臭皮匠，顶个诸葛亮。一群人有助于发现并解决手头的问题，也会解决_兼容性问题_（这可能就是问题的原因）。\n\n\n网络上标准#\n\n当处理与互联网相关的事情时，这里存在另一个“疑难杂症”。互联网或与其相关的一些事情上，都会有些放荡不羁。每个标准后面都会有候补标准。对于每个规则往往有至少三个例\n外。\n\n首先，浏览器的工作方式不同。这里不是指IE和Netscape的不同，也不是指旧浏览器和新浏览器的不同。而是，举个例子来说，是Macintosh下的“Intern\net Explorer 5”和Windows下的“Internet Explorer 5”（显著）的区别。\n\n在网页设计讨论组寻求帮助的人们往往很惊讶的听到，他们经历的网页问题却没有在使用不同浏览器的那些人哪里表现出来。\n\n\nJava Applets#\n\n更复杂一点的，有更多问题的，还要数网页中有个Applet的时候了。上述提到的浏览器往往会形成不同（通常不好的）HTML和样式表，如何将Applets与浏览器结合\n的很好，这将是另一个问题。这里只是举个例子。\n\n很长一段时间，微软在Internet Explorer上运行Java的_早期版本_（JVM\n1.1版本）。之后发生了一些事情，微软将_最新的Java_引擎嵌入到它的浏览器中。不就之后，他们又开始提供_没有JVM_的IE版本了。\n\n含有Applets可能会出现并发症，但庆幸的是当在互联网环境下，这很容易检查出来。点击几下，在星球另一边的人就能从他们自己浏览器的Java控制台上看到输出，有些\n时候也能看到Applet正常的工作。\n\n如果一个Applet在你这里能正常工作，在其他人那里却出问题了，这可以帮助你快速所别问题的范围，一般是HTML、Applet标签、或者（完全没有安装）浏览器的J\nVM插件。\n\n\n何必如此？#\n\n这是一个很好的问题。为什么要做这些事情？\n\n也许会有人能从你给的描述中明白你所描述的问题。也许这只是数以千计的人无意当中发现的一件事情。\n\n如果你已经检查了FAQ、google过论坛、阅读了XXX指导手册，那么你会发现答案不会那么容易浮现出来。你_必须_深入做这些事情，难道不是吗？\n\n如果浪费了公共论坛其他会员的时间和带宽，就可能会被群起而攻之。\n\n在讨论组有过贡献的人给予很宽泛的建议。这些建议有时候会奏效，有时候不会，但无论哪种方式，意见都是免费的。\n\n贡献者这样做有多种多样的原因，其中一条是，当他们可以将自己所知道的与自己领域相关的一部分知识传递给正在学习的人，这样所带来的成就感。\n\n不幸的是，如果一些人问一些包含在基础教程却还需要别人喂养的问题，这个迹象表明，提问者并没有强烈的欲望想去学习那些他自己应该去学习的内容。\n\n如果这里有一段你想写的代码，你可以有很多途径来完成或者让其他人帮你修改一下。对于金额不多的时候，你可以找一些基于互联网的外包公司来完成（做完）大多数的IT工作。\n这些本来就是这些外包公司正在研究的。\n\n自由论坛就是用来学习的。\n\n话说回来：\n\n让我们假设你的确在学习，你有一个庞大的、复杂的系统，系统中有一个偶然的、不可预知的错误，然后你搜索了FAQ和论坛、研究了说明书或文档，但是却没有找到一个答案。\n\n向讨论组描述问题的时候放松宽泛一点，也许这样可以消除一些基本问题上的误解。\n\n我们并不打算为了解决每一个单独的问题都用上SSCCE。也并不是说某些例子需要这样做或者必须那样做。\n\n然而，它将使人们获得帮助，最终会增加找到解决方法的机会。\n\n\n参考内容#\n\n * Short, Self Contained, Correct Example","routePath":"/2015/11/12/problem-with-short-selfcontained-correct-example/","lang":"","toc":[{"text":"什么是 SSCCE","id":"什么是-sscce","depth":2,"charIndex":39},{"text":"简短的","id":"简短的","depth":2,"charIndex":321},{"text":"精简的技巧","id":"精简的技巧","depth":3,"charIndex":398},{"text":"问题解决了吗？","id":"问题解决了吗","depth":3,"charIndex":702},{"text":"自成一体的","id":"自成一体的","depth":2,"charIndex":916},{"text":"怎样弄一个自成一体的例子","id":"怎样弄一个自成一体的例子","depth":3,"charIndex":1050},{"text":"正确性","id":"正确性","depth":2,"charIndex":1422},{"text":"示例","id":"示例","depth":2,"charIndex":2072},{"text":"示例 - 加分点","id":"示例---加分点","depth":3,"charIndex":2275},{"text":"网络上标准","id":"网络上标准","depth":3,"charIndex":2550},{"text":"Java Applets","id":"java-applets","depth":3,"charIndex":2837},{"text":"何必如此？","id":"何必如此","depth":2,"charIndex":3262},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":3962}],"domain":"","frontmatter":{"layout":"post","title":"新手向的问题描述及提问实践SSCCE","date":"2015-11-12 22:09:45","categories":["高效生活"],"tags":["编程","技巧"]},"version":""},{"id":123,"title":"一个你吃我我吃你的小游戏Agar","content":"#\n\n今天是一个特殊的日子，就来介绍游戏了呀。之前看谜之声玩过，感觉还是挺有意思的，不过自己玩的时候就感觉，哈哈。\n\nAgar传送门：http://agar.io/\n\n这是一个在线网页游戏，服务器在国外，感觉有点慢。打开后就可以看到这个界面，输入昵称就可以开始游戏了。\n\n\n\n说一下基本操作：\n\n> 光标移动 控制细胞的移动方向 空格键 向光标方向平均分裂 W键 大约6-3分裂，较小的向光标方向冲刺\n\n在游戏界面可以看到，左上角显示排名，右下角显示你当前的分数\n\n\n\n刚开始你只是一个很小的细胞，需要吃散落的细胞增长自己。当生长到一定的程度的时候，就可以吃比你小的细胞了。 细胞越小跑的越快，光凭移动大细胞是无法追上小细胞的。\n\n\n\n在游戏中可以看到一些表面有刺的细胞，当你的细胞比有刺的细胞小的时候，可以躲进去防止大细胞的攻击。比有刺细胞大的细胞在碰到有刺细胞的时候会自动分裂成小细胞。\n\n\n\n游戏中还有许多技巧，可以去摸索一下。 总之，真心玩进去了感觉还是挺有意思的。","routePath":"/2015/11/11/eat-cells-smaller-than-you-and-dont-get-eaten-by-the-bigger-ones/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"一个你吃我我吃你的小游戏Agar","date":"2015-11-11 21:50:48","categories":["游戏人生"],"tags":["agar","games"]},"version":""},{"id":124,"title":"SSH的转义字符","content":"#\n\nSSH 有一个转义字符（Escape Character），今天在微博上看到如何结束无响应的SSH的时候才了解到了它。\n\n转义字符必须在 换行之后的第一个字符输入 ，如果已经输入了其它内容，即使按了退格键也是没有效果的。这个时候需要按Enter之后再重新输入。\n\n默认在终端输入可以看到帮助：\n\n\n\n如果想退出终端，可以使用 ~.。听说可以优雅的断开没有响应的SSH连接。 ~^Z（~ 然后\nCtrl+Z）可以将当前SSH进程切换到后台，之后再回去可以输入fg即可。 若不想使用~作为转义字符，可以使用-e参数修改为其它的字符。例如将转义字符修改为#：\n\n\n\n\n参考内容#\n\n * SSH Escape Character\n * 如何的退出无响应的 SSH 连接","routePath":"/2015/11/10/how-to-use-ssh-escape-character/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":283}],"domain":"","frontmatter":{"layout":"post","title":"SSH的转义字符","date":"2015-11-10 23:13:18","categories":["高效生活"],"tags":["ssh","shell","linux"]},"version":""},{"id":125,"title":"在CentOS 7上安装Tomcat 8","content":"#\n\nApache Tomcat是一个基于Java应用的网络服务器和servlet容器。Tomcat是一个实现了Java Servlet和JavaServer\nPages技术的开源软件，它由Apache Software Foundation发行。要在CentOS下安装Tomcat，需要进行以下几个步骤。\n\n\n安装Java#\n\nTomcat需要服务端的Java运行环境，这样才能保证Java程序的正常运行。这里使用OpenJDK 8来代替JDK的安装。\n要安装OpenJDK8，需要运行以下的命令：\n\n\n\n\n创建Tomcat用户#\n\n出于安全考虑，Tomcat需要运行在没有特权的用户上。需要创建一个新的用户和用户组来运行Tomcat服务。 首先，要创建一个新的tomcat用户组：\n\n\n\n然后创建新的tomcat用户。使这个用户作为tomcat用户组的成员，用户根目录设置到Tomcat的安装位置/opt/tomcat，配置终端为/bin/fals\ne使得不可以用此用户登录终端。\n\n\n\n\n安装Tomcat#\n\n最简单的方法就是安装Tomcat 8绿色版，下载最新的版本，并配置它。\n\n\n下载Tomcat#\n\n可以在Tomcat8下载页面找到Tomcat 8的最新版本。当前最新版本为8.0.28。在Binary\nDistributions分类里的Core找到\"tar.gz\"的下载链接，复制这个下载链接。 将其下载到用户的主目录文件夹下：\n\n\n\n接下来将Tomcat安装到/opt/tomcat文件夹，创建这个文件夹，将压缩文件解压到这个目录下：\n\n\n\n\n设置权限#\n\n要访问Tomcat的安装目录，tomcat需要有合适的权限。 首先切换到Tomcat的安装目录：\n\n\n\n授予tomcat用户conf目录的写权限和目录下文件的读权限：\n\n\n\n然后修改work、temp、logs目录的所有者为tomcat用户：\n\n\n\n\n设置systemd文件#\n\n要想让Tomcat作为服务启动，需要在配置Tomcat Systemd文件。 创建并打开一个服务配置文件：\n\n\n\n将下列脚本粘贴到改文件中。可能需要修改CATALINA_OPTS来设置分配的内存大小。\n\n/etc/systemd/system/tomcat.service\n\n\n\n保存，退出。这个脚本告诉系统使用tomcat用户按照配置来启动Tomcat服务。\n\n重新加载Systemd来加载Tomcat配置文件：\n\n\n\n现在可以使用systemctl命令来启动Tomcat服务：\n\n\n\n如果想要在开机的时候就启动Tomcat服务，可以运行：\n\n\n\n现在，Tomcat启动了。可以通过浏览器访问域名或IP地址的:8080端口，就可以看到默认起始页了。\n\n> http://server_IP_address:8080\n\n\n配置Tomcat Web管理接口#\n\n为了使用Tomcat的管理界面，我们需要为Tomcat服务添加用户。编辑tomcat-users.xml文件：\n\n\n\n在这个文件里可以看到一些被注释了的配置文件。 如果想要添加一个可以访问manager-gui和admin-gui的用户，可以如下添加用户名和密码：\n\ntomcat-user.xml\n\n\n\n保存并退出tomcat-user.xml文件。要想使配置生效，需要重启Tomcat服务：\n\n\n\n\n访问网络接口#\n\n访问以下地址就可以看到下面的图片：\n\n> http://server_IP_address:8080\n\n\n\n可以看到有指向管理员界面的链接。\n\n点击 Manager App 链接或者访问\n\n> http://server_IP_address:8080/manager/html\n\n\n\n在这个界面，可以管理Java网络应用。可以启动、停止、重新加载、部署或者不部署应用。也可以运行一些诊断程序。最后在页面的最下方可以看到服务器的一些信息。\n\n主机管理可以通过主页的链接或者访问\n\n> http://server_IP_address:8080/host-manager/html/\n\n\n\n通过虚拟主机管理页面，可以为应用添加虚拟主机。\n\n\n参考内容#\n\n * How To Install Apache Tomcat 8 on CentOS 7","routePath":"/2015/11/09/install-apache-tomcat-8-on-centos-7/","lang":"","toc":[{"text":"安装Java","id":"安装java","depth":2,"charIndex":155},{"text":"创建Tomcat用户","id":"创建tomcat用户","depth":2,"charIndex":254},{"text":"安装Tomcat","id":"安装tomcat","depth":2,"charIndex":446},{"text":"下载Tomcat","id":"下载tomcat","depth":3,"charIndex":495},{"text":"设置权限","id":"设置权限","depth":3,"charIndex":680},{"text":"设置systemd文件","id":"设置systemd文件","depth":3,"charIndex":813},{"text":"配置Tomcat Web管理接口","id":"配置tomcat-web管理接口","depth":2,"charIndex":1188},{"text":"访问网络接口","id":"访问网络接口","depth":2,"charIndex":1409},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1738}],"domain":"","frontmatter":{"layout":"post","title":"在CentOS 7上安装Tomcat 8","date":"2015-11-09 20:16:27","categories":["网站"],"tags":["tomcat","apache","centos"]},"version":""},{"id":126,"title":"修改炉石传说客户端显示字符串","content":"#\n\n> 炉石传说显示的文字是可以修改的，通过修改文字有更好的自定义性（个性）。\n\n受@笔良文昌的推荐，看到了王师傅的这个视频，可以修改一下炉石传说的客户端。\n\n{% video '' %}\n\n简单说明一下步骤：\n\n 1. 找到炉石传说的文件夹的资源文件，一般存放在$HEARTSTONE/Strings/$LA/目录下，$HEARTSTONE为炉石传说主文件夹，$LA为语言\n    。\n    * GAMEPLAY_AUDIO.txt 存放的是游戏语音对应的文本\n    * GAMEPLAY.txt 存放战斗界面的文本\n    * 其它txt文件也有相应的文本，打开文件就可以看出来\n 2. 用文本编辑器打开，由于换行符的原因，最好不要使用系统自带的记事本打开。\n 3. 文件的一般格式为，有的文件可能没有“声音文件”部分。只替换TEXT文本即可，不要增加或删除原有的空格。\n\n> 标签 文字 备注 声音文件 TAG TEXT COMMENT AUDIOFILE\n\n 4. 修改完之后，请做好“修改完成文件”的备份。战网每次启动时可能会检查资源文件，发现修改会自动替换回去，所以每次启动游戏的时候都要替换一遍。\n\n也就这么多了，希望能在游戏中找到自己的乐趣。这才是游戏本身的使命。","routePath":"/2015/11/07/modify-heartstone-string-resource-to-have-fun/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"修改炉石传说客户端显示字符串","date":"2015-11-07 01:16:45","categories":["游戏人生"],"tags":["heartstone","技巧","个性化"]},"version":""},{"id":127,"title":"博客发现贴片广告(╯‵□′)╯︵┻━┻","content":"#\n\n晚上更新博客的时候突然发现页面的右下角出现了广告。\n\n使用Chrome的控制台查看源代码可以发现一个奇怪的#ppp_box的div\n\n博客引用的外部js有：semantic-ui框架、duoshuo评论、cilcki统计、swiftype搜索。\n在使用xxx+广告搜索无果的情况下，决定以ppp_box为关键词搜索引用的js，终于发现了蛛丝马迹。\n\n统计已换为google_analytics。 使用clicki是因为它的友好型和漂亮的扩展，可以显示来访用户详细的信息。\n\n感觉非常难过。","routePath":"/2015/11/06/clicki-with-advertisement-very-sad/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"博客发现贴片广告(╯‵□′)╯︵┻━┻","date":"2015-11-06 00:57:00","categories":["网站"],"tags":["clicki","analytics","google"]},"version":""},{"id":128,"title":"使用aapt出现No such file or directory错误","content":"#\n\n在Linux环境下运行aapt的时候出现：\n\n\n\n开始以为是没有加x权限，然而加了也没有用。 经过查找发现是64位的系统中缺少32位的运行库，安装后就可以使用了。\n\n\n\n如果还出现错误error while loading shared libraries: libz.so，再执行：\n\n\n\n即可运行aapt。\n\n\n参考内容#\n\n * 64位linux无法运行Android sdk的adb和aapt，提示No such file or directory的错误解决办法","routePath":"/2015/11/06/aapt-with-no-such-file-or-directory-error/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":160}],"domain":"","frontmatter":{"layout":"post","title":"使用aapt出现No such file or directory错误","date":"2015-11-06 00:17:24","categories":["工具"],"tags":["aapt","linux","sdk","解决问题"]},"version":""},{"id":129,"title":"使用aapt获取apk的基本信息","content":"#\n\naapt全称是android assert packaging tool。在编写android程序的时候，IDE会使用这个工具将程序资源打包成apk文件。\n前几天有获取apk包图标的需求，几番求证发现可以使用这个工具得到icon资源在apk包中的路径，通过处理aapt的输出，进而可以获取到图标。\n这里只简单记录一下aapt获取apk基本信息的方法，对于打包方法不做介绍了。\n\n\n它在哪里#\n\n如果你有安装android的sdk工具包，那么就可以在sdk目录下$ANDROID_HOME/build-tools/$SDK目录下找到它（$SDK为sdk的版\n本）。\n\n\n命令行#\n\n\n\n\n获取信息#\n\n\nlist#\n\n\n\n列出apk包的内容 这个功能与unzip差不多，因为apk本来就是一个zip压缩包。\n\n\n\n-v 选项会以table的形式显示apk内容。\n\n\n\n-a会详细显示apk的内容，不仅会显示包内文件，还会显示xml树和AndroidManifest.xml的内容。 这个参数与这三个命令的集合aapt list\n; aapt dump resources ; aapt dump xmltree AndroidManifest.xml执行的效果相同。\n\n\n\n\ndump#\n\n\n\n查看apk包的信息 badging 会显示apk包声明的一些信息。\n\n\n\npermissions 打印apk申请的权限\n\n\n\nresources 打印apk的资源表\n\n\n\nconfigurations 打印apk包资源配置属性\n\n\n\nxmlstrings 打印给出的xml文件中的字符串\n\n\n\nxmltree 打印给出的已编译的xml文件\n\n\n\n可以用来打印AndroidManifest.xml文件的xml树。\n\n\n\n\n参考内容#\n\n * Android aapt\n * android aapt用法","routePath":"/2015/11/04/use-aapt-to-get-apk-information/","lang":"","toc":[{"text":"它在哪里","id":"它在哪里","depth":2,"charIndex":192},{"text":"命令行","id":"命令行","depth":2,"charIndex":286},{"text":"获取信息","id":"获取信息","depth":2,"charIndex":295},{"text":"list","id":"list","depth":3,"charIndex":303},{"text":"dump","id":"dump","depth":3,"charIndex":539},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":759}],"domain":"","frontmatter":{"layout":"post","title":"使用aapt获取apk的基本信息","date":"2015-11-04 20:08:18","categories":["工具"],"tags":["android","aapt","apk"]},"version":""},{"id":130,"title":"使用git hooks进行hexo博客自动化部署","content":"#\n\n客的一个备份搭在了DigitalOcean的虚拟主机上，于是就出现了一个需求，每次更新博客的时候都需要使用ftp重新上传文件，很容易造成文件的丢失。所以就考虑能\n不能有一种自动化部署的方案。最近查找的时候发现可以使用git hooks来实现自动化部署。\n\n\ngit 与 hooks#\n\n在CentOS下安装git\n\n\n\n安装完git之后，需要使用git的hook特性。\n\n> 钩子(hooks)是一些在\"$GIT-DIR/hooks\"目录的脚本, 在被特定的事件(certain points)触发后被调用。当\"git\n> init\"命令被调用后, 一些非常有用的示例钩子文件(hooks)被拷到新仓库的hooks目录中; 但是在默认情况下这些钩子(hooks)是不生效的。\n> 把这些钩子文件(hooks)的\".sample\"文件名后缀去掉就可以使它们生效了。\n\n需要关注的是post-receive的钩子，当push操作完成之后这个钩子就会被调用。\n\n\n服务端配置#\n\n网站存放在/var/www/html目录下，当接收到push请求后，push的内容会被放置到这个目录下。 需要一个可以用来登录ssh的账户。\n\n\n新建git仓库#\n\n首先需要在服务器端建一个“裸库”来存放push的内容，“裸库”就是只含.git目录下内容的仓库。在这里我们将git仓库放到/opt/repo/site.git\n\n\n\n--bare的意思指文件夹不包含源代码，只有版本控制的结构。\n\n\n配置hooks#\n\n现在在目录下使用ls可以看到版本控制的结构，其中有一个hooks文件夹。进入hooks文件夹并创建一个post-receive文件。\n\n\n\n在post-receive文件夹下写入以下内容\n\n\n\n别忘了赋予post-receive可执行权限\n\n\n\n--git-dir 表示仓库所在的位置 --work-tree 表示实际文件被存放的位置 通过这个实现仓库与实际文件的分离\n\n\n本地配置#\n\n\n一般流程#\n\n进入工作目录，初始化git仓库，然后添加服务器的remote，push提交\n\n\n\n和普通的提交是一样的。\n\n\nhexo#\n\n我们可以配置使得hexo博客方便的提交到服务器，省去了ftp的步骤。 修改hexo目录下的_config.yml文件，找到[deploy]添加一个条目\n\n\n\n这样通过hexo deploy命令可以同时部署到github pages和服务器上了。\n\n\n参考内容#\n\n * Git Book 中文版 - Git Hooks\n * How To Set Up Automatic Deployment with Git with a VPS","routePath":"/2015/11/02/use-git-hooks-for-hexo-automatic-deployment/","lang":"","toc":[{"text":"git 与 hooks","id":"git-与-hooks","depth":2,"charIndex":131},{"text":"服务端配置","id":"服务端配置","depth":2,"charIndex":431},{"text":"新建git仓库","id":"新建git仓库","depth":3,"charIndex":512},{"text":"配置hooks","id":"配置hooks","depth":3,"charIndex":638},{"text":"本地配置","id":"本地配置","depth":2,"charIndex":835},{"text":"一般流程","id":"一般流程","depth":3,"charIndex":843},{"text":"hexo","id":"hexo","depth":3,"charIndex":905},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1037}],"domain":"","frontmatter":{"layout":"post","title":"使用git hooks进行hexo博客自动化部署","date":"2015-11-02 09:59:22","categories":["网站"],"tags":["git","hooks","部署","hexo"]},"version":""},{"id":131,"title":"Java调用外部命令","content":"Java调用外部命令#\n\nJava调用外部命令的基本方法是：通过Runtime.getRuntime()返回一个当前环境的运行时，通过运行时来调用外部的命令。\n\n\n函数原型#\n\n调用外部命令可以使用以下命令：\n\n> java.lang Class Runtime\n> \n> java.lang.Object java.lang.Runtime\n> \n> Process exec(String command) Process exec(String[] cmdarray) Process\n> exec(String[] cmdarray, String[] envp) Process exec(String[] cmdarray,\n> String[] envp, File dir) Process exec(String command, String[] envp) Process\n> exec(String command, String[] envp, File dir)\n\ncommand和cmdarray是要执行的命令。其中cmdarray[0]是要执行的命令，其它的作为参数。 envp是执行命令附带的环境。\ndir是执行命令所在的目录。 命令执行会返回一个Process对象，通过该对象可以与执行命令的子进程进行通信，包括写输入读输出等。\n\n\n示例代码#\n\n下面的代码演示了基本的使用方法，执行一个命令，并读取命令的返回。\n\n\n\n\n注意问题#\n\nJava执行命令不同于普通的Shell执行命令，一些命令需要自己指定shell执行，带有命令参数的命令最好通过cmdarray的方式执行。 例如：\n\n 1. 命令ping 127.0.0.1 可以写成\n\n\n\n 2. 重定向命令 echo 'hello' > 1.txt 需要写成\n\n\n\n\n参考内容#\n\n * Java运行命令行并获取返回值\n * JAVA调用系统命令或可执行程序","routePath":"/2015/10/30/java-exec-command/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":779}],"domain":"","frontmatter":{"layout":"post","title":"Java调用外部命令","date":"2015-10-30 14:46:45","categories":["编程语言"],"tags":["java","shell","cmd"]},"version":""},{"id":132,"title":"CentOS最简单安装与配置vsftpd","content":"#\n\n> 使用服务器搭建了一个静态网站，需要上传更新网页，于是想到了使用ftp服务来完成这个过程。\n\n\n什么是vsftpd#\n\nvsftpd 是“very secure FTP daemon”的缩写，安全性是它的一个最大的特点。vsftpd 是一个 UNIX\n类操作系统上运行的服务器的名字，它可以运行在诸如 Linux、BSD、Solaris、\nHP-UNIX等系统上面，是一个完全免费的、开发源代码的ftp服务器软件，支持很多其他的 FTP\n服务器所不支持的特征。比如：非常高的安全性需求、带宽限制、良好的可伸缩性、可创建虚拟用户、支持IPv6、速率高等。vsftpd是一款在Linux发行版中最受推崇\n的FTP服务器程序。特点是小巧轻快，安全易用。\n\n\n安装vsftpd#\n\n登录CentOS服务器，执行以下命令安装vsftpd\n\n\n\n如果还需要FTP客户端，可以运行\n\n\n\n确保启动时运行vsftpd服务\n\n\n\n启动vsftpd服务\n\n\n\n\n添加ftp用户并修改权限#\n\n添加一个ftpuser用户用来登录ftp，主目录在apache的网页目录下，禁止此用户登录SSH和shell，并限制其访问其它目录\n\n\n\n设置用户口令\n\n\n\n修改/var/www/html的权限\n\n\n\n\n配置vsftpd#\n\nvsftpd的配置文件在/etc/vsftpd/vsftpd.conf，打开这个文件\n\n\n\n修改以下配置\n\n\n\n重启vsftpd\n\n\n\n\n使用#\n\n现在可以使用一个ftp客户端通过普通的用户名密码方式登录ftp了，主目录限定在apache的目录下可以用来更新网站文件。\n\n\n参考内容#\n\n * CentOS 6.3 64位ftp服务器搭建-vsftpd安装及配置\n * How To Set Up vsftpd on CentOS 6\n * CentOS 6.4 下安装vsftpd","routePath":"/2015/10/26/centos-install-vsftpd-ftp-server-for-html-deployer/","lang":"","toc":[{"text":"什么是vsftpd","id":"什么是vsftpd","depth":2,"charIndex":51},{"text":"安装vsftpd","id":"安装vsftpd","depth":2,"charIndex":329},{"text":"添加ftp用户并修改权限","id":"添加ftp用户并修改权限","depth":2,"charIndex":424},{"text":"配置vsftpd","id":"配置vsftpd","depth":2,"charIndex":541},{"text":"使用","id":"使用","depth":2,"charIndex":621},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":689}],"domain":"","frontmatter":{"layout":"post","title":"CentOS最简单安装与配置vsftpd","date":"2015-10-26 21:41:49","categories":["服务器与系统"],"tags":["centos","vsftpd","ftp","服务","网站"]},"version":""},{"id":133,"title":"在Digital Ocean上部署shadowsocks","content":"#\n\n自从申请到Github的学生开发大礼包之后，就想怎么用其中的各种服务。之前使用goagent代理开始变得不太稳定了，于是考虑在Digital\nOcean上搭建一个新的代理，最终选择了shadowsocks。谨以此缅怀goagent和shadowsocks。\n\n\nDigitalOcean#\n\n\n邀请注册#\n\n在注册DigitalOcean之前，可以先去网上找一个邀请链接。通过邀请链接注册可以获得$10的奖励。\n（我的邀请链接：https://www.digitalocean.com/?refcode=dc33afe984e5）。\n\n\n充值激活#\n\n通过邀请链接注册之后还是不能创建虚拟主机，需要绑定信用卡或者充值$5。鉴于自身的这种情况下，还是充值$5比较好。\n充值我选择用PayPal，先去paypal.com注册一个账户，然后绑定一张银联卡（储蓄卡就可以）。接下来需要认证身份，和支付宝绑定银行卡差不多。\nPayPal身份认证完成之后，就可以在DigitalOcean生成充值账单，使用PayPal付款。请确保账户中有至少35元的余额。\n\n\n使用优惠码#\n\n激活完成后，账户中应该有$15余额。如果有Github的大礼包优惠码，可以使用。 在 Setting-Billing-Promo Code\n输入优惠码，但是一般是无法输入的，因为DigitalOcean需要进一步确认你的学生身份。 在 Support-Support Tickets\n里新建一个Ticket，大体说明一下你无法使用Github提供的优惠码。\n然后会有客服回复，需要向他们提供学生证、录取通知书、优惠码、Github申请截图、优惠码截图等信息，发送到指定的邮箱里。发送之后回复一下Ticket告诉他们信息\n已发送。 等大约一天左右就会看到账户里增加了优惠码的金额了。\n\n\n创建虚拟主机#\n\n之后创建虚拟主机，选择$5/mo的足矣。服务器位置我选择了San Francisco的，镜像选择了Ubuntu 14.04 x64，添加了IPv6的地址。\nSSH key我添加了没有起作用，之后还是选择了用户名密码的方式登录SSH。\n创建了之后root密码会发送到邮箱中，第一次登录需要重新设置root密码，没有收到或者忘记了可以选择重置root密码。\n\n\nShadowsocks#\n\n由于相关政策，shadowsocks已经不更新了，但是还可以继续使用。\n\n\n获取#\n\n在DigitalOcean的虚拟机页面上查到主机的IP。用SSH连接上去。\n\n\n\n第一次可能会要求修改root的密码。 先执行一下update命令更新软件源。\n\n\n\n更新完成后安装shadowsocks。\n\n\n\n如果使用的CentOS服务器，可以这样安装。\n\n\n\n\n启动shadowsocks服务#\n\n可以使用命令行方式启动/终止shadowsocks服务。\n\n\n\n也可以创建一个配置文件，例如shadowsocksconfig.json来启动。\n\n\n\n接下来就可以使用这个配置文件来启动/终止服务了。\n\n\n\n\nshadowsocks客户端#\n\nshadowsocks支持主流的平台，这里只列举了Windows的配置，其它的也差不多。 OS X / Windows 客户端的配置就是配置文件里设置的配置。\n\n浏览器的配置可以参考goagent的代理配置。这里使用了Chrome插件SwitchyOmega作为例子。\n\n\n参考内容#\n\n * 使用Digital Ocean和shadowsocks来科学上网","routePath":"/2015/10/23/build-shadowsocks-in-digitalocean/","lang":"","toc":[{"text":"DigitalOcean","id":"digitalocean","depth":2,"charIndex":133},{"text":"邀请注册","id":"邀请注册","depth":3,"charIndex":149},{"text":"充值激活","id":"充值激活","depth":3,"charIndex":271},{"text":"使用优惠码","id":"使用优惠码","depth":3,"charIndex":477},{"text":"创建虚拟主机","id":"创建虚拟主机","depth":3,"charIndex":778},{"text":"Shadowsocks","id":"shadowsocks","depth":2,"charIndex":966},{"text":"获取","id":"获取","depth":3,"charIndex":1018},{"text":"启动shadowsocks服务","id":"启动shadowsocks服务","depth":3,"charIndex":1156},{"text":"shadowsocks客户端","id":"shadowsocks客户端","depth":3,"charIndex":1279},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1433}],"domain":"","frontmatter":{"layout":"post","title":"在Digital Ocean上部署shadowsocks","date":"2015-10-23 18:49:01","categories":["网站"],"tags":["digitalocean","shadowsocks","上网","代理","github"]},"version":""},{"id":134,"title":"Atom快捷键整理","content":"#\n\n> 接触Atom有一段时间了，于是想好好看一看Atom的快捷键。网上找了几个快捷键列表，但是其中的一些快捷键在Windows下不能使用，所以就自己整理了一份。\n\n\n移动#\n\n\n基本#\n\nalt-B ctrl-left 移动到单词开始 alt-F ctrl-right 移动到单词结尾 ctrl-Home 移动到文件开始 ctrl-End\n移动到文件结尾 ctrl-G 跳转到指定行的指定位置，输入格式row:column\n\n\n标识#\n\nctrl-R 显示当前文档标识列表 ctrl-shift-R 显示当前工程标识列表 ctrl-T ctrl-P 查找文件\n\n\n书签#\n\nctrl-F2 显示书签列表 ctrl-alt-F2 在当前行添加/删除书签 ctrl-shift-F2 清除书签 F2 移动到下一个书签 shift-F2\n移动到上一个书签\n\n\n选择#\n\nshift-up 向上选择 shift-down 向下选择 shift-left 向前选择一个字符 shift-right 向后选择一个字符\nalt-shift-B ctrl-shift-left 选取至单词开始 alt-shift-F ctrl-shift-right 选取至单词结尾\nshift-end 选取至行结尾 shift-home 选取至行开始 ctrl-shift-home 选取至文件开始 ctrl-shift-end\n选取至文件结尾 ctrl-L 选取当前行 ctrl-A 全选\n\n\n编辑删除#\n\n\n基本#\n\nctrl-J 将下一行整合到当前行 ctrl-up ctrl-down 上下移动行 ctrl-shift-D 重复当前行 ctrl-K, ctrl-U\n当前单词大写 ctrl-K, ctrl-L 当前单词小写\n\n\n剪切删除#\n\nctrl-shift-K 删除当前行 ctrl-X shift-delete 未选中时剪切一行 ctrl-backspace alt-H 剪切到单词开始\nctrl-delete alt-D 剪切到单词结尾\n\n\n多重光标#\n\nctrl-click 添加光标 ctrl-D 选取和当前单词相同的下一处\n\n\n括号#\n\nctrl-M 跳转到最近的匹配括号 ctrl-alt-M 选择括号内的文本 ctrl-alt-. 闭合当前HTML/XML标签\n\n\n编码#\n\nctrl-shift-U 选择文档编码\n\n\n查找和替换#\n\nctrl-F 查找 ctrl-shift-F 当前工程查找\n\n\n缩写片段#\n\nalt-shift-S 查看所有片段\n\n\n自动填充#\n\nctrl-space 查看提示\n\n\n折叠#\n\nctrl-alt-shift-[ 折叠所有 ctrl-alt-shift-] 展开所有 ctrl-alt-[ 折叠当前 ctrl-alt-] 展开当前\nctrl-K, ctrl-n 折叠第n层 ctrl-alt-F 折叠选中文本\n\n\n面板#\n\nctrl-K arrow 向arrow方向分割面板 ctrl-K ctrl-arrow 将焦点移动到arrow方向的面板上 ctrl-W 关闭当前面板\n\n\n语言语法#\n\nctrl-shift-L 选择语言\n\n\nMarkdown#\n\nctrl-shift-M 预览","routePath":"/2015/10/19/atom-shortcut/","lang":"","toc":[{"text":"移动","id":"移动","depth":2,"charIndex":84},{"text":"基本","id":"基本","depth":3,"charIndex":90},{"text":"标识","id":"标识","depth":3,"charIndex":215},{"text":"书签","id":"书签","depth":3,"charIndex":283},{"text":"选择","id":"选择","depth":2,"charIndex":378},{"text":"编辑删除","id":"编辑删除","depth":2,"charIndex":634},{"text":"基本","id":"基本-1","depth":3,"charIndex":642},{"text":"剪切删除","id":"剪切删除","depth":3,"charIndex":754},{"text":"多重光标","id":"多重光标","depth":3,"charIndex":866},{"text":"括号","id":"括号","depth":3,"charIndex":912},{"text":"编码","id":"编码","depth":3,"charIndex":983},{"text":"查找和替换","id":"查找和替换","depth":2,"charIndex":1010},{"text":"缩写片段","id":"缩写片段","depth":2,"charIndex":1050},{"text":"自动填充","id":"自动填充","depth":2,"charIndex":1078},{"text":"折叠","id":"折叠","depth":2,"charIndex":1103},{"text":"面板","id":"面板","depth":2,"charIndex":1225},{"text":"语言语法","id":"语言语法","depth":2,"charIndex":1308},{"text":"Markdown","id":"markdown","depth":2,"charIndex":1335}],"domain":"","frontmatter":{"layout":"post","title":"Atom快捷键整理","date":"2015-10-19 20:13:52","categories":["高效生活"],"tags":["atom","快捷键"]},"version":""},{"id":135,"title":"Hexo MathJax插件","content":"#\n\n> 使用MathJax让Hexo博客支持数学公式。\n\n本来不打算为网站添加数学公式功能的，不过今天偶然看到了，发现添加比较简单，就尝试了一下。\n\n\n安装#\n\n在hexo博客的目录里执行\n\n\n\n\n使用#\n\n\n普通的行内公式#\n\n\n\n效果：\n\nSimple inline $a = b + c$.\n\n\n普通公式块#\n\n\n\n效果：\n\n$$ \\frac{\\partial u}{\\partial t} = h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2}\n+ \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2}\\right)\n$$\n\n\n标签行内公式#\n\n\n\n效果： This equation $\\cos 2\\theta = \\cos^2 \\theta - \\sin^2 \\theta = 2 \\cos^2\n\\theta - 1$ is inline.\n\n\n标签公式块#\n\n\n\n效果：\n\n$$ \\begin{aligned} \\dot{x} & = \\sigma(y-x) \\ \\dot{y} & = \\rho x - y - xz \\\n\\dot{z} & = -\\beta z + xy \\end{aligned} $$\n\n\n2018年6月6日更新#\n\n由于 hexo-math 使用了 hexo-inject\n进行latex相关解析库的javascript注入，但是在新版的hexo中hexo-inject对其支持不好，因此该方法会出现一些问题。\n\n现在本文改为使用 hexo-renderer-markdown-it-plus 配合 markdown-it-katex 进行latex公式的渲染。\n\n\n参考内容#\n\n * Hexo MathJax插件\n * hexo-math - Github","routePath":"/2015/10/17/hexo-mathjax-plugin/","lang":"","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":76},{"text":"使用","id":"使用","depth":2,"charIndex":99},{"text":"普通的行内公式","id":"普通的行内公式","depth":3,"charIndex":105},{"text":"普通公式块","id":"普通公式块","depth":3,"charIndex":151},{"text":"标签行内公式","id":"标签行内公式","depth":3,"charIndex":330},{"text":"标签公式块","id":"标签公式块","depth":3,"charIndex":441},{"text":"2018年6月6日更新","id":"2018年6月6日更新","depth":2,"charIndex":576},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":766}],"domain":"","frontmatter":{"layout":"post","title":"Hexo MathJax插件","date":"2015-10-17 20:25:12","categories":["实验室"],"tags":["网站","hexo","mathjax"]},"version":""},{"id":136,"title":"Android下smali常用注入代码","content":"#\n\n这几天做Android的CTF，发现使用smali注入的方式获取Flag的方法比较通用，所以写出来参考一下。\n\n\n简介#\n\n通过注入可以将一些内部变量输出到外部来，使一些看不到的内容看到。在Android一般输出的媒介有Toast和Logcat。\n\n\n注入方式#\n\n\nToast方式#\n\n\n\n可以将第三行的v4寄存器换成需要查看的寄存器。\n\n\nLogcat方式#\n\n\n\n同样可以将第二行v1寄存器换成需要的寄存器。\n\n\n注意事项#\n\n\n寄存器数量#\n\n在smali中，每个 .method 方法中都会用 .locals 声明需要寄存器的数量，在注入的时候要修改寄存器的数量进行扩充。\n\n\n格式转换#\n\n要查看的寄存器的内容需要为 String 类型，如果不是就需要转换。\n\nint转String#\n\n\n\nv1 为需要查看的int类型寄存器，转换后的结果存放到 v4 中。\n\nboolean转String#\n\n\n\nv1 为需要产看的boolean类型寄存器，转换后的结果存放到 v4 中。\n\n\n常用数据类型#\n\nSMALI   JAVA\nV       void 只能用于返回值类型\nZ       boolean\nB       byte\nS       short\nC       char\nI       int\nJ       long (64 bits)\nF       float\nD       double (64 bits)\n\n\n参考内容#\n\n * Android 反汇编Smali语言中插入log打印 | 学步园\n * Smali语法：数据类型、方法和字段","routePath":"/2015/05/18/android-smali-inject/","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":59},{"text":"注入方式","id":"注入方式","depth":2,"charIndex":128},{"text":"Toast方式","id":"toast方式","depth":3,"charIndex":136},{"text":"Logcat方式","id":"logcat方式","depth":3,"charIndex":174},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":212},{"text":"寄存器数量","id":"寄存器数量","depth":3,"charIndex":220},{"text":"格式转换","id":"格式转换","depth":3,"charIndex":296},{"text":"int转String","id":"int转string","depth":4,"charIndex":339},{"text":"boolean转String","id":"boolean转string","depth":4,"charIndex":389},{"text":"常用数据类型","id":"常用数据类型","depth":3,"charIndex":448},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":625}],"domain":"","frontmatter":{"layout":"post","title":"Android下smali常用注入代码","date":"2015-05-18 09:44:17","categories":["编程语言"],"tags":["smali","android","ctf"]},"version":""},{"id":137,"title":"你好，画廊","content":"#\n\n\n\n匆匆\n\n作者: 朱自清\n\n　　燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？\n又藏在何处呢？是他们自己逃走了罢：现在又到了哪里呢？\n\n　　我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，八千多日子已经从我手中溜去；像针尖上一滴水滴在大海里，我的日子滴在时间的流里，没有声音，\n也没有影子。我不禁头涔涔而泪潸潸了。\n\n　　去的尽管去了，来的尽管来着；去来的中间，又怎样地匆匆呢？早上我起来的时候，小屋里射进两三方斜斜的太阳。太阳他有脚啊，轻轻悄悄地挪移了；我也茫茫然跟着旋转。于\n是——洗手的时候，日子从水盆里过去；吃饭的时候，日子从饭碗里过去；默默时，便从凝然的双眼前过去。我觉察他去的匆匆了，伸出手遮挽时，他又从遮挽着的手边过去，天黑时\n，我躺在床上，他便伶伶俐俐地从我身上跨过，从我脚边飞去了。等我睁开眼和太阳再见，这算又溜走了一日。我掩着面叹息。但是新来的日子的影儿又开始在叹息里闪过了。\n\n　　在逃去如飞的日子里，在千门万户的世界里的我能做些什么呢？只有徘徊罢了，只有匆匆罢了；在八千多日的匆匆里，除徘徊外，又剩些什么呢？过去的日子如轻烟，被微风吹散\n了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸的回去罢？但不能平的，为什么偏要白白走这一遭啊？\n\n　　你聪明的，告诉我，我们的日子为什么一去不复返呢？\n\n","routePath":"/2015/04/22/hello-gallery/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"photo","title":"你好，画廊","date":"2015-04-22 11:21:49","categories":["实验室"],"tags":["图片"]},"version":""},{"id":138,"title":"Hello World","content":"#\n\n> A collection of Hello World applications from helloworld.org.\n\n\nC#\n\n\n\n\nC++#\n\n\n\n\nJAVA#\n\n\n\n\nAssembler#\n\n\n\n\n.NET#\n\n\n\n\nRuby#\n\n\n\n\nBASIC#\n\n\n\n\nPerl#\n\n\n\n\nPython#\n\n\n\n\nBash#\n\n\n\n\nBrainfuck#\n\n\n\n\nphp#\n\n\n\n\nPascal#\n\n\n\n\nDelphi#\n\n\n\n\n参考内容#\n\n * Hello World\n * Code Highlight 高亮示例","routePath":"/2015/04/21/real-hello-world/","lang":"","toc":[{"text":"C","id":"c","depth":2,"charIndex":68},{"text":"C++","id":"c","depth":2,"charIndex":75},{"text":"JAVA","id":"java","depth":2,"charIndex":84},{"text":"Assembler","id":"assembler","depth":2,"charIndex":94},{"text":".NET","id":"net","depth":2,"charIndex":109},{"text":"Ruby","id":"ruby","depth":2,"charIndex":119},{"text":"BASIC","id":"basic","depth":2,"charIndex":129},{"text":"Perl","id":"perl","depth":2,"charIndex":140},{"text":"Python","id":"python","depth":2,"charIndex":150},{"text":"Bash","id":"bash","depth":2,"charIndex":162},{"text":"Brainfuck","id":"brainfuck","depth":2,"charIndex":172},{"text":"php","id":"php","depth":2,"charIndex":187},{"text":"Pascal","id":"pascal","depth":2,"charIndex":196},{"text":"Delphi","id":"delphi","depth":2,"charIndex":208},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":220}],"domain":"","frontmatter":{"layout":"post","title":"Hello World","date":"2015-04-21 17:42:03","categories":["编程语言"],"tags":["代码"]},"version":""},{"id":139,"title":"你好，世界","content":"#\n\n博客已经建成。 之前使用的是Jekyll，由于荒废了好长一段时间了，所以干脆重新建设一个。","routePath":"/2015/04/17/hello-world/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"你好，世界","date":"2015-04-17 17:49:21","categories":["网站"],"tags":["随笔"]},"version":""},{"id":140,"title":"《创新、严肃、好玩的android应用程序开发》课程笔记③","content":"《创新、严肃、好玩的android应用程序开发》课程笔记③#\n\n> 《创新、严肃、好玩的android应用程序开发》第三周的视频，由于课程方那边圣诞放假，于是课程的 Deadline\n> 就推迟了三周，借这个时间也把手头的事情忙了一下。\n\n课程地址：https://class.coursera.org/androidapps101-001/class\n\n\n视图滚动#\n\n当视图内容超出手机屏幕的宽度和高度的时候，为了保证正常显示所有的内容，可以添加一个 ScrollView 来让视图可以滚动，以显示剩余的内容。\n\n视图的宽 android:layout_width 和高 android:layout_height 有三个属性 wrap_content\nmatch_parent fill_parent，作用分别为适应内容、填充父控件、填充父控件，后两个属性在作用上是一致的。\n\n\n程序的发布#\n\n安卓程序是一个 APK 格式的类压缩文件，真正要发布的 APK 程序需要签名，而我们测试时候安装到手机中的 APK 被 ADT 默认用了一个 DEBUG\n的签名，这样的 APK 程序是不能发布到商店的。\n\n要发布安卓程序，首先在工程上单击右键，选择 Export ，在其中找到 Export Android Application 。首先是选择一个 Keystore\n或者新建一个。这里新建一个，需要输入要设定的密码，Key 的名称，确认密码，密钥的有效期，密钥的组织等。密钥创建成功之后，选择要导出 APK 的目录即可导出。\n\n\n程序的安装#\n\n相同的包名，但是不同的签名的安卓程序是不能覆盖安装的，需要先卸载之前的版本。\n\n默认情况下，系统设置不允许安装其它来源的 APK 程序，需要在设置中解锁。\n\n在系统中打开 APK 文件，根据提示就可以安装 APK 程序了。\n\n\n参考内容#\n\n * Android Developers","routePath":"/2014/01/09/my-lesson-notes-on-coursera-androidapps101-001-3/","lang":"","toc":[{"text":"程序的发布","id":"程序的发布","depth":2,"charIndex":392},{"text":"程序的安装","id":"程序的安装","depth":2,"charIndex":666},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":788}],"domain":"","frontmatter":{"layout":"post","title":"《创新、严肃、好玩的android应用程序开发》课程笔记③","date":"2014-01-09 00:00:00","categories":["读书笔记"],"tags":["android","coursera","笔记"]},"version":""},{"id":141,"title":"《创新、严肃、好玩的android应用程序开发》课程笔记②","content":"#\n\n> 《创新、严肃、好玩的android应用程序开发》第二周的视频放出来了，这次主要将的是安卓程序的创建、运行还有资源布局方面的内容。\n\n课程地址：https://class.coursera.org/androidapps101-001/class\n\n在练习中看到的一个有意思的事情。\n\n打开 cmd 然后输入 telnet towel.blinkenlights.nl 23 就可以在命令提示符中看到用 ASCII 播放星球大战的电影。\n\n\n创建工程#\n\n 1. 打开 eclipse ，新建一个 android 项目， 【New】 -> 【Project】 -> 【New Android\n    Application...】。\n 2. 输入 Application Name ， Project Name 和 Package Name。Package Name 应该唯一。\n 3. 选择 Minimum Required SDK ， Target SDK 和 Compile With。\n 4. 可以在向导里创建简单的 ICON 图标，可以使用自定义图片，文字，图形等。\n 5. 记得创建一个 Blank Activity。\n\n\n手机端#\n\n在 Windows 和 Linux 系统下，需要下载 Usb Drivers，可以使用 豌豆荚 等软件代劳。\n\n手机需要打开【开发者模式】才能被电脑进行调试。 4.0 以上的安卓版本，首先在【设置】（Settings）->【关于手机】（About\nPhone）里面点击【编译版本】（Build number）七次，打开【开发者选项】（Developer options）。在【开发者选项】（Developer\noptions）中将选项设置为【打开】（On）。\n\n可以在【关于手机】中查看手机所使用的 Android 版本。\n\n\n工程运行（调试）#\n\n右键点击工程，选择【Run As】->【Android Application】。在运行界面中可以选择是通过真实手机（如果已连接）运行，还是通过模拟器运行。\n\nAndroid 工程的运行最小版本号（Minimum Required SDK）需小于手机端的版本号，后期我们可以在 AndroidManifest.xml\n修改。\n\n> AndroidManifest.xml 包含了组成应用程序的每一个组件(活动、服务、内容提供器和广播接收器)的节点，并使用 Intent\n> 过滤器和权限来确定这些组件之间以及这些组件和其他应用程序是如何交互的。\n\nAndroidManifest.xml 中的 package 代表 android 应用包的名字，android:minSdkVersion 代表最小需要的安卓\nAPI 版本。\n\n修改文件的时候需要注意文件的格式。\n\n\n工程简单修改#\n\n在目录结构 res -> layout -> activity_main.xml 下存放着工程的一个默认布局文件。通过修改布局文件可以修改引用改布局文件的\nactivity 的 UI 显示。\n\n在目录结构 res -> values -> strings.xml\n下存放着工程的一个字符串变量文件。一般都会将工程中使用的字符串提取出来放到该文件进行引用，目的是方便管理和国际化的进行。 文件中存在几个转义：\n\n> < 代替 < > 代替 > & 代替 & \\n 代替 回车换行\n\n向 LogCat 发送信息，可以在代码中使用 Log 类的内容。\n\n> Log.v 黑色，代表 VERBOSE 。 Log.d 蓝色，代表 DEBUG 。 Log.i 绿色，代表 INFORMATION 。 Log.w\n> 橙色，代表 WARING 。 Log.e 红色，代表 ERROR 。 Log.wtf 代表非常致命的 FAULT 信息（What a Terrible\n> Failure）。\n\n在工程中，若不导入相应的包，就需要使用全名来引用包的内容。如上面的命令就需要写成 android.util.Log.e()。\n\n\n图片资源的操作#\n\n使用 eclipse 中的 File Explorer 视图可以查看连接手机的内部文件，包括系统文件和 SD Card\n文件。可以通过方法将文件从手机复制出来然后添加到工程中。\n\n对于在资源管理中的修改， eclipse 并不会自动更新文件目录信息，需要按 F5 或者右键选择【Refresh】来重新加载资源。\n\n要想将资源添加到 android 工程目录中，并被 R 资源文件索引，文件名必须为 a-z，0-9，还有小数点下划线，不能包含其它字符。否则 eclipse\n将会给出错误提示。刷新 R 文件可以通过删除 R 文件然后重新生成来实现。\n\n在布局文件中，图片文件可以通过 ImageView 显示到界面上。\n\n图片文件太大会超出 Android 的运行内存，导致异常的发生。 Android 虚拟机为每个安卓 APP 提供了 16MB 的运行空间。\n\n在 Layout 文件中可以定义每个组件的相对关系，包括上下左右相邻。对于 ID ，@+id表示添加一个 view id\n供使用和索引。文件遵循先定义，后使用的原则。\n\nProperties 视图可以方便的修改各个资源的属性，这比直接修改 Layout 文件方便的多。\n\n\nres目录下资源文件夹的命名#\n\n资源文件夹通过不同的命名来适应不同的设备场景。 Android 会根据当前模拟器的情况自动寻找相应文件夹下的资源文件。\n\n场景布局资源文件夹。layout 适应与所有的布局场景，layout-land 适应于横屏场景，layout-port 是竖屏场景。\n\n通过不同的命名，使得一个应用可以根据不同的环境来读取不同的配置文件。具体可以参照 Android SDK 说明文档。\n\n\n参考内容#\n\n * Android Developers","routePath":"/2013/12/07/my-lesson-notes-on-coursera-androidapps101-001-2/","lang":"","toc":[{"text":"创建工程","id":"创建工程","depth":2,"charIndex":224},{"text":"手机端","id":"手机端","depth":2,"charIndex":521},{"text":"工程运行（调试）","id":"工程运行调试","depth":2,"charIndex":791},{"text":"工程简单修改","id":"工程简单修改","depth":2,"charIndex":1186},{"text":"图片资源的操作","id":"图片资源的操作","depth":2,"charIndex":1701},{"text":"res目录下资源文件夹的命名","id":"res目录下资源文件夹的命名","depth":2,"charIndex":2229},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2436}],"domain":"","frontmatter":{"layout":"post","title":"《创新、严肃、好玩的android应用程序开发》课程笔记②","date":"2013-12-07 00:00:00","categories":["读书笔记"],"tags":["android","coursera","笔记"]},"version":""},{"id":142,"title":"《创新、严肃、好玩的android应用程序开发》课程笔记①","content":"#\n\n> 在 coursra\n> 上学习《创新、严肃、好玩的android应用程序开发》这门课程，就把课程中重要的东西记录下来。因为是课程笔记，所以只记录了我认为比较有用的东西，也写的比较简\n> 练。\n\n课程地址：https://class.coursera.org/androidapps101-001/class\n\n\n安装环境的配置#\n\n可以去谷歌的 android 开发者网站 http://developer.android.com/sdk/index.html 下载。\n\n点击 “Download the SDK”，就会自动下载对应系统的 SDK 。Windows 和 Linux 注意区分系统的位数（32位 或者\n64位）。将下载到的压缩文件解压到合适的目录。\n\nSDK 中包含所需要开发模拟器和写代码的程序（eclipse）。\n\n接下来要去 Java 下载 Java SDK 6 ，由于电脑中已经安装，就不再阐述了。\n\n\n使用安卓模拟器#\n\n首先在解压出来的文件中找到 SDK Manager 这个程序，然后在其中选择下载需要的 API 版本（android 版本）。在 “Tools” ->\n“Manage AVDs...” 就可以创建模拟器了。\n\n创建好相应的模拟器启动。\n\n\n模拟器小技巧#\n\n两个模拟器之间发短信（Message）#\n\n启动两个模拟器之后，发现模拟器标题上有类似于端口号的东西（例如：5554），收信人的号码填写这个端口号即可。\n\nTelnet 的使用#\n\n使用 Telnet 可以连接到模拟器。\n\n首先我们了解一下 Telnet 的使用。\n\n使用 Windows 7 或 Windows 8 在命令提示符中可能会提示找不到 telnet 命令，找到 “控制面板” -> “程序和功能” ->\n“打开或关闭 windows 功能” -> “选中 telnet 客户端” -> “确定”。\n\n连接网站：在命令提示符中输入 telnet www.baidu.com 80 回车即可通过 80 端口连接到该网站。随便输入几个字符回车，即可发现网站返回\n“400 Bad Request” 的错误提示。\n\n使用命令 telnet 127.0.0.1 [端口号] 可以连接到虚拟机。\n\n 1. 使用 sms 命令发送短信 输入sms send 787 Hello Emulator! 即可想模拟器发送一条来自 787 的短信，内容是 “Hello\n    Emulator!”。\n\n 2. 使用 power 来修改电池电量 输入 power capacity 0 将电池电量改为 0 。\n\n 3. 使用 window 缩放窗口 输入 window scale 0.5 将模拟器窗口缩放到原先的二分之一。\n\n 4. 使用 avd 控制模拟器 avd stop 可以使模拟器停止响应。avd start 可以重新恢复。\n\n 5. 使用 gsm 电话控制 gsm call 123456 可以让模拟器接入一个来自 123456 的电话。gsm cancel 123456 来电\n    123456 主动挂断。\n\n\n快捷键#\n\n安卓模拟器快捷键可以参考开发网站上的内容。\n\n> Ctrl + F11 重力旋转 Ctrl + Enter 全屏\n\n\nIntel 模拟加速器#\n\n可以在 Android SDK Manager 中下载 Intel x86 Emulator Accelerator (HAXM) 。然后到\n\\sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manager 来安装。需要 CPU 的支持。\n\n\neclipse 的使用#\n\n两个工具 “LogCat” 和 “Devices” 。\n\nLogCat 用于捕捉来自模拟器应用进程的日志事件。 Devices 可以对模拟器进行一些控制，包括重启模拟器、对模拟器截图等等。\n\n创建工程 -> 编译 -> 启动模拟器 -> 安装app -> 运行。\n\n删除工程。\n\n\n参考内容#\n\n * Android Developers","routePath":"/2013/12/04/my-lesson-notes-on-coursera-androidapps101-001-1/","lang":"","toc":[{"text":"安装环境的配置","id":"安装环境的配置","depth":2,"charIndex":160},{"text":"使用安卓模拟器","id":"使用安卓模拟器","depth":2,"charIndex":417},{"text":"模拟器小技巧","id":"模拟器小技巧","depth":3,"charIndex":547},{"text":"两个模拟器之间发短信（Message）","id":"两个模拟器之间发短信message","depth":4,"charIndex":556},{"text":"Telnet 的使用","id":"telnet-的使用","depth":4,"charIndex":634},{"text":"快捷键","id":"快捷键","depth":3,"charIndex":1318},{"text":"Intel 模拟加速器","id":"intel-模拟加速器","depth":3,"charIndex":1383},{"text":"eclipse 的使用","id":"eclipse-的使用","depth":2,"charIndex":1543},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1698}],"domain":"","frontmatter":{"layout":"post","title":"《创新、严肃、好玩的android应用程序开发》课程笔记①","date":"2013-12-04 00:00:00","categories":["读书笔记"],"tags":["android","coursera","笔记"]},"version":""},{"id":143,"title":"EasyBCD硬盘安装Ubuntu","content":"#\n\n> 前一阵子不小心把Ubuntu搞坏了，进不了系统，于是就打算重装一下。\n\n用这种方法装 Ubuntu 的好处就是不用刻盘，也不用将 iso 的镜像刻到 U 盘引导中。还是比较方便的。\n\n\n准备#\n\n 1. 系统分区，这个大约准备 20GB 左右吧，我准备了 50GB ，我就直接用以前的分区了。\n 2. EasyBCD ，一个 BCD 启动管理软件，我的是 EasyBCD 2.2 ，1.7 以后的版本就可以了。\n 3. Ubuntu 的 iso 镜像，这个可以到官网下载，我用的是最新的 Ubuntu 14.04 ，推荐使用 13.04 吧，这个看个人喜好了。\n\n\n添加启动菜单#\n\n打开 EasyBCD，选择添加新项目（Add New Entry），然后选择 NeoGrub ，点击 安装（Install） 。\n\n\n\n安装之后选择 配置（Configure） ，之后将一下模板内容粘贴到编辑器中，保存。\n\n\n\n这里稍微解释一下代码的含义：\n\n> title 是引导菜单的标题 (hd0,0) 代表第一块硬盘的第一个分区，这个要根据你放的镜像的位置调整。我的默认放到 C 盘下面了\n> trusty-desktop-i386.iso 这是你下载的镜像的名称，注意不要写错了 注意：只是提供了一个模板，具体还要根据自己的实际情况进行调整。\n\n接下来把 Ubuntu 的光盘镜像 ISO 文件复制到 C 盘的根目录下面。用压缩软件或者虚拟光驱打开，找到 casper 文件夹，复制 initrd.lz 和\nvmlinuz 到 C 盘根目录下。 重启电脑。\n\n\n安装 Ubuntu#\n\n重启，你就会看到有2个启动菜单，选择 NeoGrub 这个，之后再选择 Install Ubuntu 14.04 这个菜单项。等一段时间之后就可以看到进入了\nUbuntu 的界面。如果出现错误，请好好检查一下那个文件是否正确，复制的文件的目录是否与配置文件中的信息对应起来了。 进入 Ubuntu 界面之后首先按\nCtrl+Alt+T 呼出控制台，输入\n\n\n\n来取消光盘镜像的挂载。 双击桌面上的图标开始安装 Ubuntu。之下来是部分图片。因为要分区，安装类型选择其它选项。（PS：我在 Ubuntu\n下面截的图挂了，只好先盗图用一下了。）\n\n\n\n注意分区的时候要特别小心，如果不太明白的话多去百度一下，数据可是无价的。 挂在分区的方案如下(以30G为例)：\n\n> / 20G ext4（根分区可以大点） SWAP 2G （大约为内存的 2 倍吧） /home 8G ext4（剩下的给/home）\n\n\n\n安装完成后就可以重启了。\n\n\n后续工作#\n\n重启之后会发现多出 GRUB 的引导菜单。 如果不需要再安装了，可以进入 Windows ，打开 EasyBCD 按照开始时候的操作，删除 NeoGrub\n即可。然后去 C 盘 删除 vmlinuz，initrd.lz 和 Ubuntu 的 iso 文件。 利用 EasyBCD 可以更改启动项菜单按 Edit\nBoot Menu 按钮，可以选择将 Windows 设为默认开机选项。不过它对于 Grub 的修改是无效的。\n\n\n参考内容#\n\n * Win7+Ubuntu11.10(EasyBCD硬盘安装) - allenjin","routePath":"/2013/11/27/install-ubuntu-with-harddisk/","lang":"","toc":[{"text":"准备","id":"准备","depth":2,"charIndex":97},{"text":"添加启动菜单","id":"添加启动菜单","depth":2,"charIndex":287},{"text":"安装 Ubuntu","id":"安装-ubuntu","depth":2,"charIndex":682},{"text":"后续工作","id":"后续工作","depth":2,"charIndex":1113},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1334}],"domain":"","frontmatter":{"layout":"post","title":"EasyBCD硬盘安装Ubuntu","date":"2013-11-27 00:00:00","categories":["服务器与系统"],"tags":["ubuntu","linux","装机"]},"version":""},{"id":144,"title":"只怪自己年少无知？——写给21岁的自己","content":"#\n\n> 以前也没码过啥字，就借着这个机会随便写点什么吧。\n\n又是一个平淡的生日呀，本来就不太喜欢热闹的我决定叫三个人一块去吃饭。。。结果，土豪不理我，大神回家了，还是老卜去了。去鸡公煲那里看了一下，呃，好多人呀，就去南方\n包子那里简单吃了一顿。。。俊哥送的键盘也到货了，真没用过这么好的键盘O__O\"…一下子就被镇住了。。。\n\n先从哪里开始说呢？不知不觉，21\n个年头了吧，时间总是过得那么的快。虽然不太顺利，但也算过得平平淡淡、开开心心的也就无所牵挂了。之前也经历过许许多多的事情，受过颇多人的照顾。真的非常感谢你们。\n\n有些时候我也在想，我究竟该干什么，该怎么干？之前杭州现场赛的惨状，又让我考虑自己是不是又坑了一次队友。很多时候，老师都说我的课程紧，导致时间上的矛盾，成绩上的矛\n盾，选择上的矛盾。而我又能说什么呢？\n\n一个月前，95 岁的老爷爷西去了，爷爷忙活的生病了。昨天又听闻邻居家 17\n岁的孩子淋巴肿大去世了，一时间太多的事情接踵而至，妈妈着急的空腔溃疡。而我又能做什么呢？\n\n想说的话没有说不出来，顾虑太多，羁绊太多，不懂时事，不勘人情。一切似乎都只在自己的臆想之中，开心、难过、懊悔、气愤、无语、默泪。而我又能干什么？\n\n整天窝在宿舍里，打游戏、看视频，一天又一天，一周又一周，每天过的也不知道是不是有意义，反正就是过去了。课也是听了，作业反正也做了。而我又能想什么呢？\n\n生活就是这个样子吧。你猜到了结局，却往往猜不到过程。只能怪自己年少无知吗？不明白利害关系，不懂得轻重缓急，只能怪自己年少无知吗？人情世故，世态轮回，伤心中的猝不\n及防，又只能怪自己年少无知吗？\n\n吴老师说，你是个毛孩子。亲人们说，还是个孩子，就不用这样了吧。学姐说，学弟好。。。年少无知，只是一个过程，而不能成为一个借口。有时候，我们会活在自己的年少无知中\n。以前看过一个漫画，一个地铁上的所有人都在想“这些无知的人呀。举世混浊而我独清，世人皆醉而我独醒。”我也许就是其中的一个吧。每天活在自己的无知之中。之前去杭州的\n火车上，一个初中模样的孩子说话字里行间却带着成熟的气息，听他说的一些话，我也懂得，可是为啥我就是说不出来呢。现在也只有“呵呵”能表达我的心境吧。\n\n还记得高中的时候，有一个一起搞 NOIP\n的学习特厉害的孩子（听说似乎是考上清华了），他说，成熟也许就是一天的事情。成熟是什么？依稀记得某人说过：“成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的音响，\n一种不再需要对别人察言观色的，一种终于停止向周围申诉求告的大气，一种不理会哄闹的微笑，一种洗刷了偏激的冷漠，一种无需声张的厚实，一种能够看得很圆却又并不陡峭的高\n度。”成熟就是长大吗？我还是不懂得的，也不知道还会留给我多少时间去懂得。。。\n\n一切都是那么的平静，今后的路还要慢慢的走下去。坑了队友，那下次就让队友坑回来；幸福，才是根本吧；每天都要充实。记得许三多说过，做一个有意义的人，做有意义的人就是\n做许许多多有意义的事。。。\n\n21 年的光阴，不多不少，承载了不多不少的质量。奔三的前奏已开始。接下来的生活还会有多少迷茫？\n\n最后，我的心愿是：祝愿一切都好。\n\nThe End","routePath":"/2013/11/17/happy-birthday/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"只怪自己年少无知？——写给21岁的自己","date":"2013-11-17 19:47:34","categories":["随笔"],"tags":["随笔"]},"version":""},{"id":145,"title":"简单了解JAVA对象序列化（Serializable）","content":"#\n\n> 今天在整理 BAE 相关内容的时候突然发现了一个新东西 serializable ，中文名是序列化。通过了解这个新姿势，我终于找到了一种将对象保存的方法。\n\n\n序列化是什么？#\n\n先来一个百度百科上的解释：\n\n> 序列化\n> (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存\n> 储区中读取或反序列化对象的状态，重新创建该对象。\n\n这里我们通俗一点来说就是将一个对象的状态数据保存起来，然后并可以根据这些数据恢复原来成的对象。当然，你也可以通过各种方法来保存一个对象的内部数据，但是 JAVA\n提供了一个更好的保存方式。\n\n\n序列化可以干神马#\n\n 1. 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；以某种存储形式使自定义对象持久化。\n\n 2. 当你想用套接字在网络上传送对象的时候；将对象从一个地方传递到另一个地方。\n\n 3. 使程序更具维护性。\n\n\n使用序列化#\n\n在JAVA中有一个接口\n\n> public interface Serializable\n\n类通过实现 java.io.Serializable\n接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列\n化的语义。\n\n下面通过一个例子简单了解一下序列化和反序列化：\n\n数据类：\n\n\n\n主方法：\n\n\n\n运行结果：\n\n> n = 888 n = 888\n\n如果我们想要序列化一个对象，首先要创建某些 OutputStream (如 FileOutputStream 、 ByteArrayOutputStream\n等)，然后将这些 OutputStream 封装在一个 ObjectOutputStream 中。这时候，只需要调用 writeObject()\n方法就可以将对象序列化，并将其发送给 OutputStream\n（记住：对象的序列化是基于字节的，不能使用Reader和Writer等基于字符的层次结构）。而反序列的过程（即将一个序列还原成为一个对象），需要将一个\nInputStream (如 FileInputstream 、 ByteArrayInputStream 等)封装在 ObjectInputStream\n内，然后调用 readObject() 即可。\n\n\n注意问题#\n\n 1. Serializable 序列化时，只对对象的状态进行保存，而不管对象的方法；\n 2. 当一个父类实现序列化，子类自动实现序列化，不需要显式实现 Serializable 接口；\n 3. 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化，即添加 Serializable 接口；\n 4. 并非所有的对象都可以序列化：安全方面的原因，比如一个对象拥有 private ， public 等 field，还有资源分配方面的原因等等；\n 5. 最好添加一个域 serialVersionUID （串行化版本统一标识符），来表明保存的对象使用的编码值。\n\n\n参考内容#\n\n * 序列化_百度百科\n * 我对Java Serializable（序列化）的理解和总结 - 锲而不舍 金石可錄\n * JAVA 对象序列化（一）——Serializable - chenfei0801","routePath":"/2013/11/16/first-step-simple-java-serializable/","lang":"","toc":[{"text":"序列化是什么？","id":"序列化是什么","depth":2,"charIndex":84},{"text":"序列化可以干神马","id":"序列化可以干神马","depth":2,"charIndex":321},{"text":"使用序列化","id":"使用序列化","depth":2,"charIndex":443},{"text":"注意问题","id":"注意问题","depth":2,"charIndex":1043},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1340}],"domain":"","frontmatter":{"layout":"post","title":"简单了解JAVA对象序列化（Serializable）","date":"2013-11-16 00:00:00","categories":["编程语言"],"tags":["java","姿势"]},"version":""},{"id":146,"title":"用Jekyll书写博客","content":"#\n\n> Jekyll 是一个简单的免费的 Blog 生成工具，类似 WordPress 。但是和 WordPress 又有很大的不同，它可以免费部署在 Github\n> 上。相信喜欢 DIY 的你一定会喜欢上它的。\n\n刚开始使用 Jekyll 也走了不少的弯路，查找各种资料，终于将自己的博客搭建起来了。之后就是向博客中添加自己喜欢的功能，包括语法高亮、 LaTex\n公式还有各种评论功能，忙的不亦乐乎，也是通过它才学会简单的使用 github 的。最近才发现自己的博客越来越臃肿了，不过也算乐在其中吧。\n\n距离刚使用 Jekyll 有好长时间了，好多东西也记不太清了，所以下面写的也是参考网络上的一些文章回忆的。\n\n\nWhat is Jekyll#\n\nJekyll 是一个静态站点生成器，它会根据网页源码生成静态文件。它提供了模板、变量、插件等功能，可以用来生成整个网站。\n\nJekyll 生成的站点，可以直接发布到 github 上面，这样我们就有了一个免费的，无限流量的，有人维护的属于我们的自己的 web 网站。Jekyll\n是基于 Ruby 的程序，可以通过 gem 来下载安装。\n\nJekyll官方文档：http://jekyllrb.com/\n\n接下来主要介绍 Jkeyll 在 github 上的部署与发布。关于 Jkeyll 在本地的调试环境可以参照我的上一篇博文。\n\n你需要对 github 有一点了解，如果不是很熟的话请参考相关资料。\n\n\n起步：构建 Jekyll 模板#\n\nJekyll 的模板是基于 bootstrap 的，下载jekyll-bootstrap的模板项目。\n\n\n从github下载模板#\n\n\n\n\n进入项目目录#\n\n\n\n\n查看目录模板#\n\n\n\n\n启动服务#\n\n\n\n打开浏览器访问网址 http://localhost:4000/ 就可以看到了。\n\n\n\n通过几条命令，就可以创建基于 boostrap 风格的网站。当然你也可以根据 jekyll 的语法自己来构建属于自己的模板。\n\n\n旅途：用 Mrakdown 书写文章#\n\n我们可以使用命令来创建空白的文章：\n\n\n\n你也可以仿照一下格式自己新建空白文章。文章需要使用 Markdown 语言书写，具体语法可以参照相关资料。\n\n\n\n文件名就命名为 年-月-日-文件名.md 放到 _post 目录下面。文章要保存为 UTF-8 无 BOM 格式编码，可以使用 Notepad++\n转换一下。然后运行命令启动本地服务器浏览一下。\n\n\n\n\n归宿：在 Github 上安家#\n\n在开始这一步之前，请确保你有一个 github 的账号。我们需要创建一个新的版本库，库名为你的 github 账户名 +\ngit的域名，假设为USERNAME.github.com 。创建版本库之后将版本库的内容下载下来。\n\n\n\n接下来过几分钟你就可以在 http://USERNAME.github.io 看到你的博客了。这个应该和你在本地看到的无异。\n\n然后你就可以在这个目录下写文章，本地浏览，觉得不错的之后就可以 push 到 github 上与他人分享啦。这里就可以知道为什么要吧文章保存为 UTF-8 无\nBOM 格式编码 的了，为防止 github 上生成的文章为乱码。如果文章中含有中文，一定要转换一下编码在 push 上去。\n\n\n遇到的问题#\n\n\n错误一#\n\n本地编译运行的时候你可能会遇到以下错误：\n\n\n\n这个是使用 GBK 编码读取 UTF-8 编码的文章造成的错误。找到 jekyll 安装目录，修改 convertible.rb 文件，第38行\n\n\n\n还有 tags/include.rb 文件，第129行\n\n\n\n\n错误二#\n\n这种错误也比较常见\n\n\n\n这种错误主要是 Mrakdown 语言的语法有错误。请注意一下方括号与尖括号的问题。修改之后一般就能编译了。\n\n\n参考内容#\n\n * Jekyll在github上构建免费的Web应用 | 粉丝日志\n * 利用Jekyll搭建个人博客","routePath":"/2013/11/09/writting-in-jekyll/","lang":"","toc":[{"text":"What is Jekyll","id":"what-is-jekyll","depth":2,"charIndex":310},{"text":"起步：构建 Jekyll 模板","id":"起步构建-jekyll-模板","depth":2,"charIndex":631},{"text":"从github下载模板","id":"从github下载模板","depth":3,"charIndex":702},{"text":"进入项目目录","id":"进入项目目录","depth":2,"charIndex":719},{"text":"查看目录模板","id":"查看目录模板","depth":2,"charIndex":731},{"text":"启动服务","id":"启动服务","depth":3,"charIndex":743},{"text":"旅途：用 Mrakdown 书写文章","id":"旅途用-mrakdown-书写文章","depth":2,"charIndex":861},{"text":"归宿：在 Github 上安家","id":"归宿在-github-上安家","depth":2,"charIndex":1062},{"text":"遇到的问题","id":"遇到的问题","depth":2,"charIndex":1404},{"text":"错误一","id":"错误一","depth":3,"charIndex":1413},{"text":"错误二","id":"错误二","depth":3,"charIndex":1551},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1627}],"domain":"","frontmatter":{"layout":"post","title":"用Jekyll书写博客","date":"2013-11-09 00:00:00","categories":["网站"],"tags":["jekyll","github"]},"version":""},{"id":147,"title":"jekyll本地环境搭建","content":"#\n\n> 用jekyll作为写作博客已经有半年多了，一直没有将搭建过程写出来。这几天正好想要给博客添加表格功能，本地环境却一直出错，遂决定重新搭建一下本地的博客环境。\n\n以下以 Windows 为例，说明一下本地测试环境搭建的过程。\n\n\n准备 Ruby 环境#\n\n由于 jekyll 是用 ruby 语言写的一个静态网页生成工具，所以要搭建 jekyll 本地环境就需要先配置好 ruby\n环境。鉴于本人对系统的配置也不是很熟，所以接下来的步骤能省则省。\n\n①.下载 RubyInstaller ，这是 Ruby 的一个集成包，除 Ruby\n之外，捆绑一些额外的资源库，能省掉一些麻烦。下载了“rubyinstaller-2.0.0-p247.exe”，记得安装的时候选上 “Add Ruby\nexecutables to your PATH” （添加系统环境变量）这样就省去了手动设置系统环境变量的麻烦，我这里安装到了 D:\\Ruby200 下\n\n②.下载对应版本 DevKit，我下载的是 “DevKit-mingw64-32-4.7.2-20130224-1151-sfx.exe”\n，解压进行执行相关命令。我解压到了D:\\devkit下，打开cmd，切换到D:\\devkit下，分步执行如下的命令，出现如下提示表示安装成功了：\n\n\n\n经过上面的两个步骤，基本的 Ruby 环境就搭建起来了。\n\n\n安装 Jekyll#\n\n在正式安装之前，建议先修改一下 Ruby 的镜像源，以加快速度。 可以参考一下http://ruby.taobao.org/的操作步骤。\n\n打开命令提示符，输入下面的命令（via ruby.taobao.com）来修改镜像源：\n\n\n\n可能会有点慢，耐心等待一下就好。\n\n接下来继续输入以下命令：\n\n\n\n出现版本号就代表安装成功了。期间可能会出现unable to convert \"\\XXX\" from ASCII-8BIT to UTF-8 for\nXXX/XXX.XX, skipping的错误，这个忽略就行，没什么影响。\n\n查看一下 jekyll 的帮助文件：\n\n\n\n至此，Jekyll 的本地环境搭建结束了。\n\n\n参考内容#\n\n * jekyll本地环境搭建(Windows) - yevon\n * Jekyll在github上构建免费的Web应用 | 粉丝日志","routePath":"/2013/11/08/set-up-jekyll-local-service/","lang":"","toc":[{"text":"准备 Ruby 环境","id":"准备-ruby-环境","depth":2,"charIndex":118},{"text":"安装 Jekyll","id":"安装-jekyll","depth":2,"charIndex":601},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":924}],"domain":"","frontmatter":{"layout":"post","title":"jekyll本地环境搭建","date":"2013-11-08 00:00:00","categories":["网站"],"tags":["jekyll"]},"version":""},{"id":148,"title":"开始驾照学习之旅","content":"#\n\n> 要开始学习驾照了，感觉好兴奋。有吗？嘿嘿。\n\n\n报名 2013-11-6#\n\n想不到居然拖了这么久，自从忙完上一件事情之后，直到现在才开始挪动我的懒惰去驾校报了名。本来还想拉几个小伙伴来着，结果。。。还是自己去了。。。\n\n上午打了把“炉石”就往后门的农大驾校去了，先前几天问过要准备的东西。从来没拿过那么的 Money\n，结果才在我手里呆了不到半个小时就交出去了。不过那边的阿姨（大妈？）倒是挺友好的。填了几个表，告诉我今天上午最好就去体检吧。\n\n接下来就坐 11 路车去了驾驶员学校体检。下公交车之后就迷路了，不过总算是找到了正确的道路。呃。。。体检人好多呀，听说昨天停电了，所以就压了一些人。排队等了 1\n个小时，终于轮到了，也就是输个电话号码，交个费⊙﹏⊙b汗，测个色盲，盖个章就好了。可惜照相的时候我没整理好发型，结果悲催了。。。听说排队的大叔说要跟我四年呀。。\n。回来算是正式报名了。一上午就这样过去了。\n\n下午在宿舍敲了一会儿代码，然后就去另一个地方确认报名。。。我乘 10\n路公交杀了过去，结果。。。又迷路了，转了一圈，终于找了了一个指示牌，把我领到了正确的位置。上去一看，我都不知道泰安有好多驾校呀。为啥唯独我报的驾校还没来办公人员\n。。。不过也没等多长时间，又是签了两个名，交了一个回执，还提醒我不要忘记下周的科目一培训。\n\n现在算是正式报名成功了吧。\n\n晚上石叔叔说周末有空的话可以教我学开车，这个。。。整天麻烦别人多不好意思。。。哎。。。\n\n\n\n\n科目一培训 2013-11-15#\n\n之前一直担惊受怕的，因为自从报完名之后，给了一个科目一的培训时间，我居然忘记了具体的日子，只记得是个星期五。。。于是今天去看了一下。。。\n\n早上起了个大早（7点起床，汗。。。），之后到7点40左右才等到公交。在公车上就看到几个似乎是去培训的童鞋，去了才知道果然是今天，好险好险。。。自己一个人就是心里\n没底。早知道就该拉个人一起去学车去，无奈嘴炮工夫不行，不能“动之以情，晓之以理”，人家不愿意去也不能强求嘛。。。问过女神要不要一起去，然后你懂的。。。女神现在就\n要开始准备考研了，不愧是（省略号），也没啥合适称谓。。。\n\n8点正式开始，来了好多人呀，看来今后要上车还要排好长时间来着，先把科目一过了再说吧。本来以为一会儿就结束了，听讲课大姐说要到中午11点，好吧，第二节的操作系统果\n断要逃掉了。。。形式也就是看视频，然后老师给讲一下其中考试的重点和容易错的地方。虽然形式单一，但讲课大姐挺有意思的，将重点的时候不忘给我们开几个玩笑，哈哈。。。\n\n昨天不应该吃辣椒的，肚子又开始闹腾了，中间出去了一下，看不见我看不见我。。。\n\n一上午的时间很快就结束了（写文章好陈旧的梗呀，接下来不会是我度过了有意义的一天→_→），结束的时候就是要填一个资料了，代表你参加了 12\n学时的科目一的培训学习。工作人员一个一个念名字，然后上去领材料，一上午就代表了 7 个签名呀。。。中间念到一个叫“ *\n冰雪”的，感觉名字好像同学的女盆友呀，可以没刘海，不像（其实我也不认识）。。。\n\n接下来应该暂时没什么动作了吧，大约再过 1 个月左右考试吧，然后好好背题目吧。。。\n\n\n\n\n科目一考试通知 2013-12-27#\n\n等了这么久，终于在这学期期末的时候等到了科目一考试的通知。期间老妈也在不停的问啥时候考试，既然等到了就努力备考吧。。。\n\n\n科目一注意事项培训 2014-1-4#\n\n距离报名已经过去两个月了，今天终于有点戏了。早上去驾校报名的地方去学习，因为这边还有一个教学培训，所以找了童鞋去顶替了一下。到了之后看着人还是挺多的，我们是驾校\n的第 135 期学员。\n\n首先是校长给我们讲科目二的内容，这个。。。好吧，校长真是能扯呀，说着说着两个小时就过去了，结果还是啥暂时有用的都没有说到。。。休息了一会儿，这才开始说科目一的注\n意事项，一般来说无非是考试机的使用之类的，还有啥时候去考试，去哪儿考试。一上午的时间就这样过去了，结果搞得顶替的童鞋饿死在机房了，囧。。。我赶紧回去把他解救了出\n来。。。\n\n\n科目一正式考试 2014-1-8#\n\n总感觉自己做了啥坏事似的，一直好背。。。本来实习光讲课还好，结果前一天才知道原来下午还要进行一次考核。。。这个驾照考试这边虽说 12\n点出发，这个还有返回的余地，但是就是不知道啥时候能考试呀。。。结果就这样我纠结了一天半左右的时间，找向实习老师说了两次，最终还是没有弄到啥结果%>_<%。。。于\n是也就破罐子破摔了。。。\n\n决定下午拼一拼人品，中午 12 点出发的话，下午 3\n点左右“应该”能回来吧？。。。但是实习那边也不能缺个人吧，只好再找个人替补一下了。结果那天的童鞋听到“替考”这两个字，顿时吓坏了。。。好吧，也许我用词太严重了。\n只不过是实习总结的测验嘛，事后证明监考一点儿也不紧（有监考的吗。。。），基本上 Copy\n一下就可以了。。。只好换老卜上场了，学长不愧是学长，果然老练O(∩_∩)O。。。\n\n这边打理好了之后我又给学院老师打了一个电话，这样就有了点心里安慰了，可以基本放心的去考试了。。。\n\n之前班里的童鞋就告诉我，要想快轮到的话就尽量排前边。中午 11 点半左右的时候我就从实习教室溜了出来，到达集合地点。12\n点多一点的时候开始出发去考试地点了。在大巴上感觉不放心，又做了两套题，结果还是不会呀，希望能考试顺利。。。30 分钟的车程赶到了考试地点。\n\n到达考试地点之后，由于没有看到带队的老师，人群先是犹豫了一会儿，然后就开始自己往考试地点走了，到达那边一看，原来已经有人在那儿开始排队了，赶紧去队尾站好，希望能\n快点轮到自己考完吧。。。考试的基本流程是：先到达一个大厅里面，按照顺序坐好，然后一排一排的进入里屋。在里屋里面念到名字就可以进入考场考试了。考试共 100\n道题，40 道判断，60 道选择。答案确定之后就不能更改，答错的题目会提示正确答案，答错 11\n题立即出局。。。这种考试方式还是第一次见，每答一道题就像是抽奖似的。。。不过还好啦，大约花了 15 分钟的时间就答完了。最终得了 96\n分，心里的一块石头终于落地了。。。\n\n交卷之后赶紧往回赶，这边交通不太方便，驾校只管去不管回，就按照同学推荐的拼了个出租回来的。终于不负众望，在 3\n点之前赶到了实习教室。接应了顶替我的老卜之后，实习这边的测验也很快就搞定了。。。\n\n总的来说，感觉还是比较高兴的，一方面是科目一的石头落地了，另一方面教学实习也结束了，假期开始了。。。在此要特别感谢照应我替身的子玉童鞋，我真的感受到了那种不知所\n措的滋味了。。。","routePath":"/2013/11/06/starting-getting-driving-license/","lang":"","toc":[{"text":"报名 2013-11-6","id":"报名-2013-11-6","depth":2,"charIndex":28},{"text":"科目一培训 2013-11-15","id":"科目一培训-2013-11-15","depth":2,"charIndex":-1},{"text":"科目一考试通知 2013-12-27","id":"科目一考试通知-2013-12-27","depth":2,"charIndex":-1},{"text":"科目一注意事项培训 2014-1-4","id":"科目一注意事项培训-2014-1-4","depth":2,"charIndex":1422},{"text":"科目一正式考试 2014-1-8","id":"科目一正式考试-2014-1-8","depth":2,"charIndex":1706}],"domain":"","frontmatter":{"layout":"post","title":"开始驾照学习之旅","date":"2013-11-06 00:00:00","categories":["随笔"],"tags":["随笔"],"description":"要开始学习驾照了，感觉好兴奋。有吗？嘿嘿。"},"version":""},{"id":149,"title":"百度BAE初次尝试","content":"#\n\n> 百度BAE类似于谷歌的网站应用发布，也具有托管网站的功能。今日突发奇想，就想把自己用J2EE写的一个小网站放到上面去，结果遇到各种问题。暂时算是解决了一些吧\n> ，将遇到的问题记录下来。\n\n\n使用的软件#\n\n百度开发者平台（以下简称 BAE 平台）可以支持 PHP 、 Java 和 Python 代码的 Web APP 。BAE 有着自己一套 MySQL\n数据库方法和代码托管方式。掌握好这些，对于今后写博客（不仅仅是写博客）找临时空间使用还是有好处的。\n\n对于代码托管方式，BAE 提供了两种方法 SVN 和 Git 。每种都有自己的好处，这里还是推荐使用 SVN 吧，至于为什么，其实我也不知道为什么。只是觉得\nGit 类的用过 Github 了。\n\n 1. SVN 软件就使用 TortoiseSVN ，可以去官网下载。\n 2. 编程环境 BAE 官方推荐使用 eclipse ，因为 BAE 有着一套适用于 eclipse 的 bdt 插件，myeclipse\n    是无法安装的，当然你也可以用 myeclipse 写完，然后用记事本修改提交。当然 BAE 的在线编辑环境也是很赞的。\n\n\n适配的问题#\n\n\n环境搭建#\n\nBAE 提供了一个用于 eclipse 的插件来支持 BAE 开发，所以在 myeclipse\n下暂时没法使用。可以考虑将需要移植到云平台特性的类单独写出来，然后重新书写一下。\n\nBAE 支持标准的 eclipse 开发目录，所以只要把整个目录提交上去就可以了，注意要删除编译生成的 classes 文件夹，还有建议将 IDE\n环境下用到的包，全部Copy到工程路径的 lib 目录下，就是根目录。如果对目录有什么疑问，可以下载新建的默认的版本库来查看目录结构。\n\n建议新建两个代码版本，一个用于发布网站，只将修改的可以发布的网站合并到该版本，另一个用于测试用。不然在一个版本里修改很无奈。\n\n\n配置文件#\n\nBAE 需要单独的配置文件 duapp-web.xml ，这个文件要放到和 web.xml 同目录。\n\n\n\n\n数据库连接#\n\nBAE 使用的是 mysql 云数据库，基本的数据库操作都能使用，就是在获取数据库用户名密码的时候不同，还有每次连接只能选择一次数据库。具体情况请参考 帮助文档\n\n下面的代码来自帮助文档，可以参考来改自己的数据库类。\n\n\n\n\n静态变量无法常驻内存#\n\n由于 BAE 使用的是分布式服务器，每次请求会随机落到一个服务器上，所有静态变量会重新初始化，即使是相同的客户端请求也不例外，所以无法保存，可以保存到\nCache 上或写到数据库里。\n\nCache 的使用方法可以参考：帮助文档\n\n\n\n\nSession 无法使用#\n\n原因同上，基于 BAE 的分布式特性，Session 也不能被很好支持，也是考虑将其添加到 Cache 中。\n\n我的方法是写一个类以 SessionID 作为键值对在 BaeMemcached 中进行登录信息的操作，并同步设置到 Session 里面。\n\n注意： 保存登录信息的对象要实现 Serialiable 接口。\n\n\n\n\n用户日志#\n\n在本地我们可以使用 System.out.println() 来打印用户日志，在云环境中要使用手动打印的方法来调试错误，具体可以参考帮助文档\n\n\n\n\n遇到的问题#\n\n\n问题1：默认分布式 Session 不开放#\n\n注意： 本方法只是解决了 Session 无法使用的错误提示，而没有真正解决 Session 在分布式系统中无法使用的局面。\n\n如果你的代码中使用了 Session，那么使用 Session 的时候会出现以下提示：\n\n\n\n解决方法就是在配置文件 duapp-web.xml 中添加一句 true 。\n\n注意不要拼写错误，否则发布无法成功。\n\n\n问题2：HTTP ERROR 404#\n\n登录的时候会出现\n\n\n\n解决方法： 弄一个 listener 。添加类 StrutsAppEngineAdapter ，内容如下：\n\n\n\n修改 web.xml ，把这个 listener 加进来：\n\n\n\n\n问题3：访问域名出错（此方法适用于 jetty 服务器，经测试不适合 Tomcat 服务器）#\n\n错误信息：\n\n\n\n错误的原因就是 Struts2 的拦截器设置了拦截所有的网址，却没有设置默认的 action，这就导致了首页网址找不到匹配的 action 操作。\n\n解决方案： 在 struts2 的默认 package 中加入以下配置\n\n\n\n\n问题4：对数据库进行中文操作的时候出现 Incorrect string value: \"\\XXX\\XXX\\XXX\\XXX\\XXX\" for column\n'XXX' at row 1#\n\n解决方法： 在连接 mysql 数据库的时候添加字符设置字段?useUnicode=true&characterEncoding=UTF-8。\n\n\n问题5：乱码导致 BAE 服务端发布失败#\n\nBAE 发布不成功，并且查看日志，出现下面的乱码。\n\n\n\n一种方法是更改 eclipse 的默认编码为 UTF-8 格式。修改方法如下：\n\n\n\n修改完的时候，文本文件中中文部分将变成乱码，注意修改这些乱码。\n\n另一种方法是用 BAE 的云编辑环境修改乱码，重新保存来解决。\n\n\n参考内容#\n\n * BAE使用笔记2-改造JFinal Demo部署到BAE上 - 土龙的个人空间\n * docs/cplat/rt/demo - 百度开发者中心\n * 在GAE中使用struts2框架 - 明年我18\n * Struts 2 on GAE – Error: result ‘null’ not found\n * (BAE)jetty8+struts2導致 welcome-file-list 失效\n * JAVA BAE 问题总结 - 记录走下的弯路, 让更多的人快捷到达终点 - 博客频道","routePath":"/2013/11/04/baidu-BAE-first-try/","lang":"","toc":[{"text":"使用的软件","id":"使用的软件","depth":2,"charIndex":100},{"text":"适配的问题","id":"适配的问题","depth":2,"charIndex":506},{"text":"环境搭建","id":"环境搭建","depth":3,"charIndex":515},{"text":"配置文件","id":"配置文件","depth":3,"charIndex":820},{"text":"数据库连接","id":"数据库连接","depth":3,"charIndex":882},{"text":"静态变量无法常驻内存","id":"静态变量无法常驻内存","depth":3,"charIndex":1003},{"text":"Session 无法使用","id":"session-无法使用","depth":3,"charIndex":1134},{"text":"用户日志","id":"用户日志","depth":3,"charIndex":1314},{"text":"遇到的问题","id":"遇到的问题","depth":2,"charIndex":1396},{"text":"问题1：默认分布式 Session 不开放","id":"问题1默认分布式-session-不开放","depth":3,"charIndex":1405},{"text":"问题2：HTTP ERROR 404","id":"问题2http-error-404","depth":3,"charIndex":1601},{"text":"问题3：访问域名出错（此方法适用于 jetty 服务器，经测试不适合 Tomcat 服务器）","id":"问题3访问域名出错此方法适用于-jetty-服务器经测试不适合-tomcat-服务器","depth":3,"charIndex":1725},{"text":"问题4：对数据库进行中文操作的时候出现 Incorrect string value: \"\\XXX\\XXX\\XXX\\XXX\\XXX\" for column 'XXX' at row 1","id":"问题4对数据库进行中文操作的时候出现-incorrect-string-value-xxxxxxxxxxxxxxx-for-column-xxx-at-row-1","depth":3,"charIndex":-1},{"text":"问题5：乱码导致 BAE 服务端发布失败","id":"问题5乱码导致-bae-服务端发布失败","depth":3,"charIndex":2067},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2229}],"domain":"","frontmatter":{"layout":"post","title":"百度BAE初次尝试","date":"2013-11-04 00:00:00","categories":["网站"],"tags":["bae","baidu"]},"version":""},{"id":150,"title":"ACM计算几何题目推荐及做题统计","content":"#\n\n> 先前这个是放在首页的，现在结束了就把它挪到这里了，也算是对之前过程的一个留念吧。\n\n这次的题目不再局限于POJ了，因为自己去年周游了各个OJ，反而很少在POJ切题了。而且这次推荐的题目比上次难了，也复杂多了。现在看回自己第一次写的计算几何题目推\n荐，实在感到当时自己写得有点肤浅。其实对于一些大牛来说，这些题目也算不了什么。\n\n下面的OJ之中，CII是指ACM-ICPC Live Archive ，网址是： http://cii-judge.baylor.edu/\n\n其他OJ的地址大家都熟知了，因此不再提供。\n\n希望各位转载的同志注明本文的出处。\n\n一。基础题目 1.1 有固定算法的题目\n\nA， 最近点对问题 最近点对问题的算法基于扫描线算法。 ZOJ 2107 Quoit Design 典型最近点对问题 AcceptPOJ 3714 Raid\n变种最近点对问题\n\nB，最小包围圆 最小包围圆的算法是一种增量算法，期望是O(n)。 ZOJ 1450 Minimal Circle\n\nHDU 3007 Buried memory\n\nC，旋转卡壳 POJ 3608 Bridge Across Islands 旋转卡壳解两凸包最小距离 AcceptPOJ 2079 Triangle\n旋转卡壳计算平面点集最大三角形\n\n1.2 比较简单的题目 HDU 3264 Open-air shopping malls ，圆面积相交问题，如果用二分法做的话不难 CII 3000\nTree-Lined Streets，几何+贪心\n\nCII 4676 Geometry Problem，模板题\n\nHDU 3272 Mission Impossible，枚举+镜面反射思想 POJ 3334 Connected Gheeves，二分答案，面积判定 POJ\n1819 Disks，模拟一下\n\nCII 3905 Meteor，貌似还是比较简单 ZOJ 2589 Circles，平面图的欧拉定理，圆的相交 POJ 2194 Stacking\nCylinders，向量旋转\n\n二。经典算法\n\n2.1 三角剖分\n三角剖分这个东西貌似去年流行了一下，高校联赛时某U连续出了两次。实际上对多边形进行三角剖分是一个很常见的算法思想，因为三角形是一个比较简单的凸多\n边形，可以对两个三角形比较容易地求公共面积，这也是三角剖分最常见的用途。对这个算法进行扩展，就可以求两个简单多边形的面积交了。主要是理解有向面积 的概念。\n\n第一类是圆与三角形的相交，主要做法是分情况讨论。 AcceptPOJ 3675 Telescope 三角形剖分，圆与三角形的交 AcceptPOJ 2986 A\nTriangle and a Circle 三角形剖分，圆与三角形的交 ZOJ 2675 Little Mammoth 三角形剖分，圆与三角形的交\n\n第二类是多边形与多边形相交。 HDU 3060 Area2 简单多边形面积并，三角剖分\n\n三角形剖分的另一种变种是梯形剖分，应用起来稍有局限性，但是比三角形剖分好写。 POJ 3148 ASCII Art 多边形梯形剖分，半平面交\n\n多边形的重心问题，也是三角形剖分的应用： CII 4426 Blast the Enemy!\n\n2.2 极角排序\n顾名思义，极角排序一般就是有一个圆心的问题，将平面上各个点按照与圆心极角进行排序。然后就可以在线性扫描之中解决一些统计问题。不过这类问题就稍稍超出计算几何范畴了\n。\n\nUVA 11696 Beacons 颇为经典的极角排序的统计问题，记得darkgt大牛有一篇文章提到这个题目。 CII 4064 Magnetic Train\nTracks，极角排序的统计问题，补集思想。 UVA 11704 Caper pizza POJ 2280 Amphiphilic Carbon\nMolecules，极角排序相当巧妙地解决了这个问题。\n\n2.3 扫描线算法\n扫描线算法，需要使用到平衡树辅助，写起来比较复杂（对于本菜而言）。关于平衡树，我建议是直接使用STL的set或map。所以你需要掌握一些C++的\n知识，才能够看懂一份使用了map与set的代码。当年学习OI牛的代码我看得很纠结。不过只要理解了“事件点”这一个概念后就比较好办了。\n\nHDU 3124 Moonmist 二分+扫描线。最近圆对，不存在改编最近点对的方法。不过当时数据弱，很多人乱搞过了 POJ 2927 Coneology\n平衡树+扫描线，与上题类似。\n\n下面两个题目都是关于多边形的扫描线算法，关于平面上许多凸多边形套了多少层的问题。 CII 4125 Painter\n，这个是Final题，比较简单，是判断三角形嵌套层数的。 UVA 11759 IBM\nFencing，上题是三角形，这题是多边形，稍稍难了一点。不过理解好扫描线算法的话应该没有问题。\n\n2.4 其他题目 POJ 3528 Ultimate\nWeapon，模板化的三维凸包。知道几个三维有向体积的概念即可比较容易理解三维凸包的算法。三维凸包算法又是一种增量算法。\n\n三。不确定算法/极值问题 POJ 3301 Texas Trip ，算是一种模拟退火求极值的问题，通过平面旋转找到最佳答案。 AcceptSPOJ 4409\nCircle vs Triangle(AREA1)，也是模拟退火 UVA 11562 Hard Evidence，应用三分极值法求极值。\n\n四。传统几何、公式题 UVA有一个名叫Shahriar\nManzoor喜欢出这些题目，喜欢这类题目的同志可以研究一本名叫《近代欧式几何学》的书。不过这些题目一般中学几何知识能够解决。 CII 4413\nTriangle Hazard，梅涅劳斯定理，想不到SCNU校赛出到了 UVA 11524 InCricle，三角形内切圆性质联立海伦公式 CII 4714\nIn-circles Again，还是公式推导 POJ 2208 Pyramids，欧拉四面体公式\n\n五。几何结合其他算法，麻烦题\n\nHDU 2297 Run，百度杯的题目，利用到了zzy的半平面交的极角排序思想。 CII 4448 Conduit\nPacking，问一个大圆能否放下四个小圆。颇为变态的Final题，算法都很基础，就是二分一个答案，枚举两个已知圆，求与已知的两圆公切的第三个圆，枚举放置的位置\n……关键是不好想。 CII 4510 Slalom 几何+最短路 UVA 11422 Escaping from Fractal Bacterium\n，麻烦题，主要还是向量旋转。 HDU 3228 Island Explorer，利用了最小生成树的性质。 CII 4499 Camera in the\nMuseum，有关圆形处理的，很不错的题目。 CII 2395 Jacquard Circuits，Pick公式的应用 POJ 3747 Scout YYF\nII，又是一个几何问题，需要猜想一下。 POJ 3336 ACM Underground，几何预处理，并查集 CII 4428 Solar\nEclipse，也是不错的题目，涉及圆的问题 CII 4206 Magic Rings，dancing links解重复覆盖问题，二分，百度杯也有个类似的题目。\nPOJ 1263 Reflections，与下面一个题目都是一类光线在球面上反射问题。解决方法是解析几何，参数方程，向量旋转等等。 CII 4161\nSpherical Mirrors，上面题目的三维版本。 POJ 3521 Geometric Map，复杂的预处理，可以用于自虐 CII 3270\nSimplified GSM Network 虽然有着V图的模型，但是规模小，所以无须出动V图算法，用半平面交即可。变态级的V图算法可以咨询三鲜教主。 CII\n4617 Simple Polygon，平面上有一堆点，叫你用一笔画把这些点连起来，连成一个闭合的简单多边形，线不允许出现相交。改造一下凸包算法即可。\n\n当然，除了上述的题目外，还有许多比较精彩的计算几何题目等待大家发掘。\n\n这两天在学习计算几何，随便说说自己的学习过程吧。\n\n　　基本的叉积、点积和凸包等东西就不多说什么了，网上一搜一大堆，切一些题目基本熟悉了就差不多了。\n\n　　一些基本的题目可以自己搜索，比如这个blog：http://blog.sina.com.cn/s/blog_49c5866c0100f3om.html\n\n　　接下来，研究了半平面交，思想方法看07年朱泽园的国家队论文，模板代码参考自我校大牛韬哥：\n\nhttp://www.owent.net/2010/10/acm-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E4%B8%AA%\nE4%BA%BA%E6%A8%A1%E6%9D%BF.html\n\n　　一些半平面交的题目：\n\n　　AcceptPOJ 3335 Rotating Scoreboard 　　http://poj.org/problem?id=3335\n　　AcceptPOJ 3130 How I Mathematician Wonder What You Are!\n　　http://poj.org/problem?id=3130 　　AcceptPOJ 1474 Video Surveillance\n　　http://poj.org/problem?id=1474 　　知识点：半平面交求多边形的核，存在性判断 　　AcceptPOJ 1279 Art\nGallery 　　http://poj.org/problem?id=1279 　　半平面交求多边形的核，求核的面积 　　AcceptPOJ 3525\nMost Distant Point from the Sea （推荐） 　　http://poj.org/problem?id=3525\n　　给出一个多边形，求里面的一个点，其距离离多边形的边界最远，也就是多边形中最大半径圆。\n　　解法：可以使用半平面交+二分法解。二分这个距离，边向内逼近，直到达到精度。 　　AcceptPOJ 3384 Feng Shui （推荐）\n　　http://poj.org/problem?id=3384 　　半平面交实际应用，用两个圆覆盖一个多边形，问最多能覆盖多边形的面积。\n　　解法：用半平面交将多边形的每条边一起向“内”推进R，得到新的多边形，然后求多边形的最远两点。 　　AcceptPOJ 1755 Triathlon （推荐）\n　　http://poj.org/problem?id=1755 　　半平面交判断不等式是否有解。注意不等式在转化时正负号的选择，这直接影响到半平面交的方向。\n　　AcceptPOJ 2540 Hotter Colder 　　http://poj.org/problem?id=2540\n　　半平面交求线性规划可行区域的面积。 　　AcceptPOJ 2451 Uyuw’s Concert\n　　http://poj.org/problem?id=2451 　　Zzy专为他那篇nlogn算法解决半平面交问题的论文而出的题目。\n\n　　(以上题目来自别人的blog，后面还有几题是我自己找到的)\n\n　　AcceptPOJ 1271 Nice Milk 　　http://poj.org/problem?id=1271 　　黑书习题\n\n　　UVA 11722 Joining with Friend\n　　http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=\n117&page=show_problem&problem=2769 　　概率问题，这个规模用半平面交有点浪费，不过就当练习了\n\n　　USACO 2010 MARCH GOLD StarCowraft\n　　http://61.187.179.132:8080/JudgeOnline/showproblem?problem_id=1829\n\n　　\n\n　　接下来稍微弄了一下坐标旋转的问题，具体可以参考武汉大牛的博文http://dumbear.com/blog/?p=143\n\n　　坐标旋转题目切得不多\n\n　　AcceptHDU 1700 Points on Cycle\n　　http://acm.hdu.edu.cn/showproblem.php?pid=1700 　　比较基础的一道题 　　POJ 3845 Fractal\n　　http://poj.org/problem?id=3845 　　注意eps的取值\n\n　　AcceptPOJ 1133 Stars 　　http://poj.org/problem?id=1133 　　Harbin Online Contest\n2010 　　http://acm.hrbeu.edu.cn/index.php?act=problem&id=1006&cid=16\n　　三维坐标旋转。这个要有账号才能提交，还有就是Sample Input 中第二个Sample的“275”改成“270”\n\n　　HDU 3623 Covering Points (2010天津网络赛C题)\n　　http://acm.hdu.edu.cn/showproblem.php?pid=3623 (航电没有这题了)\n　　http://acm.tju.edu.cn/toj/showp3740.html\n\n　　FZU 2002 Shade of Hallelujah Mountain (2010福州regional)\n　　http://acm.fzu.edu.cn/problem.php?pid=2002\n\n　　AcceptHDU 4087 ALetter to Programmers (2011 北京现场赛)\n　　http://acm.hdu.edu.cn/showproblem.php?pid=4087 　　三维旋转矩阵 + 矩阵加速\n\n　　然后是旋转卡壳，一个很好的学习网站http://cgm.cs.mcgill.ca/~orm/rotcal.html（不过是英文的），后来找到一个大牛的blo\ng里有部分翻译http://blog.csdn.net/ACMaker，综合起来看了一下，收益良多啊。\n\n　　一些旋转卡壳的题目\n\n　　AcceptPOJ 2187 Beauty Contest 　　http://poj.org/problem?id=2187\n　　凸包求最远点对。可以暴力枚举，也可以使用旋转卡壳。 AcceptPOJ 3608 Bridge Across Islands\n　　http://poj.org/problem?id=3608 　　两个凸包的最近距离。\n　　上面两题可以参考blog：http://www.cppblog.com/staryjy/archive/2009/11/19/101412.html（上面代\n码很不错） 　　AcceptPOJ 2079 Triangle 　　http://poj.org/problem?id=2079\n　　这题以为O(N^2)的复杂度会超时，结果就是O(N^2)复杂度\n\n　　UVA 10173\n　　http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show\n_problem&category=13&problem=1114&mosmsg=Submission+received+with+ID+8029560\n　　给定点集S,求S的最小覆盖矩形\n\n　　\n\n　　然后看了一些扫描线之类的东西。\n\n　　推荐几道比不错的题目：\n\n　　POJ 2932 Coneology 　　http://poj.org/problem?id=2932\n\n　　HDU 3124 Moonmist 　　http://acm.hdu.edu.cn/showproblem.php?pid=3124 　　最近圆对问题（二分\n+ 扫描线）\n\n　　HDU 3867 Light and Shadow 　　http://acm.hdu.edu.cn/showproblem.php?pid=3867\n　　(按极角扫描)注意-PI和PI的位置分割\n\n　　解析几何，平面最近点对，。。。这些搞得也不是很深入。\n\n　　\n\n　　折纸问题 参见大牛dumbear的blog http://dumbear.com/blog/?p=249\n\n　　两道题目\n\n　　POJ 1921 Paper Cut 　　http://poj.org/problem?id=1921 　　这题相对下一题还算比较好做\n\n　　POJ 3806 Origami Through-Hole 　　http://poj.org/problem?id=3806\n　　这题处理有点麻烦，我调试了很久才过\n\n　 　\n\n　　圆的面积并和交，详细可以看AekdyCoin大牛的blog\n\n　　圆的面积并：http://hi.baidu.com/aekdycoin/blog/item/c1b28e3711246b3f0b55a95e.html\n\n　　圆的面积交：http://hi.baidu.com/aekdycoin/blog/item/12267a4e9476153bafc3abbd.html\n\n　　题目：\n\n　　SPOJ 8073 The area of the union of circles\n　　https://www.spoj.pl/problems/CIRU/\n\n　　SPOJ 3863 Area of circles 　　https://www.spoj.pl/problems/VCIRCLES/\n\n　　SPOJ 8119 CIRU2 　　https://www.spoj.pl/problems/CIRUT/ 　　圆面积并的拓展\n\n　　HDU 3467 Song of the Siren 　　http://acm.hdu.edu.cn/showproblem.php?pid=3467\n\n　　HDU 3239 Jiajia's Robot (推荐) 　　http://acm.hdu.edu.cn/showproblem.php?pid=3239\n　　很巧妙的一道题，我是看了AC大牛blog中的留言才知道到方法的。 　\n方法见AC大牛blog中的一条留言：http://hi.baidu.com/aekdycoin/blog/item/12267a4e9476153bafc3ab\nbd.html\n\n　　\n\n　　凸多边形的面积并\n\n　　先看了AC大牛的blog学会了O(N^3)的方法，后来在做Codeforces的时候发现有O(N^2*logN)的方法，而且也不繁琐\n\n　　AC大牛的博文：http://hi.baidu.com/aekdycoin/blog/item/fbe5a03232c71952ad4b5fcc.html\n\n　　Codeforces Round #83 DIV1 的 E题用O(N^3)的方法过不掉第49组数据，然后研究了其他大牛的凸多边形交的代码\n\n　　http://codeforces.com/contest/107/status/E\n\n　　先是看了dagon的代码发现其实他的代码有问题，Codeforces的数据居然没有查出来。然后看了syntax_error的代码，\n\n　　发现他是用类似梯形剖分的方法做的，复杂度O(N^2*logN)，果断就学习了\n\n　　题目：http://codeforces.com/contest/107/problem/E\n\n　　有关细节：http://www.cnblogs.com/ch3656468/archive/2011/10/17/2215551.html\n\n　　有一类题目是给出一些点，并告诉你哪些点之间有连线，并且这些连线段之间除端点之外没有其他交点（有时候这些线段是要自己处理出来的）。\n\n　　然后题目要你求\n\n　　　　1 每小块多边形的面积\n\n　　　　2 有多少个K多边形内部不含点和线段\n\n　　　　3 这些线段围成的图形的轮廓线\n\n　　这类题目的方法都差不多，在很多大牛的blog里都可以找到类似的方法。\n\n　　比如：　gccfeli大牛的blog：http://gccfeli.cn/2007/09/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD\n%95-pku1092-%E5%A5%87%E7%89%B9%E7%9A%84%E6%8A%80%E5%B7%A7.html\n\n　　　　　　watashi大牛的blog：http://watashi.ws/blog/970/andrew-stankevich-3-solution/\n\n　　　　　　Isun大牛的blog：http://hi.baidu.com/xh176233756/blog/item/29652646f0e870006a63\ne5cb.html\n\n　　题目：\n\n　　POJ 1092 Farmland 　　http://poj.org/problem?id=1092\n\n　　ZOJ 2361 Areas / SGU 209\n　　http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=2361\n　　不错的一题，watashi的blog里有解题报告\n\n　　POJ 3743 LL’s cake 　　http://poj.org/problem?id=3743\n\n　　POJ 2164 Find the Border 　　http://poj.org/problem?id=2164\n\n　　三维几何\n\n　　网上有关三维几何的内容很少阿，代码和题目基本都不怎么能搜到，我也就切了不多的几题\n\n　　前面坐标旋转里的两到题：\n\n　　　　Harbin Online Contest 2010\n　　　　http://acm.hrbeu.edu.cn/index.php?act=problem&id=1006&cid=16\n　　　　三维坐标旋转。这个要有账号才能提交，还有就是Sample Input 中第二个Sample的“275”改成“270”\n\n　　　　FZU 2002 Shade of Hallelujah Mountain (2010福州regional)\n　　　　http://acm.fzu.edu.cn/problem.php?pid=2002\n\n　　SGU 110 Dungeon 　　http://acm.sgu.ru/problem.php?contest=0&problem=110 　　三维光线反射\n\n　　FZU 1981 Three kingdoms (2010福州网络赛)\n　　http://acm.fzu.edu.cn/problem.php?pid=1981 　　坐标映射，我一开始用map一直TLE，只好改成不用map的代码\n\n　　UVA 11275 3D Triangles\n　　http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=\n24&page=show_problem&problem=2250 　　HDU 4042是这题的加强版，我使用同样的代码AC的\n　　对于这题题目中诡异的精度0.000001我并没有特别处理\n\n　　HDU 4042 Fireworks (2011北京网络赛)\n　　http://acm.hdu.edu.cn/showproblem.php?pid=4042 　　很不错的题目\n(解题报告：http://hi.baidu.com/%D0%A1%CE%E4rj/blog/item/0114bb2dcd4cdef78b13991d.html\n)\n\n　　AcceptHDU 4087 ALetter to Programmers (2011 北京现场赛)\n　　http://acm.hdu.edu.cn/showproblem.php?pid=4087 　　三维旋转矩阵 + 矩阵加速\n\n　　其他一些题目：\n\n　　EOJ 283 Target Practice\n　　http://202.120.106.94/onlinejudge/problemshow.php?pro_id=283 　　搜索 + 几何\n\n　　POJ 1688 Dolphin Pool 　　http://poj.org/problem?id=1688 　　这题有好几种做法\n\n　　POJ 1981 Circle and Points 　　http://poj.org/problem?id=1981 　　很经典的一道题目\n\n\n\n　　http://poj.org/problem?id=1259 　　最大凸洞，计算几何 + DP\n\n　　POJ 1586 Three Sides Make a Triangle 　　http://poj.org/problem?id=1586\n　　题目内容很简单，方法也很明显，不过想AC可不容易，精度很恶心的一题，我是看了discuss才过的\n\n\n\n　　FZU 1973 How many stars (推荐) (2010福州网络赛)\n　　http://acm.fzu.edu.cn/problem.php?pid=1973 　　比较经典的一道题目\n\n　　POI2007 对称轴osi 　　http://www.zybbs.org/JudgeOnline/problem.php?id=1100\n　　很犀利的一道题目，题意是判多边形的对称轴个数，原来做的这种题目都是用O(N^2)的复杂度来解的，\n　　这次O(N^2)果断不行，加随机化也过不了，最后在解题报告的指导下才搞定这题。第一次发现计算几何 　　的问题居然还能用字符串的方法解。\n　　网上搜到的解题报告：http://hi.baidu.com/nplusnplusnplu/blog/item/d260baef2e9e9c5879f055c\nb.html","routePath":"/2013/10/29/summer-for-geometry-after-icpcacm/","lang":"","toc":[],"domain":"","frontmatter":{"title":"ACM计算几何题目推荐及做题统计","date":"2013-10-29 00:00:00","category":"读书笔记","tags":["ACM","计算几何","题目推荐","做题统计"]},"version":""},{"id":151,"title":"n! 与组合数的素因子分解","content":"#\n\n> 阶乘和组合数的素因子分解不同于一般的素因子分解，不同之处就在于枚举的不是每个数的所有素因子，而是每个素因子包含哪些数。\n\n\nn!的素因子分解#\n\n> 首先筛选出所有 [1,n] 的素数，然后对于一个素数 prime[i]，[1,n] 中有因子 prime[i] 的一定是形如：prime[i], 2 *\n> prime[i] ,3 * prime[i] ,...第一轮我们得到的是 n/prime[i] 个因子，并且将 n 变成 n/prime[i]，这样一直到\n> n 等于 0 的时候就可以求出所有 n! 的 prime[i]的因子了。\n\n这里应用了递归思想：\n\n假设我们以 9! 求解 2 这个素因子的个数为例：\n\n含有2这个素因子的数字有：\n\n\n\n计算过程：\n\n\n\n核心思想是看 [2,n] 中含 m^t 次方的个数，含 m,m^2....., 有多少个加几。和就为最后的结果。\n\n贴个代码，不是我写的。。。\n\n\n\n\n组合数的素因子分解#\n\n根据组合数公式 $C( n , m ) = n! / ( n- m )! * m!$\n\n可以将三个阶乘的素因子组合起来，个数进行加减运算（乘加除减）。具体的实现还是参照下面的题目吧。（太懒了，不想写了。。。）\n\n\n题目#\n\n下面以FZU1753为例：\n\n这个题目是求解多个组合数公共素因子的个数，根据上面组合数分解的算法，就可以很容易写出来了。至于题目为什么要进行素因子分解，因为组合数太大了。\n\n还有题目需要进行一些优化。我们要求解 公共 因子的个数，所以只求出最小的那个组合数之间的公因子个数就行了，大于它的素数因子个数的求解就没有意义了。\n\n\n\n\n参考内容#\n\n * FZU_1753 Another Easy Problem - Chris_Home\n * 阶乘因式分解 （n的阶乘分解质因数中含m的个数） - 我们一直在努力","routePath":"/2013/10/13/prime-factorization-for-n-factorial-and-combinatorial-number/","lang":"","toc":[{"text":"n!的素因子分解","id":"n的素因子分解","depth":2,"charIndex":66},{"text":"组合数的素因子分解","id":"组合数的素因子分解","depth":2,"charIndex":417},{"text":"题目","id":"题目","depth":2,"charIndex":536},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":706}],"domain":"","frontmatter":{"layout":"post","title":"n! 与组合数的素因子分解","date":"2013-10-13 00:00:00","categories":["算法"],"tags":["数论","算法"]},"version":""},{"id":152,"title":"数组中只出现过一次的元素","content":"数组中只出现过一次的元素#\n\n> 数组中其它元素都出现 k 次，只有一个元素出现一次，如何把它找出来。\n\n好久没来更新博客了，最近也只是在修改了几次博客的模板。感觉再不更新就要杂草丛生了。\n\n今天在刷微博的时候，无意间发现“秋大”转发了一个问题，感觉挺有意思的，但是自己的思路还是有些狭窄，还是通过他人的思路提醒才明白其中的奥妙的。\n\n\n题目描述#\n\n一个数组中有一个元素只出现1次，其他所有元素都出现k次（k>1)，求这个只出现1次的元素。要求：空间复杂度O(1),时间复杂度O(n).\n\n\n前期的思路#\n\n首先我们将 k 分为奇数和偶数考虑。对于 k 为偶数来说，只要将每个数异或起来，那么剩下的就是最终结果了；但是对于 k\n为奇数的情况，却没有很好的方法解决。于是这种方法先告一段落了。\n\n\n比较完美的方法#\n\n这里我们不要将每个数作为整体，而是把它分为好几个二进制位来考虑。这样我们假设数组中的元素为 32 位的整型，然后对于每个数，将二进制位对应加起来的和 mod k\n。那么结果就是 mod k 后的二进制位重新组合起来。\n\n以后再补个代码理解一下吧。\n\n\n后记 - To Be Continue#\n\n这种题目还有好多种变形，等以后整理一下，再整合到这篇博文里面吧。","routePath":"/2013/10/10/single-element-in-a-array/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"数组中只出现过一次的元素","date":"2013-10-10 00:00:00","categories":["算法"],"tags":["面试","算法"]},"version":""},{"id":153,"title":"三角形面积的计算公式","content":"#\n\n> 给出一个三角形，这里有好几个公式来得到它的面积。\n\n三角形面积没有什么特别的计算方法，只是对几个公式的理解。\n\n这里借鉴了一篇文章的几个公式，希望对今后的解题有所帮助。\n\n\n\n这里再将常用的几个写成代码形式：\n\n\n\n三角形面积也就是在不同情形下的不同应用，还是需要对各种公式的熟练掌握。","routePath":"/2013/08/07/triangle-area/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"三角形面积的计算公式","date":"2013-08-07 20:00:00","categories":["算法"],"tags":["姿势","计算几何","三角形面积"]},"version":""},{"id":154,"title":"给定半径圆覆盖点","content":"#\n\n> 给定一个圆，使其能覆盖平面上最多的点。\n\n\n题目模型#\n\n给平面上N个点的坐标 ( Xi,Yi )，给出圆半径 R ，求 R 能覆盖的最多的点数。\n\n\n题目分析#\n\n> 最初的分析就是移动，保证点在圆周上，然后圆以这一点为轴转动360度，检查有多少个点能被圆覆盖。操作时，对于基点 i ，如果 dist(i, j)\n\n这里再说明一下这种方法：\n\n首先将重叠的弧的开始点和结束点标示出来（如开始点为 1 ，结束点为 0），那么将弧按极角排序之后，遇到开始点的时候计数器加 1 ，遇到结束点计数器减\n1。统计这个期间计数器的最大值就是圆重叠的最大数。具体原理可以参考一下上面的图片。\n\n\n例题#\n\n\nhoj2704 Phone Cell#\n\n直接套用算法就可以解决。\n\n题目连接：http://acm.hit.edu.cn/hoj/problem/view?id=2704\n\n\n\n\nhoj1799 Circle and Points#\n\n这个问题与上一个问题类似，只不过半径固定为 1.0 。其它的没什么特殊的地方。\n\n题目链接：http://acm.hit.edu.cn/hoj/problem/view?id=1799\n\n\nhoj2940 Pit Lord#\n\n这个问题每个点都有一个权值，可以考虑“进入”的时候增加的是点的权值，而“离开”的时候减去点的权值。\n\n题目链接：http://acm.hit.edu.cn/hoj/problem/view?id=2940\n\n\n\n\nural1332 Genie Bomber#\n\n这个问题的特殊之处就在于每个点也有自己的半径，也就是用大圆 R 来覆盖若干小圆 r 。这里的处理方法是将 R-r 作为覆盖圆来使用。注意 R-r\n为负值的时候要输出 0 。\n\n题目链接：http://acm.timus.ru/problem.aspx?space=1&num=1332\n\n\n\n\n参考内容#\n\n * 【转】HOJ2704 Phone Cell 计算几何_AekdyCoin的空间\n * 单位圆覆盖平面上点 - wujiawei@HIT\n * 北京邮电大学-北邮人论坛-北邮人的温馨家园 -- [模板]二维几何模板","routePath":"/2013/08/06/Radius-Circle-Cover/","lang":"","toc":[{"text":"题目模型","id":"题目模型","depth":2,"charIndex":26},{"text":"题目分析","id":"题目分析","depth":2,"charIndex":80},{"text":"例题","id":"例题","depth":2,"charIndex":296},{"text":"hoj2704 Phone Cell","id":"hoj2704-phone-cell","depth":3,"charIndex":302},{"text":"hoj1799 Circle and Points","id":"hoj1799-circle-and-points","depth":3,"charIndex":393},{"text":"hoj2940 Pit Lord","id":"hoj2940-pit-lord","depth":3,"charIndex":516},{"text":"ural1332 Genie Bomber","id":"ural1332-genie-bomber","depth":3,"charIndex":642},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":813}],"domain":"","frontmatter":{"layout":"post","title":"给定半径圆覆盖点","date":"2013-08-06 00:00:00","categories":["算法"],"tags":["算法","计算几何"]},"version":""},{"id":155,"title":"8-2-SDAU练习赛（泰山挑夫1）点题报告","content":"8-2-SDAU练习赛（泰山挑夫1）点题报告#\n\n> 老师说要向泰山挑夫那样一步一步。\n\n今天的练习赛似乎又回到了上个暑假的时候，只是感觉少了点什么。\n\n题目大都很基础，只挑几个没有解决的问题说一下吧。\n\n> 6E Exposition 6D Lizards and Basements 2 6C Alice, Bob and Chocolate 6B\n> President's Office 6A Triangle brute 4D Mysterious Present 4C Registration\n> System 4B Before an Exam 4A Watermelon math\n\n\nCodeforece 4D Mysterious Present#\n\n题目大意：\n给出一些信封的长和宽，还有一个礼物。现在要把礼物装到信封中。可以将信封嵌套装到信封中。要求嵌套的层数最多。求解最多的层数。一件物品（礼物和信封）要被装到信封里，\n长和宽必须严格小于外面的信封。\n\n大体思路： 先将信封按照长排序，长相等的可以按照宽排序。然后就可以类似于【最长上升子序列】一样进行dp求解。\n\n遇到的问题：\n首先是只从能开始装到礼物那个信封开始dp的，而且只把那个信封的层数设为了1，这就导致起点的位置不正确。保存解的时候，也只是考虑了一个，最后把所有的数组都设为了\n-1 。\n\n\n\n\nCodeforces 6E Exposition#\n\n题意： 给出一些书，这些书已经固定了次序。从中选出一个区间，保证这个区间最长，而且不超过设定的值 k 。只输出最长区间的书的范围。\n\n大体思路： 考虑到记录每个区间最大值和最小值的问题，我想到了用单调队列，两个单调队列分别用来保存最大值和最小值。然后如果最大值和最小值超过了 k\n，就两个队列中编号最小的那个值，并根据区间的长度保存区间的范围（用了无数个 vector ）。最后输出最长区间的区间范围即可。\n\n遇到的问题： 感觉就是题意没理解好，最后看着数据才慢慢理解了题意。这道题算是根据数据水过的吧。。。\n\n\n\n贴个几个简单的代码理解一下吧，比我的代码简单多了。\n\n代码1：\n\n\n\n代码2：\n\n","routePath":"/2013/08/02/sdau-practice-contest/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"8-2-SDAU练习赛（泰山挑夫1）点题报告","date":"2013-08-02 00:00:00","categories":["读书笔记"],"tags":["解题报告","codeforces"]},"version":""},{"id":156,"title":"判断一个点是否在凸包（多边形）内","content":"#\n\n> 判断一个点是否在凸包内是比较常用的一个算法。\n\n判断一个点是否在凸包（多边形）内是比较常用的一个算法，总结了一下出现的方法，主要找到了下面的几种。\n\n\n方法一：外积计算法（只适用于凸多边形）#\n\n简单来说就是将点到凸多边形的顶点的各条向量，通过外积运算判断是否都往同一方向旋转，如果都是往同一方向旋转，则表示点在凸多边形的内部；如果中途出现反方向旋转，则说\n明点在凸多边形的外部；如果中途出现为零的情况，表示点在凸多边形上，而且就在对应的边上。\n\n时间复杂度为O(N)\n\n\n\n\n方法二：区域判别法#\n\n这种方法适用于快速判断多个点是否在一个凸多边形内。\n\n\n\n首先，将一个凸多边形划分为 N 个三角形的区域。\n\n\n\n对于某一个点，如果不在这些三角形区域内，则必不在凸包内。否则就能通过二分的方法得到点所在的三角形区间。\n\n最后只需判断点与原凸包边的关系即可。\n\n\n\n假设我们查询绿色的点是否在凸包内，我们首先二分得到了它所在的区间，然后判断它和绿色的向量的关系，蓝色和紫色的点类似，蓝色的点在边界上，紫色的点在边界右边。\n\n由于应用了二分，时间复杂度为O(logN)。\n\n问题链接：SGU253 Theodore Roosevelt\n\nsgu253 这个问题需要使用极角序判断才能通过，而 cf116B 因为精度问题（把 eps 开到 1e-20 了都过不了）就需要使用叉乘判断，但是叉乘判断对于\nsgu253 却不起作用。两题的方法不能通用，也不知道这是为什么？\n\nsgu253 代码：\n\n\n\nCF116B 代码：（方法四提供了其它解法）\n\n\n\n\n方法三：射线相交法#\n\n从给定的点开始，往随便一个方向（习惯水平向右）引一条无限长的射线，看看穿过多少条边。如果穿过偶数条边，说明点在多边形外；穿过奇数条边，说明点在多边形内。\n\n需要注意的是射线可能穿过定点或与边重合的情况。还有点也可能在多边形的边界上。\n\n时间复杂度为O(N)\n\n\n\n\n\n补充两段代码：\n\n代码一：\n\n\n\n代码二：\n\n\n\n\n方法四：面积比较法#\n\n我们知道计算面积有两种方法（具体可以参考【计算多边形的面积】），而两种方法的区别是关于有没有使用基点。\n\n于是对于存在基点的方法，如果基点在多边形内，那么划分三角形得到的面积的符号都是相同的（逆时针计算的话都为正）。但是如果基点选在多边形外，就会出现相反符号的面积抵\n消的情况。这样来说，如果我们都按绝对值来计算每个划分三角形的面积，那么基点在多边形外的到的面积将会比真正的面积大。\n\n我们可以通过积分方法和基点方法分别计算面积，然后通过比较两种方法的面积判断基点的位置。如果面积相等，则说明基点在多边形内；如果不相等，则说明基点在多边形外。\n\n\n\n\n方法五：共求凸包法#\n\n在codeforces的一道题目里看到的这种方法，适用于点比较多的情况。\n\n大体思路是将凸包上的点与内部的点共同求凸包，如果最后求得的凸包中出现了原先没有出现的点，则证明有些点不严格在凸包内部。\n\n题目链结：Codeforces 166B Polygons\n\n这里大体讲解一下代码。题目要求的是严格在凸包内，那么就要求即使存在共线的点，也要出现在凸包上。\n\n这里提供两组cf上的测试数据\n\n\n\n可以看出，这两组测试数据形式上差不多，关键在于共线点存在的位置。这里为了使共线点出现在最后的凸包上，我们把最左上角的点和最右下角的点的连线作为参考线。在参考线右\n边的可以考虑按距离近的先排序，在参考线左边的可以考虑按距离远的先排序，这样的目的是为了保证真正的极角排序是按照逆时针（或顺时针） 形成的。这就有了下面代码的\ncmp 函数。\n\n\n\n图片中点极角序是 S->C->J->D->E->T->I->F->G->H->K\n\n如果先K再H，k点一定会被弹出，但是先H再K就不会。\n\n我的渣代码：\n\n\n\n我还发现还有其它的一些代码是相同的思路，但是使用了不同的实现方法。将点按坐标排序之后，然后求一个正向凸包，再求一次逆向凸包。最后就出结果了？？？还在考虑这是为什\n么。\n\n后来还是看了看，似乎明白了点。\n\n上面也提到了，前部分和后部分对于相同极角序的距离判断是不同的。极角序小的时候距离小的在前边，而极角序大的时候，正好想法。\n\n现在我们不考虑极角序对于距离的影响，统一进行相同的排序，那么在求凸包的时候正向凸包会把一些极角共线点包含进去，然后当反向求凸包的时候又会吧另一些极角共线点包含进\n去。由于正序和逆序对于严格的凸包上的点没有什么影响，不同的只是一些共线点的多少，通过两次求解凸包就会把所有的极角共线点包含进去，从而解决了分开排序的问题。\n\n\n\n\n参考内容#\n\n * 演算法筆記 - Polygon\n * URAL/1215 - NOCOW\n * 【SGU 253】【Theodore Roosevelt】【快速判定点是否在凸包内】_AekdyCoin的空间\n * CodeForces 166B Polygons_银白之翼\n * Codeforces 166B - Polygons - Join Hands","routePath":"/2013/08/01/Point-in-Polygon/","lang":"","toc":[{"text":"方法一：外积计算法（只适用于凸多边形）","id":"方法一外积计算法只适用于凸多边形","depth":2,"charIndex":80},{"text":"方法二：区域判别法","id":"方法二区域判别法","depth":2,"charIndex":243},{"text":"方法三：射线相交法","id":"方法三射线相交法","depth":2,"charIndex":679},{"text":"方法四：面积比较法","id":"方法四面积比较法","depth":2,"charIndex":851},{"text":"方法五：共求凸包法","id":"方法五共求凸包法","depth":2,"charIndex":1139},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1926}],"domain":"","frontmatter":{"layout":"post","title":"判断一个点是否在凸包（多边形）内","date":"2013-08-01 00:00:00","categories":["算法"],"tags":["算法","计算几何"]},"version":""},{"id":157,"title":"计算多边形的面积","content":"#\n\n> 计算一个多边形的面积有很多种方法。\n\n对于一个多边形来说，凸多边形是特例中的特例，我们就以凸多边形为例来讨论这个问题。\n\n\n方法一：三角形分割#\n\n通过分治思想，把凸多边形分割为若干个三角形，这样就容易计算面积了。\n\n\n\n我们可以取多边形内的一个点，然后将改点依次与各边连线，这样多边形就被分割为多个三角形了。我们就可以使用外积来计算每个三角形的面积，然后加起来得到多边形的面积。\n\n\n\n实际上，由于外积存在正负之分，这样我们选取的点不单单可以在凸多边形的内部，也可以在外部甚至是边界上。正值覆盖到多边形的面积，而负值刚好是多余图形的面积，正负相消\n，得到的就是多余图形的面积。\n\n\n\n如果不限定基点的选取，那么选取原点最为方便，这样就不必刻意计算每个点的向量，可以直接拿相邻两点的坐标计算外积。\n\n我们可以写成数学公式：\n\n\n\n这里说明一下，如果按逆时针旋转，求出来的为正值；如果按顺时针旋转，求出来的为负值，还要再取绝对值。\n\n\n\n\n方法二：积分方法#\n\n对于每一条边，我们可以将其对 x 轴进行积分，计算边与 x 轴与竖直边界围成的梯形的面积。\n\n面积为\n\n> Point s,t; double area = (s.x+t.x)/2.0 * (s.x-t.x);\n\n\n\n这里我们也要按照逆时针考虑，这样得到的面积也就存在正负之分，正好将多余部分抵消，得到面积。\n\n\n\n\n应用#\n\n 1. 求解面积\n\n这个就不用多说了，求解凸多边形的面积，这是必须的应用。\n\n 2. 判断基点是否在凸多边形内\n\n首先我们考虑一下【方法一】和【方法二】在计算面积上有什么不同。就是【方法一】需要选取基点，也就是说【方法二】计算得到的面积可以作为一个参考。这样，我们可不可以考\n虑通过这两个面积计算方法的不同点来判断基点的位置。\n\n关键点就是【方法一】对于面积存在正负，如果我们不考虑面积的正负，而全部取绝对值，那么基点在凸多边形内和凸多边形外对于面积的计算就会存在一定的影响。\n\n具体方法在 判断点是否在多边形内 一并讲解。\n\n\n参考内容#\n\n * 演算法筆記 - Polygon\n * URAL/1215 - NOCOW","routePath":"/2013/07/31/Polygon-Area/","lang":"","toc":[{"text":"方法一：三角形分割","id":"方法一三角形分割","depth":2,"charIndex":66},{"text":"方法二：积分方法","id":"方法二积分方法","depth":2,"charIndex":423},{"text":"应用","id":"应用","depth":2,"charIndex":593},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":863}],"domain":"","frontmatter":{"layout":"post","title":"计算多边形的面积","date":"2013-07-31 00:00:00","categories":["算法"],"tags":["算法","计算几何"]},"version":""},{"id":158,"title":"极角排序","content":"#\n\n> 通过一个简单的排序算法，从不同角度解决问题。\n\n今天第一次接触到几何类的问题，看到了一个极角排序，感觉很有用处。\n\n\n定义#\n\n我们平常所使用的坐标系都是直角坐标系，而极角排序是在极坐标系下进行的。 这里首先要选取一个点，然后其它点根据与参考点的连线与x轴所成的夹角的大小进行排序的。\n这里我们可以简单理解为绕着一个点逆时针转圈访问。\n\n\n\n盗一下别人家的图来用一下。。。\n\n\n代码#\n\n对于计较排序来说，最重要的还是cmp函数的书写，这里有一下几种书写方式：\n\n1、 利用叉积的正负来作 cmp 。\n\n\n\n2、 用 complex 的内建函数，算出极角大小。这个函数没有用过。\n\n\n\n3、 用 arctan 计算极角大小。注意角的大小范围是(-180°, +180°]。弧度表示。这里用 arctan2 函数应该是为了提高精度。\n\n\n\n4、 先判断象限，再用外积判断顺序，最后根据长度排序。\n\n\n\n5、 先判断象限，再用外积判断顺序。适用于每个点的极角都不相同。\n\n\n\n最后别忘了几个重要的东西，根据自己的需要修改吧。\n\n\n\n--------------------------------------------------------------------------------\n\n补充一下在题目中遇到的极角排序的 cmp 函数的写法：\n\n\n\n\n参考内容#\n\n * 演算法筆記 - Point, Line, Plane\n * POJ 2007(计算几何初步——极角排序) - Dev-T","routePath":"/2013/07/30/Sorting-Points-by-Polar-Angle/","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":63},{"text":"代码","id":"代码","depth":2,"charIndex":193},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":582}],"domain":"","frontmatter":{"layout":"post","title":"极角排序","date":"2013-07-30 00:00:00","categories":["算法"],"tags":["算法","计算几何","姿势"]},"version":""},{"id":159,"title":"自守数（Automorphic Number）","content":"#\n\n> 简单了解一下自守数的相关性质，似乎没多大的应用。\n\n\n定义#\n\n如果某个数的平方的末尾几位数等于这个数，那么就称这个数为自守数。\n\n例如： 一位自守数：1、5和6 （5x5=25 6x6=36） 二位自守数：25和76 （25x25=625 76x76=5776） 三位自守数：625和376\n四位自守数：0625（非严格意义上的4位自守数）和9376 五位自守数：90625和09376 ...\n\n\n性质#\n\n通过上面的例子不难看出自守数的一个性质：\n\n以它为后几位的两个数相乘，乘积的后几位仍是这个数的自守数。\n\n也就是说我们可以通过（n+1）位自守数得到 n 位自守数，或者从 n 位自守数前面加上一个特定的数字 a 得到（n+1）位自守数。\n\n实际上，我们简化一下可以发现如下规律：\n\n> 5+6=11 25+76=101 625+376=1001 ...\n\n所以，两个n位自守数，他们的和等于10^n+1。\n\n\n我是自守数#\n\n下面给出两个2000位的自守数，方便使用的时候 cheat。\n\n\n\n\nTo Be Continuue#\n\n还要研究一下自守数生成的算法。\n\n\n参考内容#\n\n * 自守数_百度百科","routePath":"/2013/07/29/Automorphic-Number/","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":31},{"text":"性质","id":"性质","depth":2,"charIndex":205},{"text":"我是自守数","id":"我是自守数","depth":2,"charIndex":415},{"text":"To Be Continuue","id":"to-be-continuue","depth":2,"charIndex":458},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":494}],"domain":"","frontmatter":{"layout":"post","title":"自守数（Automorphic Number）","date":"2013-07-29 19:47:34","categories":["姿势"],"tags":["姿势","数论"],"description":"简单了解一下自守数的相关性质，似乎没多大的应用。"},"version":""},{"id":160,"title":"模平方根的解法——托内利－尚克斯算法（Tonelli–Shanks algorithm）","content":"#\n\n> 解决一类形如 x^2==n(mod p) 的问题。\n\n\n定义#\n\n给定奇素数p和正整数x（1<=x<=p-1）, 如果存在一个整数y，1<=y<=p-1, 使得x ≡ y * y (mod p) ，则称y是x的模p平方根。\n举例说明： 63是55的模103平方根，因为有：63 * 63 ≡ 3969 ≡ 55 (mod 103)。\n\n\n算法#\n\n托内利－尚克斯算法（Tonelli–Shanks algorithm）可以解决这一类问题。算法流程如下：\n\n输入： 奇素数p和正整数x（1<=x<=p-1）\n\n输出：\n\n> 设 $p-1 = Q2^S$ ， Q 为奇数。如果 S = 1 ,那么结果就为 $R = ±n^{(p+1)/4}$ ; 随机选取 z 使得\n> z对p的勒让德符号等于-1，那么设 $c = z^Q$ ; 设 $R = n^{(Q+1)/2}$ ， $t = n^Q$ ， $M=S$ ; Loop\n> \n> > 如果 t = 1 ，返回结果 R ; 否则 找一个i , 0＜i＜M ，使得 $t^{2^i} = t^{1<\n\n托内利－尚克斯算法是概率算法，返回正确解的概率为1/2。算法的渐进时间复杂度为O((log p)^4)。\n\n\n代码#\n\n给出一个代码加深一下理解。ural1132\n\n\n\n\n勒让德符号#\n\n勒让德符号 是一个形如这样的分段函数：\n\n\n\n若 a 是 p 的二次剩余，则返回 1 ; a 是模 p 的二次非剩余，返回 -1 ; a 是 p 的公约数，返回 0 。\n\n对于二次剩余，有一个欧拉判别法：\n\n欧拉（Euler）判别法： 若 a 是模 p 的平方剩余， 则 $a^{(p-1)/2} = 1 \\pmod{p}$ 若 a 是模 p 的平方非剩余， 则\n$a^{(p-1)/2} = -1 \\pmod{p}$\n\n\n参考内容#\n\n * 模平方根_百度百科\n * Tonelli–Shanks Algorithm 二次剩余系解法 (Ural 1132. Square Root) - AC_Von\n * Tonelli–Shanks algorithm - Wikipedia, the free encyclopedia\n * 二次剩余(quadratic residue) - 冷镜瘦朱颜的日志","routePath":"/2013/07/28/tonellishanks-algorithm/","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":32},{"text":"算法","id":"算法","depth":2,"charIndex":173},{"text":"代码","id":"代码","depth":2,"charIndex":534},{"text":"勒让德符号","id":"勒让德符号","depth":2,"charIndex":565},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":785}],"domain":"","frontmatter":{"layout":"post","title":"模平方根的解法——托内利－尚克斯算法（Tonelli–Shanks algorithm）","date":"2013-07-28 00:00:00","categories":["算法"],"tags":["算法","数论"]},"version":""},{"id":161,"title":"对一道面试题目 f(f(n))==-n 的理解","content":"#\n\n> 这是一道技术面试题目，其中隐含着很多思想。\n\n不知道大家有没有见过这道题目，一开始自己也没看明白是什么意思，后来根据他人的描述，也大体了解了一些内容了。\n\n\n题目描述#\n\n> Design a function f, such that:\n> \n> f(f(n)) == -n Where n is a 32 bit signed integer; you can't use complex\n> numbers arithmetic.\n> \n> If you can't design such a function for the whole range of numbers, design it\n> for the largest range possible.\n\n大体意思就是：\n\n能不能设计一个函数f(n)，n是int32，让f(f(n))==-n对所有n成立？\n要求不允许使用复数类的运算，不限制语言。如果不存在满足整个int的f(n)，那么尽可能让它对更多int32范围的n成立。\n\n\n题目思路#\n\n\n方法1#\n\n对于支持内置状态的函数的语言，我们可以在函数的内部定义一个静态变量，然后让它根据调用次数进行变化。\n\n\n\n这种方法能适用于除了 INT_MIN 之外的所有 32 比特整数。对于 INT_MIN，求负会导致溢出，也即 f(f(INT_MIN)) = INT_MIN。\n\n\n方法2#\n\n参考方法1的内容，我们可以设计一个全局变量保存这些参数。\n\n\n\n这两种方法算是一种捷径了。但是如果没有捷径可以走呢？\n\n\n方法3#\n\n第三种方法就是从数字本身入手，将数字扩充来保存次数信息。我们可以拿一个 BIT 来储存这样的信息。\n\n\n\n这种解法，头 32 比特用来存储 n，第 33 比特用来存储状态信息。它适用于 32 BIT的所有整数，包含了 Int32.MinValue 和\nInt32.MaxValue。\n\n\n方法4#\n\n假设一定要写一个 int f(int) 的函数，那么在哪里可以存储状态信息呢？在哪里可以存储究竟 f 是被执行了奇数次还是偶数次？\n\n可以考虑用奇偶性和正负性来保存这个状态信息。\n\n> f(n) = 2n(abs(n) % 2) - n + sgn(n)\n\n证明 f(f(n)) = -n：\n\n> 若是 n 是一个正奇数，那么令 n = 2k + 1。则：\n> \n> f(f(n)) = f(f(2k + 1)) = f( 2 * (2k + 1) - (2k + 1) + 1) = f(2k + 2)) = f(2 *\n> (2k + 2) * 0 - (2k + 2) + 1) = f(-2k - 1) = -n\n> \n> 若是 n 是一个正偶数，那么令 n = 2k。则：\n> \n> f(f(n)) = f(f(2k)) = f(-2k + 1)) = f(2 * (-2k + 1) - (-2k + 1) - 1) = f(-2k) =\n> -n\n> \n> 若是 n 是一个负奇数，那么令 n = 2k + 1。则：\n> \n> f(f(n)) = f(f(2k + 1)) = f( 2 * (2k + 1) - (2k + 1) - 1) = f(2k)) = f(2 * (2k)\n> * 0 - (2k) - 1) = f(-2k - 1) = -n\n> \n> 若是 n 是一个负偶数，那么令 n = 2k。则：\n> \n> f(f(n)) = f(f(2k)) = f(-2k - 1)) = f(2 * (-2k - 1) - (-2k - 1) + 1) = f(-2k) =\n> -n\n\n转换成 C# 代码如下：\n\n\n\n因为这里用到 2 * n 的运算，所以函数不适用于所有的 32 比特整数。了解到 2n(abs(n) % 2) - n 的目的其实是为了调整 n\n的正负号，可以把代码修改成如下：\n\n\n\n这样，这个函数就能适用于除了 Int32.MinValue 和 Int32.MaxValue 之外所有的 32 比特整数了。\n\n\n参考内容#\n\n * math - Interview question: f(f(n)) == -n - Stack Overflow\n * 技术面试题：f(f(n)) == -n - 百科教程网\n * 挑战 f(f(n)) = -n - CSDN论坛","routePath":"/2013/06/29/ffn-equ-n/","lang":"","toc":[{"text":"题目描述","id":"题目描述","depth":2,"charIndex":83},{"text":"题目思路","id":"题目思路","depth":2,"charIndex":455},{"text":"方法1","id":"方法1","depth":3,"charIndex":463},{"text":"方法2","id":"方法2","depth":3,"charIndex":604},{"text":"方法3","id":"方法3","depth":3,"charIndex":671},{"text":"方法4","id":"方法4","depth":3,"charIndex":821},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1708}],"domain":"","frontmatter":{"layout":"post","title":"对一道面试题目 f(f(n))==-n 的理解","date":"2013-06-29 00:00:00","categories":["姿势"],"tags":["其它","面试"]},"version":""},{"id":162,"title":"斐波那契数列（Fibonacci）性质及拓展","content":"#\n\n> 斐波那契数列，一个简单而神秘的序列。\n\n斐波那契数列（Fibonacci）相信大家一定很熟悉了，下面简单介绍一下斐波那契数列的一些内容。\n\n\n定义#\n\n这样的序列称为斐波那契数列：\n\n\n\n斐波那契数列还有一个通项公式：\n\n$$a_n= \\frac{1}{\\sqrt{5}}\\left [ {\\left ( {\\frac{1+\\sqrt{5}}{2}} \\right\n)^n-{}\\left ( {\\frac{1-\\sqrt{5}}{2}} \\right )^n} \\right ]$$\n\n最初斐波那契数列是由兔子的繁殖问题转化而来的，表示的是在理想状态下第n个月兔子的数目。当然这不是本文讨论的重点。\n\n\nFibonacci数列的性质#\n\n 1. gcd(fib(n),fib(m))=fib(gcd(n,m))\n\n证明：\n可以通过反证法先证fibonacci数列的恣意相邻两项一定互素，然后可证n>m时gcd(fib(n),fib(m))=gcd(fib(n-m),fib(m))，\n递归即可\n求gcd(fib(n),fib(m))=gcd(fib(k),fib(l))，最后k=l，不然继承递归。K是通过展转相减法求出，易证k=gcd(n,m)，所以g\ncd(fib(n),fib(m))=fib(gcd(n,m))。\n\n 2.  如果fib(k)能被x整除，则fib(k * i)都可以被x整除。\n 3.  f(0)+f(1)+f(2)+…+f(n)=f(n+2)-1\n 4.  f(1)+f(3)+f(5)+…+f(2n-1)=f(2n)\n 5.  f(2)+f(4)+f(6)+…+f(2n) =f(2n+1)-1\n 6.  [f(0)]^2+[f(1)]^2+…+[f(n)]^2=f(n)·f(n+1)\n 7.  f(0)-f(1)+f(2)-…+(-1)^n·f(n)=(-1)^n·[f(n+1)-f(n)]+1\n 8.  f(m+n)=f(m-1)·f(n-1)+f(m)·f(n)\n 9.  [f(n)]^2=(-1)^(n-1)+f(n-1)·f(n+1)\n 10. f(2n-1)=[f(n)]^2-[f(n-2)]^2\n 11. 3f(n)=f(n+2)+f(n-2)\n 12. f(2n-2m-2)[f(2n)+f(2n+2)]=f(2m+2)+f(4n-2m) [ n〉m≥-1,且n≥1]\n\n\n斐波那契素数（Fibonacci Prime）#\n\n斐波那契素数是指：若某Fibonacci数与任何与它小的Fibonacci数互质，那么就称这个数为Fibonacci素数。\n\n哪些数才是斐波那契数列素数呢？\n\n 1. F(3)和F(4)是Fibonacci素数；从F(5)开始，某项为Fibonacci质数当且仅当它的项数为质数\n 2. 第k小的Fibonacci素数是以素数数列中的第k个数为项数的Fibonacci数( 除F(3)和F(4)之外 )\n 3. 反例：F(2)=1，不是Fibonacci素数；F(4)=3不满足第二条，但是它是Fibonacci素数\n\n最终结论：Fibonacci序列中的第3,4,5,7,11,13,17,19,23,29,...为Fibonacci素数。\n\nps:证明神马的大家可以看参考资料。\n\n\n与杨辉三角的关系#\n\n将杨辉三角左对齐，将同一斜行的数加起来，即得一数列1、1、2、3、5、8、……\n\n\n参考内容#\n\n * 证明nullfibonacci数列的性质(ZOJ3707) - xinyuyuanm\n * fibonacci数列的性质(ZOJ3707) - ACdreamers\n * 【原】斐波那契质数(Fibonacci Prime)详解 - Allen Sun\n * 斐波那契数列_百度百科","routePath":"/2013/06/02/fib/","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":75},{"text":"Fibonacci数列的性质","id":"fibonacci数列的性质","depth":2,"charIndex":307},{"text":"斐波那契素数（Fibonacci Prime）","id":"斐波那契素数fibonacci-prime","depth":2,"charIndex":1018},{"text":"与杨辉三角的关系","id":"与杨辉三角的关系","depth":2,"charIndex":1388},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1441}],"domain":"","frontmatter":{"layout":"post","title":"斐波那契数列（Fibonacci）性质及拓展","date":"2013-06-02 00:00:00","categories":["姿势"],"tags":["数论","姿势"]},"version":""},{"id":163,"title":"A^B mod C（指数循环节）的应用","content":"#\n\n> 一个公式里面藏有好多的秘密。\n\n指数循环节，用于简化大数次幂的运算。简单来说就是一个公式：\n\n$${A}^{x}\\ {mod}\\ {c}={A}^{(x\\ {mod}\\ phi(c)+phi(c))}\\ mod\\ c$$\n\n注意： 应用条件是 $x>=phi(c)$\n\n对于指数循环节的一些证明，可以参考AC大牛的证明，这里只是提一下指数循环节的应用问题。\n\n\nA^B mod C 的形式#\n\n这个首先取C的欧拉函数，对于满足 $A>=phi(C)$ 直接套用公式就可以简化次幂的运算。再加个快速幂就可以更快了。。。\n\n如果不满足公式应用的条件，也不要灰心，因为直接求解就可以了。\n\n\nA^a1^a2^... mod C 的形式#\n\n这个是最纠结的一种形式，基本思路就是递归分解每一个子指数的形式。\n\n这里需要递归调用的形式是f(ai,phi(m))，起始调用为f(a0,C)；\n\n先贴个代码加深一下理解。【例hdu2837】\n\n\n\n这里有几个地方不好理解：\n\n 1. 每次递归下去的时候，要取余的是phi(m)，而非m。这与公式有关，想一下最初的时候总的取余为C，但是指数的时候，如果存在循环节，我们套用公式之后指数的取\n    余就变成phi(C)了，就这样一层一层递归下去。\n 2. 要保证应用指数循环节之后，返回指数的范围是1..m。这里可以假想一下，如果为0，那么上层的结果就是1了，这样能保证再上层的结果正确吗？反正我是不能保证。\n 3. 判断使用条件。指数循环节需要判断使用条件，这一点是非常重要的。所以才有了要检查a^b>=c这一个函数。\n\n如果你能很好的理解这种方式了，就可以想象一个更简单的方式。\n\n\n\n这种方法只是将判断使用条件与计算结合起来，简化了递归计算的函数。\n\n当然，对于这种类型的问题，还可以使用非递归的方式进行求解。基本思路是首先将每次需要 mod 的数提前计算放到一个数组中，然后根据递归的深度来判断需要使用的\nmod 数。其实好多大牛都是写的非递归的形式，可以参考参考。。。\n\n\n参考内容#\n\n * 【关于 A^x = A^(x % Phi(C) + Phi(C)) (mod C) 的若干证明】【指数循环节】_AekdyCoin的空间\n * 雍哥为啥不告诉我博客呀。。。","routePath":"/2013/05/22/a-pow-b-mod-c/","lang":"","toc":[{"text":"A^B mod C 的形式","id":"ab-mod-c-的形式","depth":2,"charIndex":185},{"text":"A^a1^a2^... mod C 的形式","id":"aa1a2-mod-c-的形式","depth":2,"charIndex":297},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":863}],"domain":"","frontmatter":{"layout":"post","title":"A^B mod C（指数循环节）的应用","date":"2013-05-22 00:00:00","categories":["算法"],"tags":["数论"]},"version":""},{"id":164,"title":"sscanf与sprintf","content":"#\n\n> sscanf与sprintf将字符串与其它类型连接起来，在一定程度上方便了字符串的处理。\n\n这两个函数所需要的头文件都包含在#include（C++）或者#include（C）。\n\n\nsscanf函数#\n\n函数原型：int sscanf ( const char * s, const char * format, ...);\n\n函数参数：\n\n> str - - 一个C字符串表示需要得到数据的数据源。 format - -\n> 一个C字符串表示数据的输入格式，可以参照scanf的形式。Ps：函数支持正则表达式。 ... (additional arguments) - -\n> 依照format的输入格式，函数将str中的相应部分转换成为对应的格式依次存入变量列表中。变量的数目至少要等于格式字符串中变量的数目，多余的变量将被忽略。\n\n**函数返回：**如果函数成功将会返回参数列表中被成功填充的变量的数目；失败的时候返回EOF/-1，遇到错误之前的变量也会被成功填充。\n\n示例代码：\n\n\n\nOutput:\n\n> Rudolph -> 12\n\n\nsprintf函数#\n\n函数原型：int sprintf ( char * str, const char * format, ... );\n\n函数参数：\n\n> str - - 用于指向一个C字符数组的指针，这个字符数组的大小应足以容纳需要放入变量的总长度。 format - - 格式字符串，用于指示放入 str\n> 的变量的格式。（可以参照 printf）。 ...(additional arguments) - -\n> 通过format指示的格式形式，将此处的变量“放入”str中，变量的数目至少为格式字符串中标示变量的数量。多出的变量将被忽略。\n\n**函数返回：**如果函数成功，将会返回字符串的长度，长度不包括字符串末尾的结束标志'\\0'；失败时返回一个负数。\n\n示例代码：\n\n\n\nOutput:\n\n> [5 plus 3 is 8] is a string 13 chars long\n\n\n参考内容#\n\n * sscanf - C++ Reference\n * sprintf - C++ Reference","routePath":"/2013/05/18/sscanf-and-sprintf/","lang":"","toc":[{"text":"sscanf函数","id":"sscanf函数","depth":2,"charIndex":96},{"text":"sprintf函数","id":"sprintf函数","depth":2,"charIndex":479},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":881}],"domain":"","frontmatter":{"layout":"post","title":"sscanf与sprintf","date":"2013-05-18 00:00:00","categories":["编程语言"],"tags":["c/c++","姿势"]},"version":""},{"id":165,"title":"欧拉（euler）定理与欧拉函数","content":"#\n\n> 欧拉函数还是次要的，重要的是隐藏在它背后那些不可告人的秘密。\n\n\n欧拉函数#\n\n欧拉函数是数论中很重要的一个函数。欧拉函数是指：对于一个正整数 n ，小于 n 且和 n 互质的正整数（包括 1）的个数，记作 φ(n) 。\n\n\n欧拉定理#\n\n对于互质的正整数 a 和 n ，有 $a^{\\phi(n)} \\equiv 1 \\bmod n$ 。\n\n\n费马定理#\n\n若正整数 a 与素数 p 互质，则有 $a^{p-1} \\equiv 1 \\bmod{p}$ 。\n\n\n欧拉函数公式#\n\n\n$p^k$的欧拉函数#\n\n对于给定的一个素数 p ，φ(p)=p-1。则对于正整数 $n=p^k$ ， $\\phi(p)=p^k-p^{k-1}$\n\n证明：\n\n小于 $p^k$ 的正整数个数为 $p^{k - 1}$ 个，其中和 $p^k$ 不互质的正整数有 ${p * 1,p * 2,...,p * (p^{k -\n1}-1)}$ 共计 $p^{k - 1} - 1$ 个。所以 $\\phi(n) = p^k - 1 - (p^{k - 1} - 1) = p^k -\np^{k - 1}$ 。\n\n\np * q的欧拉函数#\n\n假设 p, q 是两个互质的正整数，则 p * q 的欧拉函数为\n\n$φ(p * q) = φ(p) * φ(q)$ ， $gcd(p, q) = 1$ 。\n\n证明：\n\n设 n=p * q ；\n\n则与n互质的数的集合为 $Zn = {1, 2, 3, ... , n - 1} - {p, 2p, ... , (q - 1) * p} - {q, 2q,\n... , (p - 1) * q}$\n\n则 $φ(p * q) = φ(n) = (n - 1) - (q - 1) - (p - 1) = (p - 1) * (q -1) = φ(p) *\nφ(q)$ 。\n\n\n任意正整数的欧拉函数#\n\n任意一个整数 n 都可以表示为其素因子的乘积为：\n\n$$n=\\prod_{i=1}^Ip_i^{k_i}$$ (I 为 n 的素因子的个数)\n\n根据前面两个结论，很容易得出它的欧拉函数为：\n\n$$\\phi(n)=\\prod_{i=1}^Ip_i^{k_i-1} (p_i-1)=n\\prod_{i=1}^I(1-1/p_i)$$\n\n对于任意 n > 2 ， $2 | Φ(n)$ ，因为必存在 $p_i -1$ 是偶数。\n\n\n欧拉phi函数代码#\n\n直接求解\n\n\n\n打表\n\n\n\n欧拉+素数\n\n\n\n再来一发\n\n\n\n已经求解出素数表\n\n\n\n\n参考内容#\n\n * 数论的欧拉定理证明 & 欧拉函数公式 - 蓬篙人的专栏\n * 欧拉函数公式 - Ray's Blog\n * 欧拉函数_百度百科\n * 欧拉函数 - 维基百科，自由的百科全书\n * 欧拉 phi 函数代码 - Rappy的专栏-火魂の闇狱\n * 筛法求素数+分解质因子+欧拉函数+求约数 - touzani的专栏\n * 欧拉函数打表（备忘） - Lazy\n * 打表快速求欧拉函数_poj2478_ZS_918\n * FZU_1759 Super A^B mod C - Chris_Home","routePath":"/2013/05/15/euler-and-phi/","lang":"","toc":[{"text":"欧拉函数","id":"欧拉函数","depth":2,"charIndex":37},{"text":"欧拉定理","id":"欧拉定理","depth":2,"charIndex":117},{"text":"费马定理","id":"费马定理","depth":3,"charIndex":177},{"text":"欧拉函数公式","id":"欧拉函数公式","depth":2,"charIndex":235},{"text":"$p^k$的欧拉函数","id":"pk的欧拉函数","depth":3,"charIndex":245},{"text":"p * q的欧拉函数","id":"p--q的欧拉函数","depth":3,"charIndex":497},{"text":"任意正整数的欧拉函数","id":"任意正整数的欧拉函数","depth":3,"charIndex":796},{"text":"欧拉phi函数代码","id":"欧拉phi函数代码","depth":2,"charIndex":1022},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1078}],"domain":"","frontmatter":{"layout":"post","title":"欧拉（euler）定理与欧拉函数","date":"2013-05-15 00:00:00","categories":["姿势"],"tags":["数论","欧拉"]},"version":""},{"id":166,"title":"约瑟夫（joseph）问题","content":"#\n\n> 约瑟夫是一个经典的问题，提供了一种简单的递推思路。\n\n\n基础知识#\n\n约瑟夫问题，又被叫做“约瑟夫斯变换”，是一个很经典的动态规划方面的问题。问题的描述是这样的。有n个人，从1开始编号至n，这n个人排成一个圆圈，从第一个人开始报数\n，报到m的人出列，剩下的人重新围成圆圈，从出列的那个人的下一个人开始又从1开始报数，以此类推。直到圆圈里最后剩下一个人为止，现在求这个人的编号。\n\n\n问题解法#\n\n关于约瑟夫问题，主要有以下几种形式：\n\n\n朴素解法（模拟）#\n\n根据问题描述，模拟出圈动作的进行。建议写成循环链表的形式。\n\n这种方法可以解出每次出圈的人在 整个圈 的编号，时间复杂度有点高。\n\n代码示例（数组模拟）：\n\n\n\n\n求解最后出圈的人#\n\n为了讨论方便，先把问题稍微改变一下，并不影响原意：\n\n问题描述：n个人（编号0~(n-1）），从0开始报数，报到（m-1）的退出，剩下的人继续从0开始报数。求胜利者的编号。\n\n我们知道第一个人（编号一定是（m-1） mod n) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m mod n的人开始）：\n\nk k+1 k+2 ... n-2,n-1,0,1,2,... k-2\n\n并且从k开始报0。\n\n现在我们把他们的编号做一下转换：\n\n\n\n变换后就完完全全成为了（n-1）个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？\n！！变回去的公式很简单，相信大家都可以推出来：x'=(x+k) mod n\n\n如何知道（n-1）个人报数的问题的解？对，只要知道（n-2）个人的解就行了。（n-2）个人的解呢？当然是先求（n-3）的情况 ----\n这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：\n\n令f表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]\n\n递推公式\n\n> f[1]=0;\n> \n> f=(f+m) mod i; (i>1)\n\n有了这个公式，我们要做的就是从1-n顺序算出f的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1。\n\n\n\n\n求解每次出圈的人#\n\n求解每次出圈的人，当然这不是严格意义上的每次出圈的人，而是出圈的人在当前圈的编号。\n\n则第i轮出局的人为f(i)=(f(i-1)+m-1)%(n-i+1),f(0)=0; f(i) 表示当前子序列中要退出的那个人（当前序列编号为0~(n-i));\n\n代码示例：\n\n\n\n\n其它#\n\n还有其它一些变形，比如每隔一人退出的特殊情况，这个可以进一步优化，太菜了，看不懂。（参考《具体数学》7-14页）\n\n\n参考内容#\n\n * 约瑟夫环学习小记 - whyorwhnt的专栏\n * 约瑟夫环问题的公式推导 | 江山如画\n * 扩展约瑟夫问题的解法_哀·时光机\n * 约瑟夫问题_百度百科","routePath":"/2013/05/13/joseph/","lang":"","toc":[{"text":"基础知识","id":"基础知识","depth":2,"charIndex":32},{"text":"问题解法","id":"问题解法","depth":2,"charIndex":195},{"text":"朴素解法（模拟）","id":"朴素解法模拟","depth":3,"charIndex":223},{"text":"求解最后出圈的人","id":"求解最后出圈的人","depth":3,"charIndex":316},{"text":"求解每次出圈的人","id":"求解每次出圈的人","depth":3,"charIndex":924},{"text":"其它","id":"其它","depth":3,"charIndex":1070},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1134}],"domain":"","frontmatter":{"layout":"post","title":"约瑟夫（joseph）问题","date":"2013-05-13 00:00:00","categories":["姿势"],"tags":["数学","递推"]},"version":""},{"id":167,"title":"高斯消元","content":"#\n\n> 高斯消元提供了一种简单的方法解决方程组联立的问题。\n\n\n基础知识#\n\n高斯消元是线性代数中的一类方法，也是一种算法，用来求解线性方程组，并可以求出矩阵的秩，以及求解出可逆方阵的逆矩阵。\n\n根据初等变换原理，将增广矩阵转换为行阶梯矩阵，然后回代求出方程的解。\n\n在程序设计中，常用的算法是： (我们设方程组中方程的个数为equ，变元的个数为var)\n\n 1. 把方程组转换成增广矩阵。\n 2. 利用初等行变换来把增广矩阵转换成行阶梯阵。 枚举k从0到equ – 1，当前处理的列为col(初始为0)\n    ，每次找第k行以下(包括第k行)，col列中元素绝对值最大的列与第k行交换。如果col列中的元素全为0，那么则处理col + 1列，k不变。\n 3. 转换为行阶梯阵，判断解的情况。\n\n> ① 无解 当方程中出现(0, 0, …, 0, a)的形式，且a != 0时，说明是无解的。 ② 唯一解 条件是k =\n> equ，即行阶梯阵形成了严格的上三角阵。利用回代逐一求出解集。 ③ 无穷解 条件是k < equ，即不能形成严格的上三角形，自由变元的个数即为equ –\n> k，但有些题目要求判断哪些变元是不缺定的。\n\n这里单独介绍下这种解法：\n\n首先，自由变元有var - k个，即不确定的变元至少有var -\nk个。我们先把所有的变元视为不确定的。在每个方程中判断不确定变元的个数，如果大于1个，则该方程无法求解。如果只有1个变元，那么该变元即可求出，即为确定变元。\n\n以上介绍的是求解整数线性方程组的求法，复杂度是O(n^3)。浮点数线性方程组的求法类似，但是要在判断是否为0时，加入EPS，以消除精度问题。\n\n\n贴代码#\n\n代码（雍哥修改的不知道谁的）——整型参数型\n\n\n\n对于浮点参数型，基本实现形式差不多，只不过求解的时候注意点浮点数的运算就行了。\n\n代码（来自这里）：\n\n\n\n\n主要解决的问题#\n\n高斯消元主要解决这几类问题：\n\n\n普通的消元问题#\n\n给出几个方程组，求出每个解。一般套用模板就可以了。\n\n\n染色问题#\n\n一个方格只有01两种状态，改变其中一个方格会影响其它周围方格的状态。\n\n对于这种问题，首先要建立方程组。关于方程组的建立，首先要把方格转换成一行，然后构造一个 n * n 的矩阵。那么对于矩阵中的( i,j\n)就表示j可以影响i的状态。\n\n那么如果 i 能影响 j 点，就应该把( j,i )设为1。\n\n用高斯消元的时候，注意把中间过程 mod 2，因为只有 01 两种状态。\n\n\nmod p问题#\n\n方程组对p取余，相当于一个线性同余型的问题吧。\n\n对于这种问题，分为两种情况：\n\n 1. 如果p为 质数 ，这样就可以参考染色问题，根据性质，直接将中间过程 mod p，最后得出的解保证小于 p 即可。\n 2. 如果p为 非质数 ，这样就不能对中间过程 mod\n    p，因为这样会形成循环节而扩大解集。我也没有什么好的解决方法，暂时可以中间过程不要进行任何取余操作。求解集的时候可以枚举 0~p\n    的数字，满足同余关系就可以作为解的一部分。这个也要注意解不要超过 p 。\n\n\n找出逆矩阵#\n\n高斯消元法可以用来找出一个可逆矩阵的逆矩阵。设 A 为一个 N * N 的矩阵，其逆矩阵可被两个分块矩阵表示出来。将一个 N * N 单位矩阵放在 A\n的右手边，形成一个 N * 2N 的分块矩阵 B = [ A,I ] 。经过高斯消元法的计算程序后，矩阵 B 的左手边会变成一个单位矩阵 I ，而逆矩阵 A -\n1 会出现在B 的右手边。\n\n假如高斯消元法不能将A 化为三角形的格式，那就代表A 是一个不可逆的矩阵。\n\n应用上，高斯消元法极少被用来求出逆矩阵。高斯消元法通常只为线性方程组求解。\n\n\n参考内容#\n\n * 高斯消元法(Gauss_Elimination)_分析_&_题解_&_模板_漂流萍\n * 高斯消元模板——浮点参数型 - zhj5chengfeng\n * 高斯消元模板——整数参数型 - zhj5chengfeng\n * 高斯消元法_百度百科","routePath":"/2013/05/12/gauss/","lang":"","toc":[{"text":"基础知识","id":"基础知识","depth":2,"charIndex":32},{"text":"贴代码","id":"贴代码","depth":2,"charIndex":715},{"text":"主要解决的问题","id":"主要解决的问题","depth":2,"charIndex":801},{"text":"普通的消元问题","id":"普通的消元问题","depth":3,"charIndex":828},{"text":"染色问题","id":"染色问题","depth":3,"charIndex":866},{"text":"mod p问题","id":"mod-p问题","depth":3,"charIndex":1064},{"text":"找出逆矩阵","id":"找出逆矩阵","depth":3,"charIndex":1317},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1576}],"domain":"","frontmatter":{"layout":"post","title":"高斯消元","date":"2013-05-12 00:00:00","categories":["姿势"],"tags":["数论","数学","线性代数"]},"version":""},{"id":168,"title":"二分矩阵快速幂及其应用","content":"#\n\n> 有些东西很慢，然后就变得很快了。二分矩阵快速幂是解决矩阵幂乘的一种方法，主要思想是采用分治方法。\n\n先来一个简单的数的幂运算。\n\n\n\n对于矩阵的幂运算，先给出一个模板。\n\n更新内容：在矩阵加法和矩阵乘法中，原先的取余方式if(a.m[i][j]>=MOD)a.m[i][j]%=MOD;存在负数BUG。还是使用朴素的取余方式吧。\n\n\n\n（经测试，运算符重载的效率比上边的效率低）\n\n\n\n\n参考内容#\n\n * Matrix67: My Blog » Blog Archive » 十个利用矩阵乘法解决的经典题目\n * 矩阵题目 zz - 为生存而奔跑","routePath":"/2013/05/10/dichotomous-matrix-fast-power-and-its-application/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":198}],"domain":"","frontmatter":{"layout":"post","title":"二分矩阵快速幂及其应用","date":"2013-05-10 00:00:00","categories":["算法"],"tags":["数论","矩阵"]},"version":""},{"id":169,"title":"矩阵","content":"#\n\n> 矩阵是个神奇的东西，你可以用它来干这个，这个，还有这个。\n\n数学上，一个 m×n 的矩阵是一个由 m 行 n 列元素排列成的矩形阵列。矩阵里的元素可以是数字、符号或数学式。\n\n大小相同（行数列数都相同）的矩阵之间可以相互加减，具体是对每个位置上的元素做加减法。矩阵的乘法则较为复杂。两个矩阵可以相乘，当且仅当第一个矩阵的列数等于第二个矩\n阵的行数。矩阵的乘法满足结合律和分配律，但不满足交换律。\n\n\n矩阵的基本运算#\n\n\n加减法#\n\nm×n 矩阵 A 和 B 的和（差）：A±B 为一个 m×n 矩阵，其中每个元素是A和B相应元素的和（差），\n\n$$(A ± B){i,j} = A{i,j} ± B_{i,j}$$\n\n其中 1 ≤ i ≤ m , 1 ≤ j ≤ n.\n\n\n数乘#\n\n标量 c 与矩阵 A 的数乘：cA 的每个元素是 A 的相应元素与 c 的乘积， $$(cA){i,j} = c · A{i,j}$$\n\n\n转置#\n\nm×n 矩阵 A 的转置是一个 n×m 的矩阵，记为$A^{T}$（有些书中也记为$A^{tr}$ 或$^{t}A$、$A'$），其中的第i个行向量是原矩阵 A\n的第 i 个列向量；或者说，转置矩阵 AT 第 i 行第 j 列的元素是原矩阵 A 第 j 行第 i 列的元素。\n\n\n矩阵乘法#\n\n两个矩阵的乘法仅当第一个矩阵 A 的列数和另一个矩阵 B 的行数相等时才能定义。如 A 是 m×n 矩阵和B是 n×p 矩阵，它们的乘积 AB 是一个 m×p\n矩阵，它的一个元素 $$ [AB]{i,j} = A{i,1}B_{1,j} + A_{i,2}B_{2,j} + ... + A_{i,n}B_{n,j} =\n\\sum^{n}{r=1}A{i,r}B_{r,j} $$ 其中 1 ≤ i ≤ m, 1 ≤ j ≤ p。\n\n矩阵的乘法满足结合律和对矩阵加法的分配律（左分配律和右分配律）：\n\n * 结合律：(AB)C = A(BC),\n * 左分配律： (A + B)C = AC + BC,\n * 右分配律： C(A + B) = CA + CB.\n\n矩阵的乘法与数乘运算之间也满足类似结合律的规律；与转置之间则满足倒置的分配律。\n\n$$c(AB) =(cA)B = A(cB)$$ $$(AB)^T = B^TA^T$$\n\n矩阵乘法不满足交换律。一般来说，矩阵A及B的乘积AB存在，但BA不一定存在，即使存在，大多数时候 AB ≠ BA。\n\n\n线性变换#\n\n这里的线性变换我们可以简单理解为： 给定n个点，m个操作，构造O(m+n)的算法输出m个操作后各点的位置。操作有平移、缩放、翻转和旋转\n\n\n平移#\n\n$$\\begin{pmatrix}1 & 0 & p\\ 0 & 1 & q\\ 0 & 0 & 1\\end{pmatrix}.\\begin{pmatrix}x \\\ny \\ 1 \\end{pmatrix}=\\begin{pmatrix}x+p \\ y+q \\ 1 \\end{pmatrix}$$\n\n\n缩放#\n\n$$\\begin{pmatrix}L & 0 & 0\\ 0 & L & 0\\ 0 & 0 & 1\\end{pmatrix}.\\begin{pmatrix}x \\\ny \\ 1 \\end{pmatrix}=\\begin{pmatrix}x * L \\ y * L \\ 1 \\end{pmatrix}$$\n\n\n上下翻转#\n\n$$\\begin{pmatrix}1 & 0 & 0\\ 0 & -1 & 0\\ 0 & 0 & 1\\end{pmatrix}.\\begin{pmatrix}x\n\\ y \\ 1 \\end{pmatrix}=\\begin{pmatrix}x \\ -y \\ 1 \\end{pmatrix}$$\n\n\n左右翻转#\n\n$$\\begin{pmatrix}-1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 0 & 1\\end{pmatrix}.\\begin{pmatrix}x\n\\ y \\ 1 \\end{pmatrix}=\\begin{pmatrix}-x \\ y \\ 1 \\end{pmatrix}$$\n\n\n绕原点旋转#\n\n$$\\begin{pmatrix}cos\\alpha & -sin\\alpha & 0\\ sin\\alpha & cos\\alpha & 0\\ 0 & 0 &\n1\\end{pmatrix}.\\begin{pmatrix}x \\ y \\ 1 \\end{pmatrix}=\\begin{pmatrix}xcos\\alpha\n- ysin\\alpha \\ xsin\\alpha + ycos\\alpha \\ 1 \\end{pmatrix}$$\n\n\n常用矩阵#\n\n\n单位矩阵#\n\n单位矩阵是主对角线都为1，其余都为0的一个方阵。 性质： 任何矩阵与单位矩阵相乘都等于它本身。\n\n$$E=\\begin{pmatrix}1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 0 & 1\\end{pmatrix}$$\n\n\n逆矩阵#\n\n逆矩阵是与$A$相乘得到单位矩阵$E$的一个矩阵。记作$A^{-1}$ 性质：$A·A^{-1}=E$ 求法：\n\n * 伴随矩阵法\n\n如果矩阵$A$可逆，则$A^{-1}=\\frac{A^{ * }}{|A|}$其中是的伴随矩阵。 注意：$A^{ * }$中元素的排列特点是$A^{ *\n}$的第$k$列元素是$A$的第$k$行元素的代数余子式。要求得$A^{ * }$即为求解$A$的余因子矩阵的转置矩阵。\n\n * 初等变换法\n\n初等变换求逆矩阵就是将原矩阵后再续写上一个同阶单位矩阵。然后将原矩阵化为单位矩阵，这个过程的同时就将单位矩阵化为了逆矩阵。\n\n$$\\begin{pmatrix}1 & 0 & 1 & 1 & 0 & 0 \\ -1 & 1 & 1 & 0 & 1 & 0 \\2 & -1 & 1 & 0\n& 0 & 1\\end{pmatrix}\\rightarrow \\begin{pmatrix}1 & 0 & 0 & 2 & -1 & -1 \\ 0 & 1 &\n0 & 3 & -1 & -2 \\0 & 0 & 1 & -1 & 1 & 1\\end{pmatrix}$$\n\n * Excel法\n\n 1. 输入的矩阵值，例如在（A1:B2）\n 2. 在工作表中【选取】（反白）另一块大小（例C1:D2）也是的空白格；\n 3. 找到指令【公式】→【数学与三角函数】→【MINVERSE】（意为Matrix Inverse）；\n 4. 在【MINVERSE】→【函数引数】→【Array（=阵列）】中点一下鼠标，然后选取一开始已输入值的矩阵（A1:B2）；\n 5. 同时按下Ctrl+Shift+Enter，使已选取的空白格成为使用同一公式之矩阵；\n 6. 便会得到逆矩阵$A^{-1}$.\n\n\n参考内容#\n\n * 矩阵 - 维基百科，自由的百科全书\n * Matrix67: My Blog » Blog Archive » 十个利用矩阵乘法解决的经典题目","routePath":"/2013/05/10/matrix/","lang":"","toc":[{"text":"矩阵的基本运算","id":"矩阵的基本运算","depth":2,"charIndex":204},{"text":"加减法","id":"加减法","depth":3,"charIndex":215},{"text":"数乘","id":"数乘","depth":3,"charIndex":342},{"text":"转置","id":"转置","depth":3,"charIndex":417},{"text":"矩阵乘法","id":"矩阵乘法","depth":2,"charIndex":562},{"text":"线性变换","id":"线性变换","depth":2,"charIndex":1048},{"text":"平移","id":"平移","depth":3,"charIndex":1125},{"text":"缩放","id":"缩放","depth":3,"charIndex":1278},{"text":"上下翻转","id":"上下翻转","depth":3,"charIndex":1435},{"text":"左右翻转","id":"左右翻转","depth":3,"charIndex":1588},{"text":"绕原点旋转","id":"绕原点旋转","depth":3,"charIndex":1741},{"text":"常用矩阵","id":"常用矩阵","depth":2,"charIndex":1970},{"text":"单位矩阵","id":"单位矩阵","depth":3,"charIndex":1978},{"text":"逆矩阵","id":"逆矩阵","depth":3,"charIndex":2102},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2862}],"domain":"","frontmatter":{"layout":"post","title":"矩阵","date":"2013-05-10 00:00:00","categories":["姿势"],"tags":["数学","线性代数"]},"version":""},{"id":170,"title":"欧几里得+扩展的欧几里得算法+线性同余方程+中国剩余定理","content":"#\n\n> 欧几里得、扩展的欧几里得算法、线性同余方程、中国剩余定理，这几个都是好重要的算法呀。\n\n\n欧几里得算法#\n\n欧几里得算法，用于计算两个数的最大公约数。主要有两种实现方法，辗转相除法和辗转相减法。\n\n代码实现：\n\n\n\n或者\n\n\n\n\n扩展欧几里得算法#\n\n对于不完全为 0 的非负整数 a 和 b，gcd(a,b)表示 a,b 的最大公约数，必然存在整数对 x,y ，使得 gcd(a,b)=ax+by。\n\n扩展欧几里得实质上是在欧几里得算法的基础上找到 a*x+b*y=gcd(a,b)\n这个式子的一个解。由于gcd(a,b)是a,b的线性组合，这点上面已经说明了（即存在 x,y 使得gcd(a,b)=ax+by），所以显然存在这样的线性组合。\n\n考虑这样的一个递归过程。其中 a%b=a-a/b * b\n\n 1. 当 b=0 时，显然能够找到一组满足的解:x=1,y=0。(注意gcd(a,0)=a)。\n 2. 当 b!=0 时，设 d'=b * x'+(a%b) * y' ，其中b和a%b，就是欧几里得算法下一步递归的两个变量。根据欧几里得知道：\n    d=gcd(a,b)=d'=gcd(b,a%b)\n    ，我们将式子里的d=d'改写成x,y来表示，那么就是：d=b*x'+(a-[a/b]*b)*y'=a*y'+b(x'-[a/b]*y')\n    (按a,b展开)。我们就能够得到x,y跟x',y'的关系，即 x=y' ，y=x'-[a/b] * y'。\n\n我们在欧几里德算法中按这样的递推关系进行递归就能解出x,y了。\n\n代码实现：\n\n\n\n\n线性同余方程#\n\n线性同余方程是最基本的同余方程，“线性”表示方程的未知次数是一次，基本的形式是\n\n> ax≡b (mod n) 或者 a*x+b*y = n\n\n对于方程 a*x+b*y=n 有整数解的条件是（n%gcd(a,b)==0）即n能够被 a 和 b\n的最大公约数整除（n=gcd(a,b)*k）记作gcd(a,b)|n，可以理解为扩展欧几里得定理。\n\n所以方程 a*x+b*y=n ；我们可以先用扩展欧几里德算法求出一组 x,y 。也就是 a*x+b*y=gcd(a,b) ；然后两边同时除以 gcd(a,b)\n，再乘以 n 。这样就得到了方程 a*x*n/gcd(a,b)+b*y* n/gcd(a,b)=n ；我们也就找到了方程的一个解。\n\n还有一个定理：若 gcd(a,b)=1 ，且 x0,y0 为 a*x+b*y=n 的一组解，则该方程的任一解可表示为：x=x0+b*t ， y=y0-a*t\n；且对任一整数 t，皆成立。\n\n在实际问题中，我们往往被要求去求最小整数解，所以我们就可以将一个特解 x ， t=b/gcd(a,b) ， x=(x%t+t)%t ；就可以了。\n\n总结一下：\n\n> 对于方程 ax+by=c 即ax=c(mod b) 定义：t=gcd(a,b); 有解条件 c%t==0 特解x=x * c/t;\n> 最小解x=(x%c+c)%c; 解系 x=x+k * b/t;y=y-k * a/t;（k为整数）\n\n\n中国剩余定理#\n\n对于同余方程组：\n\nx=a1 （mod m1）； x=a2 （mod m2）；\n\n方程组有一个小于m（m1，m2的最小公倍数）的非负整数解的充分必要条件是（a1-a2）%（m1，m2）==0 ，同样利用扩展欧几里德算法。\n\n两式联立：a1+m1*y=a2+m2*z。\n\n则：a1-a2=m2*z-m1*y ; 这样就可以了解出z和y，则：x=a2+m2*z；\n\n现在我们将其推广到一般情形：（设m1,m2,···,mk两两互素）\n\nx=a1（mod m1）; x=a2（mod m2）; ··· x=ak（mod mk）;其在 M=m1*m2*···*mk ;中有唯一整数解。\n\n记Mi=M/mi;因为（Mi,mi）=1,故有两整数pi,qi满足Mi*pi+mi*qi=1，如果记ei=Mi*pi;那么：ei=0（mod mj）,j!=i;\nei=1（mod mj）,j=i;\n\n很明显，e1*a1+e2*a2+···+ek*ak 就是方程的一个解，加减M倍后就可以得到最小非负整数解了。\n\n代码样例（除数两两互质）：\n\n\n\n对于m之间不互质的情况，可以想方法将两个同余方程合并： 两个方程合并的一种方法： x = c1 (mod b1） x = c2 (mod b2)\n此时b1,b2不必互质的。\n\n显然可以得到 x=k1*b1+c1 x=k2*b2 + c2， 两个方程合并一下就可以得到：k1*b1=c2-c1(mod b2)，\n这样可以设g=gcd(b1,b2),于是就有b1/g*k1-b2/g*k2=(c2-c1)/g， 显然判断(c2-c1)/g是否为整数就能判断是否存在解，\n这样在经过类似的变换就能得到k1=K(mod（b2/g))， 最后得到x=K*b1+c1(mod(b1*b2/g))。\n\n代码实现（除数不一定互质）:\n\n\n\n\n参考内容#\n\n * 欧几里得+扩展的欧几里得算法+线性同余方程+中国剩余定理 - lhfight的专栏\n * 辗转相除法 - 维基百科，自由的百科全书\n * 线性同余方程 - 维基百科，自由的百科全书","routePath":"/2013/05/07/euclid-and-extended-euclid-algorithm-and-linear-congruent-equation-and-chinese-remainder-theorem/","lang":"","toc":[{"text":"欧几里得算法","id":"欧几里得算法","depth":2,"charIndex":49},{"text":"扩展欧几里得算法","id":"扩展欧几里得算法","depth":2,"charIndex":119},{"text":"线性同余方程","id":"线性同余方程","depth":2,"charIndex":685},{"text":"中国剩余定理","id":"中国剩余定理","depth":2,"charIndex":1312},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":2097}],"domain":"","frontmatter":{"layout":"post","title":"欧几里得+扩展的欧几里得算法+线性同余方程+中国剩余定理","date":"2013-05-07 00:00:00","categories":["算法"],"tags":["数论","算法","acm"]},"version":""},{"id":171,"title":"来两发整人命令","content":"#\n\n> 今天不小心又发现了一个有意思的东东，我不会告诉你我是在微博上看到的。有胆量可以来试试呀。\n\n\nNo.1 :() { :|:& }; :#\n\n也许你见过或者没有见过这个命令:() { :|:& }; :，这个在linux下运行会出现神奇的效果。建议不要尝试。。。\n\n好了，玩笑少说，其实我也没有试过，跪求各位勇士准备好Power键前来尝试。 这个命令的原理就是定义一个函数，不断制造后台任务。这个函数名就是一个冒号。\n\n写的通俗点就是：\n\n\n\n\nNo.2 echo '十人|日一|十十o' | sed 's/.../&\\n/g' #\n\n这个命令输出几行字符串，没多大的用途。\n\n> 十人| 日一| 十十o\n\n原命令从表面上来看是将 '...' 替换为 '&\\n' ，但是 '...' 是表示每匹配三个字符， '&' 是匹配项的占位符， '\\n'\n就这是换行符了，所以输出是每三个字符就换一行。“幹! ”\n\n还是不太好理解， Linux 的 shell 还有好多值得研究的地方呀。\n\n\n参考内容#\n\n * :() { :|:& }; : - 打天打鸭 - ITeye技术网站\n * linux :() { :|:& }; : 什么意思_百度知道","routePath":"/2013/05/01/linux-joke-shell/","lang":"","toc":[{"text":"No.1 `:() { :|:& }; :`","id":"no1-----","depth":2,"charIndex":-1},{"text":"No.2 `echo '十人|日一|十十o' | sed 's/.../&\\n/g' `","id":"no2-echo-十人日一十十o--sed-sng-","depth":2,"charIndex":-1},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":445}],"domain":"","frontmatter":{"layout":"post","title":"来两发整人命令","date":"2013-05-01 00:00:00","categories":["服务器与系统"],"tags":["linux","shell","姿势"]},"version":""},{"id":172,"title":"STL中next_permutation的应用","content":"#\n\n今天看见了一个很新奇的东东 next_permutation ，就拿来试了试。\n\n在 C++ Reference 中查看了一下 next_permutation 的函数声明：\n\n> #include bool next_permutation( iterator start, iterator end );\n> \n> The next_permutation() function attempts to transform the given range of\n> elements [start,end) into the next lexicographically greater permutation of\n> elements. If it succeeds, it returns true, otherwise, it returns false.\n\n可以看出 next_permutation 的返回类型为布尔型，意思是是否成功求解出当前排列的下一个排列。\n\n\n\n恩，就这么多了。","routePath":"/2013/05/01/stl_next_permutation/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"STL中next_permutation的应用","date":"2013-05-01 00:00:00","categories":["编程语言"],"tags":["c/c++","算法","stl"],"description":"next_permutation是STL模板中用于求解排列数的一个算法。","reference":[{"title":"使用STL的next_permutation函数生成全排列(C++) - Slyar Home","url":"http://www.slyar.com/blog/stl_next_permutation.html"}]},"version":""},{"id":173,"title":"Poisson分布（泊松分布）与极大似然估计","content":"#\n\n> 概率统计学过去一年了，似乎都忘光了。。。果然还学要复习复习呀。\n\n\n泊松分布#\n\n泊松分布适合于描述单位时间内随机事件发生的次数的概率分布。如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现\n的故障数、自然灾害发生的次数、DNA序列的变异数、放射性原子核的衰变数等等。\n\n注意到的是泊松分布适合离散型的概率统计，这与正态分布不同。\n\n泊松分布的概率函数为：\n\n$$ P(X=k)=\\frac{e^{-λ}λ^k}{k!} $$\n\n泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生率。\n\n\n极大似然估计#\n\n谈到了泊松分布，不得不想想极大似然估计了。极大似然估计又叫最大似然估计，它用来求一个样本集的相关概率密度函数的参数。对于泊松分布，就是求解λ的近似值。\n\n大体的求解过程：\n\n首先列出对数似然函数：\n\n$$\\begin{matrix} L(λ) & = & log \\prod_{i=1}^n f(k_i|λ) \\ & = & \\sum_{i=1}^n\nlog(\\frac{e^{-λ}λ^k}{k!}) \\ & = & -nλ+(\\sum_{i=1}^n k_i)log(λ)-log(\\sum_{i=1}^n\nk_i!)\\end{matrix}$$\n\n对函数L取相对于λ的导数并令其等于0：\n\n$$ \\frac{d}{dλ}L(λ)=0 \\Leftrightarrow -n+(\\sum_{i=1}^n k_i)\\frac{1}{λ}=0 $$\n\n解得λ从而得到一个驻点：\n\n$$ λ_{MLE}=\\frac{1}{n}\\sum_{i=1}^n k_i $$\n\n\n参考内容#\n\n * 泊松分布 - 维基百科","routePath":"/2013/04/30/poisson-distribution-and-maximum-likelihood-estimate/","lang":"","toc":[{"text":"泊松分布","id":"泊松分布","depth":2,"charIndex":38},{"text":"极大似然估计","id":"极大似然估计","depth":2,"charIndex":280},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":722}],"domain":"","frontmatter":{"layout":"post","title":"Poisson分布（泊松分布）与极大似然估计","date":"2013-04-30 00:00:00","categories":["姿势"],"tags":["数学","概率"]},"version":""},{"id":174,"title":"Java输入输出外挂","content":"#\n\n> 看似好多大牛都写这种，是不是这就是传说中的 Java 输入输出外挂！！！\n\n今天翻别人写的代码的时候无意中发现了这个，TA 写的 Java 版本的代码中，好多都用了这个。让我稍微看看这究竟是何方神圣。\n\n\n\n这段代码重写了 Java 的输入流的 nextInt() 方法，通过一个 StringTokenizer 类来实现相应的功能。\n\nStringTokenizer 是一个用来分隔 String 的应用类，相当于 VB 的 split\n函数。这里还是不过分介绍了。具体介绍还是查看另一篇日志吧Java类StringTokenizer的说明。\n\n这样一来，整个代码的输入过程就很明确了，通过StringTokenizer类中的方法来分割字符串，然后将字符串粘贴为对应的数据类型返回。\n\n\n参考内容#\n\n * 代码出处 by ftiasch","routePath":"/2013/04/27/java-input-output/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":349}],"domain":"","frontmatter":{"layout":"post","title":"Java输入输出外挂","date":"2013-04-27 00:00:00","categories":["编程语言"],"tags":["java","姿势"]},"version":""},{"id":175,"title":"Java类StringTokenizer的说明","content":"#\n\n> 看起来 StringTokenizer 类好神奇的样子，不管有没有用先了解了解再说。\n\n\n声明#\n\n> java.util 类StringTokenizer java.lang.object ┖java.util.StringTokenizer\n\n所有已实现的接口：\n\nEnumeration\n\nStringTokenizer 是一个用来分隔 String 的应用类，相当于 VB 的 split 函数。\n\nstring tokenizer 类允许应用程序将字符串分解为标记。tokenization 方法比 StreamTokenizer\n类所使用的方法更简单。StringTokenizer 方法不区分标识符、数和带引号的字符串，它们也不识别并跳过注释。\n\n\n方法声明#\n\n\n构造函数#\n\n\n\n第一个参数就是要分隔的 String ，第二个是分隔字符集合，第三个参数表示分隔符号是否作为标记返回，如果不指定分隔字符，默认的是：\\t\\n\\r\\f\n\n\n核心方法#\n\n\n\n其实就是三个方法，返回分隔字符块的时候也可以指定分割符，而且以后都是采用最后一次指定的分隔符号。\n\n\n多余方法#\n\n\n\n这个类实现了 Enumeration 接口，所以多了这么两个方法，其实根本没有必要实现这个接口 它的名字就叫 StringTokenizer ，返回一个\nObject 就没有什么意思了。\n\n\n方法说明#\n\n\n构造函数#\n\n 1. StringTokenizer(String\n    str)：构造一个用来解析str的StringTokenizer对象。java默认的分隔符是“空格”、“制表符(‘\\t’)”、“换行符(‘\\n’)”、“\n    回车符(‘\\r’)”。\n 2. StringTokenizer(String str, String\n    delim)：构造一个用来解析str的StringTokenizer对象，并提供一个指定的分隔符。\n 3. StringTokenizer(String str, String delim, boolean\n    returnDelims)：构造一个用来解析str的StringTokenizer对象，并提供一个指定的分隔符，同时，指定是否返回分隔符。\n\n\n方法#\n\n说明：\n\n 1. 所有方法均为 public；\n 2. 书写格式 Style：［修饰符］　<返回类型><方法名（［参数列表］）>\n\n如：static int parseInt(String s)\n表示：此方法（parseInt）为类方法（static），返回类型为（int），方法所需参数为String类型。\n\n 1. int countTokens()：返回nextToken方法被调用的次数。如果采用构造函数1和2，返回的就是分隔符数量(例2)。\n 2. boolean hasMoreTokens() ：返回是否还有分隔符。\n 3. boolean hasMoreElements() ：结果同2。\n 4. String nextToken()：返回从当前位置到下一个分隔符的字符串。\n 5. Object nextElement() ：结果同4。\n 6. String nextToken(String delim)：与4类似，以指定的分隔符返回结果。\n\n例1：\n\n代码:\n\n\n\n结果为：\n\n\n\n例2:\n\n代码:\n\n\n\n结果为：\n\n\n\n\n参考内容#\n\n * StringTokenizer类的使用 - riyunzhu的专栏\n * 类 StringTokenizer - Rollen Holt","routePath":"/2013/04/27/java-stringtokenizer/","lang":"","toc":[{"text":"声明","id":"声明","depth":2,"charIndex":49},{"text":"方法声明","id":"方法声明","depth":2,"charIndex":336},{"text":"构造函数","id":"构造函数","depth":3,"charIndex":344},{"text":"核心方法","id":"核心方法","depth":3,"charIndex":430},{"text":"多余方法","id":"多余方法","depth":3,"charIndex":490},{"text":"方法说明","id":"方法说明","depth":2,"charIndex":595},{"text":"构造函数","id":"构造函数-1","depth":3,"charIndex":603},{"text":"方法","id":"方法","depth":3,"charIndex":957},{"text":"参考内容","id":"参考内容","depth":2,"charIndex":1435}],"domain":"","frontmatter":{"layout":"post","title":"Java类StringTokenizer的说明","date":"2013-04-27 00:00:00","categories":["编程语言"],"tags":["java","姿势"]},"version":""},{"id":176,"title":"由一个整人秘籍引发的新知识","content":"#\n\n> LINE、FILE、#line、__func__的用法\n\n今天无意中在人人上看到一个整人的状态：\n\n> 程序员幽默： silentbicycle： C语言整人秘笈。 #define true (LINE % 2 == 0) （陈晓鸣在百度 推荐）\n\n于是对其中的 __LINE__ 表示好奇。通过万能的度娘找到了相应姿势。\n\nC语言中可以使用 __LINE__ 指示本行语句在源文件中的位置信息：\n\n例\n\n\n\n输出结果：\n\n> 7 8 9\n\n除了 __LINE__ 之外还有 __FILE__ 用于指示本行语句所在源文件的文件名。\n\n例\n\n\n\n输出结果：\n\n> c:\\documents and settings\\administrator\\桌面\\test.c\n\n还可以通过语句 #line 来重新设定 __LINE__ 的值，举例如下：\n\n\n\n编译执行后输出结果为：\n\n> 202 203 204\n\n另外 gcc 还支持 __func__ ,它指示所在的函数，但是这个关键字不被 windows 下的 vc6.0 支持，举例如下：\n\n\n\n其编译后输出结果为\n\n> this is print by function main\n\n注意 “#line”、 “__LINE__”、 “__FILE__\" 及 “__func__\" 都是大小写敏感的。\n\n\n参考内容#\n\n * C语言中的__FILE__、__LINE__和#line\n * C语言中的__FILE__、__LINE__和#line","routePath":"/2013/04/25/cpp-joking-code/","lang":"","toc":[{"text":"参考内容","id":"参考内容","depth":2,"charIndex":579}],"domain":"","frontmatter":{"layout":"post","title":"由一个整人秘籍引发的新知识","date":"2013-04-25 00:00:00","categories":["编程语言"],"tags":["c/c++","姿势"]},"version":""},{"id":177,"title":"博客功能插件测试","content":"#\n\n> 用来测试一下博客的相关插件，主要是高亮插件和代码插件，表格样式还有公式的显示。\n\n\n代码高亮测试#\n\nHTML样式代码\n\n\n\nMarkdown样式代码\n\n\n\n\n数学公式测试#\n\n测试一下数学公式能否正常显示。\n\n$$ e^x = \\sum_{n=0}^\\infty \\frac{x^n}{n!} = \\lim_{n\\rightarrow\\infty} (1+x/n)^n\n$$\n\n\n表格测试#\n\nHEAD1 HEAD1 HEAD1   HEAD2 HEAD2 HEAD2   HEAD3 HEAD3 HEAD3   HEAD4 HEAD4 HEAD4\nrow1text1           row1text3           row1text3           row1text4\nrow2text1           row2text3           row2text3           row2text4","routePath":"/2013/04/23/blog-model-test/","lang":"","toc":[{"text":"代码高亮测试","id":"代码高亮测试","depth":2,"charIndex":46},{"text":"数学公式测试","id":"数学公式测试","depth":2,"charIndex":84},{"text":"表格测试","id":"表格测试","depth":2,"charIndex":195}],"domain":"","frontmatter":{"layout":"post","title":"博客功能插件测试","date":"2013-04-23 00:00:00","categories":["实验室"],"tags":["测试"]},"version":""},{"id":178,"title":"Hello World！","content":"#\n\n> 第一篇日志，一般都会写Hello World的吧。\n\n这是我的第一篇日志，博客配置起来好麻烦呀。","routePath":"/2013/04/22/first-hello-world/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"Hello World！","date":"2013-04-22 00:00:00","categories":["网站"],"tags":["随笔"]},"version":""}]